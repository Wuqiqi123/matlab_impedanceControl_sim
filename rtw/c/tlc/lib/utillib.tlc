%%
%%
%%
%% Copyright 1994-2018 The MathWorks, Inc.
%%
%% Abstract:
%%   This TLC library file contains the general purpose utility functions.
%%

%if EXISTS("_UTILLIB_") == 0
%assign _UTILLIB_ = 1

%function SLibCallServiceFunction(sid, serviceName, portIdx, portType, dworkIdx, payload, outVar) Output
  %%assign mdlRefDWorkArg = FcnGetModelRefDWorkArg()
  %% This function is valid only for non-CPP encap codegen
  %assert !SLibRTWCPPClassActive() 
  %assign blkIdx = SLibGetBlockIdxFromSID(System[0], sid)
  %assert blkIdx > -1
  %assign dwRec = System[0].Block[blkIdx].DWork[dworkIdx]
  %%assign dwRec = ::CompiledModel.DWorks.DWork[dworkIdx]
  %assign dworkvar = System[0].Block[blkIdx].Identifier + "_" + dwRec.Name
  %assign serviceFcn = LibGetDWorkStruct() + "." + dworkvar + "." + serviceName
  %assign host = LibGetDWorkStruct() + "." + dworkvar + "." + "host"

  %if !ISEMPTY(outVar)
    %<serviceFcn>(%<host>, %<payload>, %<outVar>)
  %else
    %<serviceFcn>(%<host>, %<payload>)
  %endif
%endfunction

%function SLibGetBlockIdxFromSID(system, sid) void
  %foreach blkIdx = system.NumBlocks
    %if ISFIELD(system.Block[blkIdx], "TLCBlockSID") && ...
      system.Block[blkIdx].TLCBlockSID == sid
      %return blkIdx
    %endif
  %endforeach
  %return -1
%endfunction %%SLibGetBlockFromSID
  
%% DocFunction{Code Configuration Functions}: LibGetModelName ==================
%% Abstract:
%%   Return name of the model (no extension)
%%
%function LibGetModelName() void
  %return ::CompiledModel.OrigName
%endfunction

%% Function: FcnSFDworkInfo ==================================================
%% Abstract:
%%   Helper function to generate meaningful comments for Stateflow dworks
%%
%function FcnSFDworkInfo(srcBlk, dwRec, dwIdx) void
  %generatefile "chartSource" "%<srcBlk.SFInfo.ChartTLCFile>.tlc"
  %assign chartDataMap = ...
    GENERATE_TYPE(srcBlk, "ChartDataMap", "chartSource", ...
    System[dwRec.SigSrc[0]])
  %if ISFIELD(chartDataMap, "ChartData")
    %assign info = chartDataMap.ChartData[dwIdx]
    %assign path = info.Path
    %assign description = info.Description
    %switch description
      %case "ChartLocal"
        %return "Local data '" + path + "'"
        %break
      %case "Constant"
        %return "Constant data '" + path + "'"
        %break
      %case "StateIsActive"
        %if ISEMPTY(path)
          %return "Chart is active"
        %else
          %return "State '" + path + "' is active"
        %endif
        %break
      %case "StateActiveChild"
        %if ISEMPTY(path)
          %return "Active substate of the chart"
        %else
          %return "Active substate of '" + path + "'"
        %endif
        %break
      %case "EmlPersistent"
      %case "EmlPersistentSentinel"
        %return "DWork:" + info.Description + ":" + info.SrcLocation +  " %<dwIdx+1>"
        %break
      %default
        %return "DWork %<dwIdx+1>"
        %break
    %endswitch
  %endif
%endfunction

%% Function: SLibTrackCanIOForSLF
%% This function is intended to handle a Stateflow
%% exported graphical function's access of a global
%% canonical I/O variable. It is a Stateflow parallel to Simulink's
%% logic in commonpass.tlc (look for ConnectedToSimulinkFunction)
%% and WriteCanonicalInputArgDefs in rtwgen_signal.cpp
%function SLibTrackCanIOForSLF(argName) void
  %assign baseSystemIdx = GetBaseSystemIdx()
  %if IsModelReferenceTarget()
    %assign intf = System[baseSystemIdx].Interface
    %foreach idx = intf.NumCanonicalInputArgDefs
      %assign argdef = intf.CanonicalInputArgDef[idx]
      %if argdef.GlobalIdentifier == argName
        %assign argdef.ConnectedToSimulinkFunction = "yes"
        %<LibAccessThisSysFcnArg(argdef, "Start", "Global")>
        %<SLibAccessArg(argdef, "Start", 0, 0)>
        %return
      %endif
    %endforeach
    %foreach idx = intf.NumCanonicalOutputArgDefs
      %assign argdef = intf.CanonicalOutputArgDef[idx]
      %if argdef.GlobalIdentifier == argName
        %assign argdef.ConnectedToSimulinkFunction = "yes"
        %<LibAccessThisSysFcnArg(argdef, "Start", "Global")>
        %<SLibAccessArg(argdef, "Start", 0, 0)>
        %return
      %endif
    %endforeach
  %endif
  %return
%endfunction

%% Function: SLibReferencedBy ==================================================
%% Abstract:
%%   Routine to return referencing paths
%%
%function SLibReferencedBy(dataRec) void
  %assign comment = ""
  %% If dataRec is a model parameter, return SLibGenModelPrmDefnComment
  %if ISFIELD(dataRec, "RecordType") && ...
    dataRec.RecordType == "ModelParameter"
    %assign comment = SLibGenModelPrmDefnComment(dataRec)

  %% Otherwise, comment is graphical path (except for global DSM)
  %else
    %if ISFIELD(dataRec, "BlkZcRecIdx")
      %assign dataGrBlk = SLibGrBlock(::CompiledModel.ZcRec.BlkZcRec[dataRec.BlkZcRecIdx].GrSrc)
    %else
      %assign dataGrBlk = ISFIELD(dataRec, "GrSrc") ? SLibGrBlock(dataRec.GrSrc) : []
    %endif
    %if ISFIELD(dataRec, "OwnerBlockName") && !ISEMPTY(dataRec.OwnerBlockName)
      %assign comment = "'" + dataRec.OwnerBlockName + "'"
    %elseif !ISEMPTY(dataGrBlk)
      %assign gen2Shared = TLC_FALSE
        %if ISFIELD(dataRec, "VarGroupIdx")
          %assign varGrp = ::CompiledModel.VarGroups.VarGroup[dataRec.VarGroupIdx[0]]
          %assign sysIdx = varGrp.SysIdx
          %assign instIdx = 0
          %if ISFIELD(varGrp,"InstanceIdx")
            %assign instIdx = varGrp.InstanceIdx
          %endif
          %if LibSystemIsContainedWithinReusedLibraryFcn(sysIdx, instIdx)
            %assign gen2Shared = TLC_TRUE
          %endif
        %endif
      %% Only Shared files should have comments pointing to libraries
      %if ISFIELD(dataGrBlk, "RLSCommentName") && gen2Shared 
        %assign comment = dataGrBlk.RLSCommentName
      %else
        %if BlockCommentType == "BlockPathComment"
          %if ISFIELD(dataGrBlk, "OrigInlineVarBlkName")
            %assign comment = "'" + dataGrBlk.OrigInlineVarBlkName + "'"
          %else
            %assign comment = "'" + dataGrBlk.Name + "'"
          %endif
        %else
          %assign comment = SLibGrBlockSIDComment(dataGrBlk)
        %endif
      %endif
    %elseif ISFIELD(dataRec, "RecordType") && ...
      dataRec.RecordType == "DWork"
      %assign comment = LibBlockDWorkOwnerComment(dataRec)
    %elseif ISFIELD(dataRec, "RecordType") && ...
      ISFIELD(dataRec, "BlockName") && ...
      (dataRec.RecordType == "ExternalInput" || dataRec.RecordType == "ExternalOutput")
      %if ISFIELD(dataRec, "GrSrc")
        %assign comment = SLibGrBlockCommentName(dataRec.GrSrc)
      %else
	%assign comment = "'" + dataRec.BlockName + "'"
      %endif
    %else
      %assign comment = ""
    %endif

    %% If SLCI is on, enhance block output and dwork comments
    %assign slciOn = ::CompiledModel.SLCI == "on"
    %if slciOn && ISFIELD(dataRec, "StorageClass") ...
      && (dataRec.StorageClass == "Auto") && ISFIELD(dataRec, "RecordType")

      %if dataRec.RecordType == "BlockOutput"
        %assign portIdx = dataRec.GrSrc[2]
        %if portIdx >= 0
          %assign comment = comment + " (Output %<portIdx+1>) "
        %endif

      %elseif dataRec.RecordType == "DWork"

        %assign dwIdx = dataRec.GrSrc[2]
        %if dataRec.GrSrc[1] != -1 && ...
          !dataRec.DWorkForDimSize          
          %assign grBlk = SLibGrBlock(dataRec.GrSrc)
          %if grBlk.Type == "Stateflow"
            %assign slBlk = ::CompiledModel.System[dataRec.SigSrc[0]].Block[dataRec.SigSrc[2]]
            %% Don't generate special comments for dworks added to the subsystem shell
            %% (e.g. subsysRanBc) instead of the S-Function actually implementing the chart
            %if slBlk.Type == "S-Function"
              %assign dworkInfo = FcnSFDworkInfo(slBlk, dataRec, dwIdx)
              %assign comment = comment + " (%<dworkInfo>) "
              %return comment
            %endif
          %endif
        %endif

        %if dwIdx >= 0
          %assign comment = comment + " (DWork %<dwIdx+1>) "
        %endif

      %endif

    %endif

  %endif

  %return comment

%endfunction

%% Function: FcnDataStoreMemoryNonAutoData ===================================
%% Abstract:
%%   Is this data a data store with non-auto storage class?
%%
%function FcnDataStoreMemoryNonAutoData(data) void
  %if data.RecordType == "DWork"
    %if data.StorageClass == "ExportedGlobal" || ...
      data.StorageClass == "ImportedExtern" || ...
      data.StorageClass == "ImportedExternPointer" || ...
      data.StorageClass == "Custom"
      %return data.IsDataStoreMemory
    %endif
  %endif
  %return TLC_FALSE
%endfunction

%% Function: FcnDataStoreMemoryVariantCondition =================================
%% Abstract:
%%   Routine to return variant condition associated with a data store
%%
%function FcnDataStoreMemoryVariantCondition(data) void
  %assert data.RecordType == "DWork"
  %assert data.IsDataStoreMemory == 1
  %return data.DSMVariantCondition
%endfunction

%% Function: SLibDataGetInlineVariantCondition =========================================
%% Abstract:
%%  Return the net variant condition associated with a data record's existance
%%  net variant condition in this case = the data record's condition && the specific callside condition
%%  used to guard block I/O initialization
%%  TopTester: test/toolbox/simulink/variants/inlineVariants/variantSource/systemtests/tmblockio_initialization_simple.m
%%  TopTester: test/toolbox/simulink/variants/inlineVariants/variantSource/systemtests/tmblockio_initialization_subsystem.m
%%
%function SLibDataGetInlineVariantCondition(data) void
  
    %assign sysCondition = ""
    %assign condition = ""
    %% Time-saving short cut applicable 99%+ of the time
    %if (!::CompiledModel.HasCodeVariants || !::CompiledModel.HasInlineVariants)
      %return condition %% return empty
    %endif

    %assign indices = SLibGetSystemAndCallSideIndex(data)
    %assign sysIdx = indices[0]
    %assign instIdx = indices[1]
    %if instIdx == -1
      %assign instIdx = 0
    %endif
    %assign conditions = ::CompiledModel.System[sysIdx].NetInlineVariantPreprocessorInstanceConditions
    %if !ISEMPTY(conditions)
      %assign sysCondition = conditions[instIdx]
    %endif

    %if (!ISEMPTY(data) && ISFIELD(data, "VariantCondition"))
	 %assign condition = data.VariantCondition
    %endif
	
    %if !ISEMPTY(condition) && !ISEMPTY(sysCondition)
       %%AND the subsystem condition to this element condition
       %assign condition = "(" + condition + ") && (" + sysCondition + ")"
    %elseif !ISEMPTY(sysCondition)
       %assign condition = sysCondition
    %endif
    %%else sysCondition is empty then return condition whether it is empty or not

  %return condition
   
%endfunction


%% Function: SLibDataPreprocessorStuff =========================================
%% Abstract:
%%  Return ppIf and ppFi associated with a data record's existance
%%
%function SLibDataPreprocessorStuff(data) void
  %assign result = ["", ""]

  %% Time-saving short cut applicable 99%+ of the time
  %if !::CompiledModel.HasCodeVariants
    %return result %% return empty
  %endif

  %% Model parameters ...
  %if data.RecordType == "ModelParameter"
    %% If constant data with no padder active
    %% return ppIf based on block usage
    %if (data.InConstSection || data.InConstWithInitSection)
      %if ::CompiledModel.PadderActive
        %return result %% return empty
      %else
        %return FcnGetPreprocessorStuffForFlatModelParam(data)
      %endif
    %% If unstructured data, return ppIf based on block usage
    %elseif data.StorageClass == "ExportedGlobal" || ...
      data.StorageClass == "ImportedExtern" || ...
      data.StorageClass == "ImportedExternPointer"
      %return FcnGetPreprocessorStuffForFlatModelParam(data)
    %% If custom data, return ppIf based on block usage only for
    %% parametrized, unstructured data - play it safe (for now)
    %elseif data.StorageClass == "Custom"
      %assign cscDefn = SLibGetCSCDefForData(data)
      %if cscDefn.CSCType == "Unstructured" || ...
        (cscDefn.OwnerPackage == "mpt" && cscDefn.TLCFileName == "MPTUnstructured.tlc")
        %return FcnGetPreprocessorStuffForFlatModelParam(data)
      %else
        %return result %% return empty
      %endif
    %endif
    %% Otherwise (e.g. sc = Simulink global) continue on below
    %% based on vargroups
  %endif

  %% External I/O never has ppIf
  %if data.RecordType == "ExternalInput" || ...
    data.RecordType == "ExternalOutput"
    %return result %% return empty
  %endif

  %assign ppIf = ""
  %assign ppFi = ""

  %% DSM with non-auto storage optimizes its own way
  %if FcnDataStoreMemoryNonAutoData(data)
    %assign condition = FcnDataStoreMemoryVariantCondition(data)
    %if !ISEMPTY(condition)
      %assign ppIf = "#if " + condition
      %assign ppFi = "#endif"
    %endif
  %else
    %assign indices = SLibGetSystemAndCallSideIndex(data)
    %assign sysIdx = indices[0]
    %assign instIdx = indices[1]
    %if instIdx == -1
      %assign instIdx = 0
    %endif
    %assign conditions = ::CompiledModel.System[sysIdx].NetPreprocessorInstanceConditions
    %% NetPreprocessorConditionForDefaultVariantExists is "1" ony for default variants, if net-preprocessor
    %% condition contains  pre-processor conditions of non-default variants we will have it "0".
    %% so the comment '(default)' is  generated ony for default variants.
    %assign conditionForDefault = ::CompiledModel.System[sysIdx].NetPreprocessorConditionForDefaultVariantExists
    %if !ISEMPTY(conditions)
      %assign condition = conditions[instIdx]
      %if !ISEMPTY(condition)
        %if conditionForDefault
          %assign ppIf = "#if " + condition + "/* (default) */"
          %assign ppFi = "#endif" 
        %else
          %assign ppIf = "#if " + condition
          %assign ppFi = "#endif"
        %endif
      %endif
    %endif
  %endif
  %assign result[0] = ppIf
  %assign result[1] = ppFi
  %return result
%endfunction

%% Function: SLibIfSystemPreprocessorCondition =====================================
%% Abstract:
%%   Return a system's net opening preprocessor condition
%%
%function SLibIfSystemPreprocessorCondition(system) void
  %assign condition = system.SystemPreprocessorCondition
  %assign conditionForDefault = system.NetPreprocessorConditionForDefaultVariantExists
  %if ISEMPTY(condition)
    %return ""
  %else
    %% check if condition exist as default ( negation of all other conditions)
    %if conditionForDefault
      %return "#if %<condition> /* (default) */"
    %else
      %return "#if %<condition>"
    %endif
  %endif
%endfunction

%% Function: SLibEndIfSystemPreprocessorCondition ==================================
%% Abstract:
%%   Return a system's net closing preprocessor condition
%%
%function SLibEndIfSystemPreprocessorCondition(system) void
  %assign condition = system.SystemPreprocessorCondition
  %if ISEMPTY(condition)
    %return ""
  %else
    %return "#endif "
  %endif
%endfunction

%% Function: SLibIfLocalPreprocessorCondition ===================================
%% Abstract:
%%   Return a subsystem block's local opening preprocessor condition
%%
%function SLibIfLocalPreprocessorCondition(ssBlk) void
  %assign condition = ssBlk.LocalPreprocessorCondition
  %assign isDefault = ssBlk.IsDefaultVariant
  %if ISEMPTY(condition) && ...
     !ISEMPTY(isDefault)
     %% for default variant local pre-processor condition may not be present
     %% in that case we need to get the condition as negation of all other conditions
     %assign systemIdx = ssBlk.CallSiteInfo.SystemIdx
     %assign system = ::CompiledModel.System[systemIdx]
     %assign condition = system.SystemPreprocessorCondition
     %assign conditionForDefault = ::CompiledModel.System[systemIdx].NetPreprocessorConditionForDefaultVariantExists
     %if ISEMPTY(condition)
       %return ""
     %else
       %if conditionForDefault
          %return "#if %<condition> /* (default) */"
       %else
          %return "#if %<condition>"
       %endif
     %endif
  %else
    %if ISEMPTY(condition)
       %return ""
    %else
       %return "#if %<condition>"
    %endif
  %endif
%endfunction

%% Function: SLibEndIfLocalPreprocessorCondition ================================
%% Abstract:
%%   Return a subsystem block's local closing preprocessor condition
%%
%function SLibEndIfLocalPreprocessorCondition(ssBlk) void
  %assign condition = ssBlk.LocalPreprocessorCondition
  %assign isDefault = ssBlk.IsDefaultVariant
  %if ISEMPTY(condition) && ...
      !ISEMPTY(isDefault)
       %% for default variant local pre-processor condition may not be present
       %% in that case we need to get the comment (default) for the default variant.
       %assign systemIdx = ssBlk.CallSiteInfo.SystemIdx
       %assign system = ::CompiledModel.System[systemIdx]
       %assign condition = system.SystemPreprocessorCondition
       %if ISEMPTY(condition)
         %return ""
       %else
         %return "#endif"
       %endif
     %else
       %if ISEMPTY(condition)
         %return ""
       %else
         %return "#endif"
       %endif
     %endif
%endfunction

%% Function: FcnOredLocalPreprocessorCondition =========================
%% Abstract:
%%   Return OR'd local preprocessor condition for the subsystem
%%   block's of all instances of a system
%%
%function FcnOredLocalPreprocessorCondition(ssblk) void
  %assign childSysIdx = ssblk.CallSiteInfo.SystemIdx
  %assign childSys    = ::CompiledModel.System[childSysIdx]
  %assert (childSys.SystemIdx == childSysIdx)
  %assign siblingCallSites = childSys.CallSites
  %assign numSiblings = SIZE(siblingCallSites,0)
  %assign unconditionalInstance = TLC_FALSE
  %assign ppCondition = ""
  %assign previousCondition = ""
  %assign siblingCallSites = childSys.CallSites
  %assign comment = "/*" + SLibGetCallSitesComment(childSysIdx) + "*/"
  %foreach siblingIdx = numSiblings
    %assign siblingCS = siblingCallSites[siblingIdx]
    %assign siblingSS = System[siblingCS[2]].Block[siblingCS[3]]
    %assign siblingCondition = siblingSS.LocalPreprocessorCondition
    %if WHITE_SPACE(siblingCondition)
      %assign unconditionalInstance = TLC_TRUE
      %break
    %endif
    %if !ISEQUAL(siblingCondition, previousCondition)
      %assign previousCondition = siblingCondition
      %if !ISEMPTY(ppCondition)
        %assign ppCondition = ppCondition + " || "
      %endif
      %assign ppCondition = ppCondition + siblingCondition
    %endif
  %endforeach
  %if unconditionalInstance
    %return ""
  %else
    %return ppCondition
  %endif
%endfunction

%%
%% Function: SLibOredIfLocalPreprocessorCondition ========================
%% Abstract:
%%   Return OR'd local preprocessor condition for the subsystem
%%   block's of all instances of a system
%%
%function SLibOredIfLocalPreprocessorCondition(ssBlk) void
  %assign condition = FcnOredLocalPreprocessorCondition(ssBlk)
  %if ISEMPTY(condition)
    %return ""
  %else
    %return "#if " + condition
  %endif
%endfunction


%% Function: SLibEndOredIfLocalPreprocessorCondition =====================
%% Abstract:
%%   Return OR'd local preprocessor condition for the subsystem
%%   block's of all instances of a system
%%
%function SLibOredEndIfLocalPreprocessorCondition(ssBlk) void
  %assign condition = FcnOredLocalPreprocessorCondition(ssBlk)
  %if ISEMPTY(condition)
    %return ""
  %else
    %return "#endif"
  %endif
%endfunction

%% Function: SLibIsERTTarget ====================================================
%% Abstract:
%%   Return true if it is ERT target or target derived from ERT
%%   Note, this is different from SLibIsERTCodeFormat().
%%   ERT Target always uses ERTCodeFormat, but target that uses ERTCodeFormat
%%   is NOT always ERT target.
%%
%%   Questions: when use SLibIsERTTarget(), when use SLibIsERTCodeFormat?
%%     Use SLibIsERTTarget() if the feature is an ERT only feature.
%%     Use SLibIsERTCodeFormat() if you just need find out the code style.
%%
%%
%function SLibIsERTTarget() void
  %return ::CompiledModel.ConfigSet.IsERTTarget
%endfunction

%% Function: SLibIsCoderDictionaryActiveForDefaults =======================
%%   Is coder dictionary mapping active for function defaults?
%%
%function SLibIsCoderDictionaryActiveForDefaults() void
  %% Initialize Function always exists if there is mapping support for 
  %% entry point functions
  %return ISFIELD(::CompiledModel, "CoderDictionary") && ...
    ISFIELD(::CompiledModel.CoderDictionary, "FunctionDefaults")    
%endfunction

%% Function: SLibHasFcnCallRootInport===========================================
%% Abstract
%%  Does the model has at least one root inport that outputs Function Call
%function SLibHasFcnCallRootInport() void
  %return ISFIELD(::CompiledModel, "ExternalPortGroups") && ...
    (::CompiledModel.ExternalPortGroups.NumFcnCallPortGroups >  0)
%endfunction

%% Function: SLibIsExportFcnDiagram ===========================================
%% Abstract
%%  Is this an export function diagram
%function SLibIsExportFcnDiagram() void
  %return ISFIELD(::CompiledModel, "IsExportFcnDiagram") && ...
    (::CompiledModel.IsExportFcnDiagram == "yes")
%endfunction

%% Function: SLibIsReusableExportFcn ===========================================
%% Abstract
%%  Is this an export function diagram with reusable code packaging
%function SLibIsReusableExportFcn() void
  %return SLibIsExportFcnDiagram() && MultiInstanceERTCode && ...
    !GenerateClassInterface
%endfunction

%% Function: SLibIsTempModelGeneratedToExportFcn ==============================
%% Abstract
%%  Is this a temporary model generated during conversion from export
%%  function-call subsystems to an export function model
%function SLibIsTempModelGeneratedToExportFcn() void
  %return ISFIELD(::CompiledModel, "IsTempModelGeneratedToExportFcn") && ...
    (::CompiledModel.IsTempModelGeneratedToExportFcn == "yes")
%endfunction

%% Function: SLibIsExplicitPartitioningDiagram =================================
%% Abstract
%%  Is explicit partitioning enabled for this diagram
%function SLibIsExplicitPartitioningDiagram() void
  %return ISFIELD(::CompiledModel, "IsExplicitPartitioning") && ...
    (::CompiledModel.IsExplicitPartitioning == "yes")
%endfunction

%% Function: SLibIsExplicitPartitioningTID ====================================
%% Abstract
%%  Is this a tid corresponding to a partition
%function SLibIsExplicitPartitioningTID(tid) void
  %assign hasNonEmptyTaskName = TYPE(tid) == "Number" && tid >= 0 && ...
    ISFIELD(::CompiledModel.SampleTime[tid],"TaskName") && !ISEMPTY(::CompiledModel.SampleTime[tid].TaskName)
  
  %assert !(SLibIsExplicitPartitioningDiagram() && !SLibIsExportFcnDiagram() && !LibAsynchronousTriggeredTID(tid) && SLibExplicitTaskingTID(tid)) || hasNonEmptyTaskName
  
  %return SLibIsExplicitPartitioningDiagram() && !SLibIsExportFcnDiagram() && !LibAsynchronousTriggeredTID(tid) && SLibExplicitTaskingTID(tid) && hasNonEmptyTaskName
%endfunction
  
%% Function: SLibIsExplicitPartitioningSystemFcn ===============================
%% Abstract
%%  Is there a system function corresponding to tid
%% The problem is even if SLibIsExplicitPartitioningTID(tid) == TLC_TRUE
%% System function body might be empty
%function SLibIsExplicitPartitioningSystemFcn(fcnType, tid) void
  %if fcnType != "Outputs" && fcnType != "Update"
    %return TLC_FALSE
  %else
    %return SLibIsExplicitPartitioningTID(tid) && ...
      ISFIELD(::CompiledModel.RTWCGModules.RTWCGModule.RTWFcnConst, ...
      "%<fcnType>_FunctionTID%<tid>")
  %endif
%endfunction
  
%% Function: SLibExplicitPartitioningSystemFcnName ========================
%% Abstract
%% Entry point name of the funtion corresponding to partition with tid
%function SLibExplicitPartitioningSystemFcnName(baseSysFcnName, tid) void
  %assert SLibIsExplicitPartitioningTID(tid)
  %assign taskName = ::CompiledModel.SampleTime[tid].TaskName
  %assign taskName = FEVAL("strrep",taskName, "." , "_")
  %return "%<baseSysFcnName>_%<taskName>_TID%<tid>"
%endfunction

%% Function: SLibAppendTIDToSystemFcnName =====================================
%% Abstract
%% Append TID to System Function name and this is different when 
%% SLibIsExplicitPartitioningTID(tid) is true
%function SLibAppendTIDToSystemFcnName(baseSysFcnName, tid) void
  %if SLibIsExplicitPartitioningTID(tid)
    %return SLibExplicitPartitioningSystemFcnName(baseSysFcnName, tid)
  %else
    %return "%<baseSysFcnName>TID%<tid>"
  %endif
%endfunction

%% Function: SLibIsERTCodeFormat ===============================================
%% Abstract:
%%  Return true when Embedded-C code format is used.
%%  Note: Not only ERT target use Embedded-C code format, other targets
%%  such as GRT target uses rtModel also use Embedded-C code format
%%
%%  see comments of SLibIsERTTarget for more information
%%
%function SLibIsERTCodeFormat() void
  %return CodeFormat == "Embedded-C"
%endfunction

%% Function: SLibFcnProtoCtrlActive ============================================
%% Abstract:
%%   Is function prototype control active?
%%
%function SLibFcnProtoCtrlActive() void
  %return ISFIELD(::CompiledModel, "RTWFcnClass") && (CompiledModel.ModelReferenceTargetType != "SIM")
%endfunction

%% Function: SLibRTWCPPClassActive =============================================
%% Abstract:
%%   Is CPP Class Generation active?
%%
%function SLibRTWCPPClassActive() void
  %return ISFIELD(::CompiledModel, "RTWFcnCPPClass")
%endfunction

%% Function: SLibAutosarActive =================================================
%% Abstract:
%%   Is AUTOSAR active?
%%
%function SLibAutosarActive() void
  %return ISFIELD(::CompiledModel, "RTWAutosar")
%endfunction

%% Function: SLibAutosarGenRTEHeader =================================================
%% Abstract:
%%   Should AUTOSAR RTE header files be generated?
%%
%function SLibAutosarGenRTEHeader() void
  %return SLibAutosarActive()
%endfunction

%% Function: SLibAdaptiveAutosarActive
%% Abstract:
%%   Is the active target Adaptive Application?
%%
%function SLibAdaptiveAutosarActive() void
  %return SLibRTWCPPClassActive() && ::CompiledModel.ConfigSet.SystemTargetFile == "autosar.tlc"
%endfunction

%% Function: SLibMdlEnableDisablePermitted ======================================
%% Abstract:
%%    Do we produce enable and disable methods at the model level?
%%
%function SLibMdlEnableDisablePermitted() void
  %return  (GenerateEnableDisable == 1)  && ...
    !HasModelReferenceBlocks() && ...
    ExportFunctionsMode != 1 && ...
    !EXISTS(CodeGenForPIL)
%endfunction

%% Function: SLibIndentFile =====================================================
%% Abstract:
%%   Indent a file with c_beautifier utility from within TLC.
%%
%function SLibIndentFile(fileName,modelName) void
  %assign fromTLC = TLC_TRUE
  %<FEVAL("rtwprivate","cBeautifierWithOptions",fileName,modelName,fromTLC)>
%endfunction

%% Function: SLibIsDeploymentDiagramType()
%% Abstract:
%%   Returns true if block diagram type is deployment diagram
%function  SLibIsDeploymentDiagramType() void
  %return (::CompiledModel.BlockDiagramType == "deploymentdiagram")
%endfunction

%% Function: LibIsDeploymentDiagram()
%% Abstract:
%%   Returns true if block diagram type is deployment diagram and code generation
%%   is not for rsim, rapid accel or accel
%function  LibIsDeploymentDiagram() void
  %return (SLibIsDeploymentDiagramType() && ...
    ISFIELD(::CompiledModel,"NumEventHandlers") && ...
    (!Accelerator) && (!isRAccel) && (!isRSim) && (!isRSimWithSolverModule))
%endfunction

%% Function: SLibIsMappedInDeploymentDiagram()
%% Abstract:
%%   Returns true if the subsystem was synthesized for a mapped component
%%   in a deployment diagram
%function SLibIsMappedInDeploymentDiagram(system) void
  %return LibIsDeploymentDiagram() && ...
    SLibDeploymentDiagramIsMapped(system.SystemIdx)
%endfunction

%% Function: SLibIsMappedInDeploymentDiagram()
%% Abstract:
%%   Returns true if the subsystem was synthesized for a mapped component
%%   in a deployment diagram
%function SLibIsMappedSystemInDeploymentDiagram(systemIdx) void
  %return LibIsDeploymentDiagram() && ...
    SLibDeploymentDiagramIsMapped(systemIdx)
%endfunction

%% Function: SLibIsDeploymentDiagramWithNoTopSolver
%% Abstract:
%%   Returns true if the block diagram type is deployment diagram and
%%   the root system does not need a solver for the root system.
%function SLibIsDeploymentDiagramWithNoTopSolver() void
  %return LibIsDeploymentDiagram() && !SLibDeploymentDiagramWithTopSolver()
%endfunction

%% Function: SLibIsDeploymentDiagramWithTopSolver
%% Abstract:
%%   Returns true if the block diagram type is deployment diagram and
%%   the root system needs a solver for the root system.
%function SLibIsDeploymentDiagramWithTopSolver() void
  %return LibIsDeploymentDiagram() && SLibDeploymentDiagramWithTopSolver()
%endfunction

%% Function: SLibIsExplicitTaskingExportFcnRateGrouping
%% Abstract:
%%   This function return true if a given TID is an explicit tasking
%%   TID with an exported function
%function SLibIsExplicitTaskingExportFcnRateGrouping(aSystemFcnType, aTID)
  %return TYPE(aTID) == "Number" && ...
    (SLibIsExportFcnDiagram() || RateGroupedAsyncFcns) && ...
    SLibExplicitTaskingTID(aTID) && ...
    (aSystemFcnType == "OutputUpdate" || aSystemFcnType == "Output" ) && ...
    ISFIELD(SampleTime[aTID],"EntryFcnName") && ...
    !ISEMPTY(SampleTime[aTID].EntryFcnName) && ...
    !SLibNonInlinedIRTEventTID(aTID)
%endfunction

%function SLibIsServiceFcn(system, aFcnType, aTID)
  %assign thisModule = ...
    ::CompiledModel.RTWCGModules.RTWCGModule[system.CGIRModuleIdx]
  %if (aFcnType == "OutputUpdate" || aFcnType == "Output" ) && ...
    TYPE(aTID) == "Number" && aTID > 0 && ...
    ISFIELD(SampleTime[aTID], "EntryFcnName") && ...
    ISFIELD(thisModule, "SystemFunctions") && ...
    ISFIELD(thisModule.SystemFunctions, SampleTime[aTID].EntryFcnName)
    %assign fcnIndex = GETFIELD(thisModule.SystemFunctions, SampleTime[aTID].EntryFcnName)
    %assign thisFcn  = thisModule.Function[fcnIndex]
    %if thisFcn.IsServiceFcn == TLC_TRUE
      %return TLC_TRUE
    %endif
  %endif
  %return TLC_FALSE
%endfunction
      
%function SLibIsRateGroupedSLFcn(system, aFcnType, aTID)
  %assign thisModule = ...
    ::CompiledModel.RTWCGModules.RTWCGModule[system.CGIRModuleIdx]
  %if SLibIsExportFcnDiagram() && ...
    (aFcnType == "OutputUpdate" || aFcnType == "Output" ) && ...
    TYPE(aTID) == "Number" && aTID > 0 && ...
    ISFIELD(SampleTime[aTID], "EntryFcnName") && ...
    ISFIELD(thisModule, "SystemFunctions") && ...
    ISFIELD(thisModule.SystemFunctions, SampleTime[aTID].EntryFcnName)
    %assign fcnIndex = GETFIELD(thisModule.SystemFunctions, SampleTime[aTID].EntryFcnName)
    %assign thisFcn  = thisModule.Function[fcnIndex]
    %if ISFIELD(thisFcn,"IsRateGroupedSLFcn") && thisFcn.IsRateGroupedSLFcn == TLC_TRUE
      %return TLC_TRUE
    %endif
  %endif
  %return TLC_FALSE
%endfunction
      
%function SLibIsGlobalRateGroupedSLFcn(system, aFcnType, aTID)
  %if SLibIsRateGroupedSLFcn(system, aFcnType, aTID)
    %foreach idx = NumSystems
      %assign thisSystem = System[idx]
      %if thisSystem.IsRateGroupedSLFcn ...
        && thisSystem.Identifier == SampleTime[aTID].EntryFcnName
        %return LibIsGlobalServer(thisSystem)
      %endif
    %endforeach
  %endif
  %return TLC_FALSE
%endfunction

%function SLibGetRateGroupedFcnPrototype(module, aTID)
  %assign fcnName = ""
  %assign fcnPrototype = ""
  %assign cgirParams = ""
  %assign fcnReturns = ""
  %if TYPE(aTID) == "Number" && aTID > 0 && ...
    ISFIELD(SampleTime[aTID], "EntryFcnName")
    %assign fcnName = SampleTime[aTID].EntryFcnName
    %assign fcnIndex = GETFIELD(module.SystemFunctions, fcnName)
    %assign thisFcn  = module.Function[fcnIndex]
    %assign fcnPrototype = thisFcn.ProtoType + ")"
    %assign fcnPrototype = FEVAL("regexprep", fcnPrototype, "static \W*", "", "once")
    %assign fcnPrototype = FEVAL("regexprep", fcnPrototype, "extern \W*", "", "once")
    %assign cgirParams = FEVAL("regexprep", fcnPrototype, "^[^\(]*\(", "")
    %assign fcnReturns = FEVAL("regexp",fcnPrototype," ","split")[0]
  %endif
  %createrecord FcnPrototype { Name fcnName; Prototype fcnPrototype; Params cgirParams; Return fcnReturns }
  %return FcnPrototype
%endfunction

%% Function: SLibGetCurrentBlock ===============================================
%% Abstract:
%%   Returns the current block record.
%%
%function SLibGetCurrentBlock() void
  %assign self = ::CompiledModel.System[BlockIdx[0]].Block[BlockIdx[2]]
  %if self.BlockIdx[0] != BlockIdx[0] || self.BlockIdx[2] != BlockIdx[2]
    %error "Incoherent BlockIdx in record."
  %endif
  %return self
%endfunction

%% Function: SLibTLCSystemFcnCallExists ========================================
%% Abstract:
%%  Returns true if a TLC interface function for a given TLC system function
%%  call exists.
%%
%function SLibTLCSystemFcnCallExists(aSystemFcnType, ...
  aSystemIdx, aCallSiteIdx, aModuleIdx, aFcnIdx) void

  %if aModuleIdx  > -1 && aFcnIdx > -1
    %assign sysFcnType   = ...
      ("OutputUpdate" == aSystemFcnType) ? "Output" : aSystemFcnType
    %assign thisModule   = ::CompiledModel.RTWCGModules.RTWCGModule[aModuleIdx]
    %assign tlcFileName  = thisModule.TLCFileName + "_TLCInterface"
    %assign thisModule.IsTLCInterfaceLoaded = TLC_TRUE
    %assign opaqueBlock  = FcnRootOpaqueBlock()
    %assign thisSytemIdx = BlockIdx[0]
    %assign thisBlockIdx = BlockIdx[2]
    %assign fcnName = "getSystem" + sysFcnType + "FcnCallInfo" + ...
      "_%<thisSytemIdx>_%<thisBlockIdx>_%<aModuleIdx>_%<aFcnIdx>_" + ...
      "%<aSystemIdx>_%<aCallSiteIdx>"
    %return GENERATE_TYPE_FUNCTION_EXISTS(opaqueBlock, fcnName, tlcFileName)
  %endif

  %return TLC_FALSE
%endfunction

%% Function: SLibTLCSystemFcnCall ==============================================
%% Abstract:
%%  Invokes the TLC interface function for a given system function call and
%%  returns
%%
%function SLibTLCSystemFcnCallInfo(aSystemFcnType, ...
  aSystemIdx, aCallSiteIdx, aModuleIdx, aFcnIdx) void

  %if aModuleIdx > -1 && aFcnIdx > -1
    %assign sysFcnType   = ...
      ("OutputUpdate" == aSystemFcnType) ? "Output" : aSystemFcnType
    %assign thisModule   = ::CompiledModel.RTWCGModules.RTWCGModule[aModuleIdx]
    %assign tlcFileName  = thisModule.TLCFileName + "_TLCInterface"
    %assign thisModule.IsTLCInterfaceLoaded = TLC_TRUE
    %assign opaqueBlock  = FcnRootOpaqueBlock()
    %assign thisSytemIdx = BlockIdx[0]
    %assign thisBlockIdx = BlockIdx[2]
    %assign fcnName = "getSystem" + sysFcnType + "FcnCallInfo" + ...
      "_%<thisSytemIdx>_%<thisBlockIdx>_%<aModuleIdx>_%<aFcnIdx>_" + ...
      "%<aSystemIdx>_%<aCallSiteIdx>"
    %% Extract the traceability comments for the call site
    %assign callInfo =  GENERATE_TYPE(opaqueBlock, fcnName, tlcFileName)
    %assign callSiteInfo = FEVAL("coder.trace.internal.extractTraceComments", callInfo.Name)
    %if !ISEMPTY(callSiteInfo.openingComment)
      %assign callInfo.Name = callSiteInfo.content
      %addtorecord callInfo OpeningTraceComment "%<callSiteInfo.openingComment>"
      %addtorecord callInfo ClosingTraceComment "%<callSiteInfo.closingComment>"
  %endif
    %return callInfo
  %endif

  %return ""
%endfunction

%% Function: SLibInvokeTLCInterface ============================================
%% Abstract:
%%   Invokes the TLC interface for a given block and property.
%%
%function SLibInvokeTLCInterface(block, property, propertyIdx, elementIdx, ...
  bAddr, lcv, ucv, sigIdx, reim) void

  %assign modIdx = ::CurrentModuleIdx
  %assign fcnIdx = ::CurrentFunctionIdx

  %if modIdx > -1 && fcnIdx > -1
    %assign thisModule  = ::CompiledModel.RTWCGModules.RTWCGModule[modIdx]
    %assign tlcFileName = thisModule.TLCFileName + "_TLCInterface"
    %assign thisModule.IsTLCInterfaceLoaded = TLC_TRUE
    %assign opaqueBlock = FcnRootOpaqueBlock()
    %assign sysIdx      = block.BlockIdx[0]
    %assign blkIdx      = block.BlockIdx[2]
    %assign fcnName = "get" + property + (bAddr  ? "Addr"  : "") + ...
      "_%<sysIdx>_%<blkIdx>_%<modIdx>_%<fcnIdx>_%<propertyIdx>_%<elementIdx>"
    %return GENERATE_TYPE(opaqueBlock, fcnName, tlcFileName, block, lcv, ucv, ...
      sigIdx, reim)
  %endif

  %return ""
%endfunction

%% Function: SLibBlockOutputExprIdx ============================================
%% Abstract:
%%   Returns the index expression for a TLC expression with a matrix type
%%
%function SLibBlockOutputExprIdx(aSystemIdx, aBlockIdx, aPortIdx, aExprIdx) void
  %assign modIdx = ::CurrentModuleIdx
  %assign fcnIdx = ::CurrentFunctionIdx

  %if modIdx > -1 && fcnIdx > -1
    %assign thisModule  = ::CompiledModel.RTWCGModules.RTWCGModule[modIdx]
    %assign tlcFileName = thisModule.TLCFileName + "_TLCInterface"
    %assign thisModule.IsTLCInterfaceLoaded = TLC_TRUE
    %assign opaqueBlock = FcnRootOpaqueBlock()
    %assign fcnName     = "getOutputExprIdx_%<aSystemIdx>_%<aBlockIdx>_" + ...
      "%<modIdx>_%<fcnIdx>_%<aPortIdx>_%<aExprIdx>"
    %if GENERATE_TYPE_FUNCTION_EXISTS(opaqueBlock, fcnName, tlcFileName)
      %assign indexVector = GENERATE_TYPE(opaqueBlock, fcnName, tlcFileName)
      %assign indexExpr = ""
      %assign seperator = ""
      %foreach dimsIdx = SIZE(indexVector, 1)
        %assign indexExpr = indexExpr + seperator + indexVector[dimsIdx]
        %assign seperator = "]["
      %endforeach
      %return indexExpr
    %endif
  %endif
  %return ""
%endfunction %% SLibBlockOutputExprIdx

%% Function: SLibUnloadTLCInterface ============================================
%% Abstract:
%%   This function is used to unload the TLC interface function and release
%%   some memory that is no longer used.
%%
%function SLibUnloadTLCInterface(module) void
  %if module.IsTLCInterfaceLoaded
    %assign    block = FcnRootOpaqueBlock()
    %assign fileName = module.TLCFileName + "_TLCInterface"
    %assign unused = UNLOAD_GENERATE_TYPE(block, fileName)
    %assign module.IsTLCInterfaceLoaded = TLC_FALSE
  %endif
%endfunction %% SLibUnloadTLCInterface

%%
%% Invoking the auto-generated TLC interface functions for the current TLC
%% block. Notice that those will update all required access flags for the DSM.
%%
%function SLibGetDSMBaseAddr(block, dsmIdx) void
  %return SLibInvokeTLCInterface(block, "DSM", dsmIdx, 0, TLC_TRUE, "", "", ...
    0, "")
%endfunction

%function SLibGetDSMElement(block, dsmIdx, elemIdx) void
  %return SLibInvokeTLCInterface(block, "DSM", dsmIdx, 0, TLC_FALSE, "", "", ...
    elemIdx, "")
%endfunction

%% FcnAccelOrGlbMdlRefSimDataStoreTransfer ====================================
%% Abstract:
%%    This function is used to transfer to and from data stores for
%%    simulation modes: accelator, rapid accelerator and model reference
%%    sim target with global DSMs
%function FcnAccelOrGlbMdlRefSimDataStoreTransfer(block, system, dWorkSrc, globalDSM, dataAddr, direction) Output
  %if ((IsModelReferenceSimTarget() && globalDSM) || Accelerator)
    %if Accelerator
      %assign simS = "S"
      %if globalDSM
        %assign reslvDsmIdx = dWorkSrc
      %else
        %assign reslvDsmIdx = "%<LibBlockDWork(dWorkSrc, "", "", 0)>"
      %endif
    %else
      %assign simS = RTMGet("MdlRefSfcnS")
      %assign reslvDsmIdx = "%<::CompiledModel.Name>_DSMIdx[%<dWorkSrc>]"
    %endif
    %<SLibCG_AccessRTM()>
    %if direction == "read"
      ssReadFromDataStoreWithPath(%<simS>, ...
        %<reslvDsmIdx>, ...
        "%<LibGetFormattedBlockPath(block)>", ...
        %<dataAddr>);
    %else
      ssWriteToDataStoreWithPath(%<simS>, ...
        %<reslvDsmIdx>, ...
        "%<LibGetFormattedBlockPath(block)>", ...
        %<dataAddr>);
    %endif
  %else
    %<LibReportFatalError("Should not be here")>
  %endif
%endfunction

%% FcnWriteToDataStoreCodeGen ====================================================
%% Abstract: This function handles data store transfers for rapid accelerator
%%     mode with global DSM and model reference sim target
%function FcnDataStoreTransferCodeGen(block, system, globalDSM, dWorkSrc, uAddr, dsmIdx, direction) Output
  %assert (IsModelReferenceSimTarget() && globalDSM)

  %assign dWorkSrc2     = block.ParamSettings.GlobalDataStoreSource[dsmIdx]
  %assign dworkAndRec   = FcnGetDworkAndRec(dWorkSrc2)
  %assign dwork         = dworkAndRec.DWork
  %assign dworkDataType = LibBlockDWorkDataTypeName(dwork, "")

  %if direction == "write"
    *((%<dworkDataType>*)(%<::CompiledModel.Name>_DSM[%<dWorkSrc>])) = *(%<uAddr>);
  %else
    *(%<uAddr>) = *((%<dworkDataType>*)(%<::CompiledModel.Name>_DSM[%<dWorkSrc>]));
  %endif
%endfunction


%% LibSFcnReadFromDataStore ====================================================
%% Abstract:
%%   This function is used by an sfunction to read a global data store
%%   it has registered and copy the contents to an address in memory
%%
%function LibSFcnReadFromDataStore(block, system, dsmIdx, yAddr) Output
  %assign dWorkSrc  = block.ParamSettings.DataStoreSource[dsmIdx]
  %assign globalDSM = block.ParamSettings.DataStoreGlobalDSM[dsmIdx]

  %if (IsModelReferenceSimTarget() && globalDSM)
    if(slIsRapidAcceleratorSimulating()) {
      %<FcnDataStoreTransferCodeGen(block, system, globalDSM, dWorkSrc, yAddr, dsmIdx, "read")>
    } else {
      %<FcnAccelOrGlbMdlRefSimDataStoreTransfer(block, system, dWorkSrc, globalDSM, yAddr, "read")>
    }
  %elseif (Accelerator)
    %<FcnAccelOrGlbMdlRefSimDataStoreTransfer(block, system, dWorkSrc, globalDSM, yAddr, "read")>
  %else
    %assign dworkAndRec   = FcnGetDworkAndRec(dWorkSrc)
    %assign dwRec         = dworkAndRec.DWorkRec
    %assign dwork         = dworkAndRec.DWork
    %assign dworkWidth    = LibBlockDWorkWidth(dwork)
    %assign hasCustomSC   = LibHasCustomStorage(dwRec)
    %if !hasCustomSC || LibCustomDataIsAddressable(dwRec)
      %assign dworkBaseAddr = hasCustomSC ...
        ? LibBlockDWorkAddr(dWorkSrc, "", "", 0) ...
        : SLibGetDSMBaseAddr(block, dsmIdx)
      %if LibBlockDWorkIsComplex(dwork)
        %assign dworkWidth = dworkWidth * 2
      %endif
      %assign dworkDataType = LibBlockDWorkDataTypeName(dwork, "")
     (void) %<LibGenMemFcnCall("memcpy", "%<yAddr>", "%<dworkBaseAddr>", ...
        "%<dworkWidth>*sizeof(%<dworkDataType>)")>;
    %else
      %foreach elemIdx = dworkWidth
        %if dworkWidth > 1
          %assign y = yAddr[elemIdx]
        %else
          %assign y = "*(%<yAddr>)"
        %endif
        %<y> = %<LibBlockDWork(dWorkSrc, "", "", elemIdx)>;
      %endforeach
    %endif
  %endif
%endfunction

%% LibSFcnWriteToDataStore =====================================================
%% Abstract:
%%   This function is used by an sfunction to write to a global data store
%%   it has registered and get the value
%%
%function LibSFcnWriteToDataStore(block, system, dsmIdx, uAddr) Output
  %assign dWorkSrc = block.ParamSettings.DataStoreSource[dsmIdx]
  %assign globalDSM = block.ParamSettings.DataStoreGlobalDSM[dsmIdx]

  %if (IsModelReferenceSimTarget() && globalDSM)
    if(slIsRapidAcceleratorSimulating()) {
      %<FcnDataStoreTransferCodeGen(block, system, globalDSM, dWorkSrc, uAddr, dsmIdx, "write")>
    } else {
      %<FcnAccelOrGlbMdlRefSimDataStoreTransfer(block, system, dWorkSrc, globalDSM, uAddr, "write")>
    }
  %elseif (Accelerator)
    %<FcnAccelOrGlbMdlRefSimDataStoreTransfer(block, system, dWorkSrc, globalDSM, uAddr, "write")>
  %else
    %assign dworkAndRec   = FcnGetDworkAndRec(dWorkSrc)
    %assign dwRec         = dworkAndRec.DWorkRec
    %assign dwork         = dworkAndRec.DWork
    %assign dworkWidth    = LibBlockDWorkWidth(dwork)
    %assign hasCustomSC   = LibHasCustomStorage(dwRec)
    %if !hasCustomSC || LibCustomDataIsAddressable(dwRec)
      %assign dworkBaseAddr = hasCustomSC ...
        ? LibBlockDWorkAddr(dWorkSrc, "", "", 0) ...
        : SLibGetDSMBaseAddr(block, dsmIdx)
      %if LibBlockDWorkIsComplex(dwork)
        %assign dworkWidth = dworkWidth * 2
      %endif
      %assign dworkDataType = LibBlockDWorkDataTypeName(dwork, "")
      (void) %<LibGenMemFcnCall("memcpy", dworkBaseAddr, uAddr, ...
        "%<dworkWidth>*sizeof(%<dworkDataType>)")>;
    %else
      %foreach elemIdx = dworkWidth
        %if dworkWidth > 1
          %assign u = uAddr[elemIdx]
        %else
          %assign u = "*(%<uAddr>)"
        %endif
        %<LibBlockAssignDWork(dWorkSrc, "", "", elemIdx, u)>
      %endforeach
    %endif
  %endif
%endfunction

%% FcnDataStoreCopyCodeGen =======================================================
%% Abstract:
%%    This function is used to copy information to and from data store given a
%%    input/output port index for model reference sim target with global DSMs
%%    in rapid accelerator mode
%function FcnDataStoreCopyCodeGen(block, system, globalDSM, dWorkSrc, pIdx, dsmIdx, direction) Output
  %assert (IsModelReferenceSimTarget() && globalDSM)

  %assign dWorkSrc2 = block.ParamSettings.GlobalDataStoreSource[dsmIdx]
  %assign dworkAndRec   = FcnGetDworkAndRec(dWorkSrc2)
  %assign dwork         = dworkAndRec.DWork
  %assign dworkDataType = LibBlockDWorkDataTypeName(dwork, "")

  %if direction == "write"
    %foreach elemIdx = LibBlockInputSignalWidth(pIdx)
      %assign uAddr = LibBlockInputSignalAddr(pIdx, "", "", elemIdx)
      ((%<dworkDataType>*)(%<::CompiledModel.Name>_DSM[%<dWorkSrc>]))[%<elemIdx>] = *(%<uAddr>);
    %endforeach
  %else
    %foreach elemIdx = LibBlockOutputSignalWidth(pIdx)
      %assign yAddr = LibBlockOutputSignalAddr(pIdx, "", "", elemIdx)
      *(%<yAddr>) = ((%<dworkDataType>*)(%<::CompiledModel.Name>_DSM[%<dWorkSrc>]))[%<elemIdx>];
    %endforeach
  %endif
%endfunction

%% LibSFcnCopyFromDataStoreToOutput ============================================
%% Abstract:
%%   This function is used by an sfunction to read a global data store
%%   it has registered and copy the contents to a block output port
%%
%function LibSFcnCopyFromDataStoreToOutput(block, system, dsmIdx, pIdx) Output
  %assign dWorkSrc  = block.ParamSettings.DataStoreSource[dsmIdx]
  %assign globalDSM = block.ParamSettings.DataStoreGlobalDSM[dsmIdx]

  %if (IsModelReferenceSimTarget() && globalDSM)
    if(slIsRapidAcceleratorSimulating()) {
      %<FcnDataStoreCopyCodeGen(block, system, globalDSM, dWorkSrc, pIdx, dsmIdx, "read")>
    } else {
      %assign yAddr = LibBlockOutputSignalAddr(pIdx, "", "", 0)
      %<FcnAccelOrGlbMdlRefSimDataStoreTransfer(block, system, dWorkSrc, globalDSM, yAddr, "read")>
    }
  %elseif (Accelerator)
    %assign yAddr = LibBlockOutputSignalAddr(pIdx, "", "", 0)
    %<FcnAccelOrGlbMdlRefSimDataStoreTransfer(block, system, dWorkSrc, globalDSM, yAddr, "read")>
  %else
    %foreach elemIdx = LibBlockOutputSignalWidth(pIdx)
      %assign y = LibBlockOutputSignal(pIdx, "", "", elemIdx)
      %assign u = LibBlockDWork(dWorkSrc, "", "", elemIdx)
      %<y> = %<u>;
    %endforeach
  %endif
%endfunction


%% LibSFcnCopyToDataStoreFromInput =============================================
%% Abstract:
%%   This function is used by an sfunction to write to a global data store
%%   it has registered and get the value from a (contiguous) input port
%%
%function LibSFcnCopyToDataStoreFromInput(block, system, dsmIdx, pIdx) Output
  %assign dWorkSrc  = block.ParamSettings.DataStoreSource[dsmIdx]
  %assign globalDSM = block.ParamSettings.DataStoreGlobalDSM[dsmIdx]

  %if (IsModelReferenceSimTarget() && globalDSM)
    if(slIsRapidAcceleratorSimulating()) {
      %<FcnDataStoreCopyCodeGen(block, system, globalDSM, dWorkSrc, pIdx, dsmIdx, "write")>
    } else {
      %assign uAddr = LibBlockInputSignalAddr(pIdx, "", "", 0)
      %<FcnAccelOrGlbMdlRefSimDataStoreTransfer(block, system, dWorkSrc, globalDSM, uAddr, "write")>
    }
  %elseif (Accelerator)
    %assign uAddr = LibBlockInputSignalAddr(pIdx, "", "", 0)
    %<FcnAccelOrGlbMdlRefSimDataStoreTransfer(block, system, dWorkSrc, globalDSM, uAddr, "write")>
  %else
    %assign dworkAndRec   = FcnGetDworkAndRec(dWorkSrc)
    %assign dwRec         = dworkAndRec.DWorkRec
    %if LibHasCustomStorage(dwRec)
      %foreach elemIdx = LibBlockInputSignalWidth(pIdx)
        %assign u = LibBlockInputSignal(pIdx, "", "", elemIdx)
        %<LibBlockAssignDWork(dWorkSrc, "", "", elemIdx, u)>
      %endforeach
    %else
      %foreach elemIdx = LibBlockInputSignalWidth(pIdx)
        %assign u = LibBlockInputSignal(pIdx, "", "", elemIdx)
        %<SLibGetDSMElement(block, dsmIdx, elemIdx)> = %<u>;
      %endforeach
    %endif
  %endif
%endfunction

%% FcnDataStoreElementTransferCodeGen =================================================
%% Abstract:
%%    This function handles data store element transfers for model reference target
%%    with global DSMs in rapid accel mode.
%function FcnDataStoreElementTransferCodeGen(block, system, globalDSM, dWorkSrc, dsmIdx, uAddr, dsmElem, direction) Output
  %assert (IsModelReferenceSimTarget() && globalDSM)

  %assign dWorkSrc2 = block.ParamSettings.GlobalDataStoreSource[dsmIdx]
  %assign dworkAndRec   = FcnGetDworkAndRec(dWorkSrc2)
  %assign dwork         = dworkAndRec.DWork
  %assign dworkDataType = LibBlockDWorkDataTypeName(dwork, "")

  %if direction == "write"
    ((%<dworkDataType>*)(%<::CompiledModel.Name>_DSM[%<dWorkSrc>]))[%<dsmElem>] = *(%<uAddr>);
  %else
    *(%<uAddr>) = ((%<dworkDataType>*)(%<::CompiledModel.Name>_DSM[%<dWorkSrc>]))[%<dsmElem>];
  %endif
%endfunction

%% FcnDataStoreElementTransferSim =========================================================
%% Abstract:
%%    This function andles data store element transfers for non rapid accelerator modes.
%function FcnDataStoreElementTransferSim(block, system, globalDSM, dWorkSrc, dsmIdx, addr, dsmElem, direction) Output
  %if ((IsModelReferenceSimTarget() && globalDSM) || Accelerator)
    %if Accelerator
      %assign simS = "S"
      %if globalDSM
        %assign reslvDsmIdx = dWorkSrc
      %else
        %assign reslvDsmIdx = "%<LibBlockDWork(dWorkSrc, "", "", 0)>"
      %endif
    %else
      %assign simS = RTMGet("MdlRefSfcnS")
      %assign reslvDsmIdx = "%<::CompiledModel.Name>_DSMIdx[%<dWorkSrc>]"
    %endif
    %if (direction == "read")
      ssReadFromDataStoreElementWithPath(%<simS>, ...
        %<reslvDsmIdx>, ...
        "%<LibGetFormattedBlockPath(block)>", ...
        %<addr>,%<dsmElem>);
    %else
      ssWriteToDataStoreElementWithPath(%<simS>, ...
        %<reslvDsmIdx>, ...
        "%<LibGetFormattedBlockPath(block)>", ...
        %<addr>,%<dsmElem>);
    %endif
  %else
    %assign dworkAndRec   = FcnGetDworkAndRec(dWorkSrc)
    %assign dwRec         = dworkAndRec.DWorkRec
    %assign dworkVal = LibHasCustomStorage(dwRec) ...
      ? LibBlockDWork(dWorkSrc, "", "", dsmElem) ...
      : SLibGetDSMElement(block, dsmIdx, dsmElem)
    %if (direction == "read")
      (%<addr>)[0] = %<dworkVal>;
    %else
      %<dworkVal> = (%<addr>)[0];
    %endif
  %endif
%endfunction

%% LibSFcnReadFromDataStoreElement =============================================
%% Abstract:
%%   This function is used by an sfunction to read a global data store
%%   it has registered
%%
%function LibSFcnReadFromDataStoreElement(block, system, dsmIdx, yAddr,dsmElem) Output
  %assign dWorkSrc  = block.ParamSettings.DataStoreSource[dsmIdx]
  %assign globalDSM = block.ParamSettings.DataStoreGlobalDSM[dsmIdx]

  %if (IsModelReferenceSimTarget() && globalDSM)
    if(slIsRapidAcceleratorSimulating()) {
      %<FcnDataStoreElementTransferCodeGen(block, system, globalDSM, dWorkSrc, dsmIdx, yAddr, dsmElem, "read")>
    } else {
      %<FcnDataStoreElementTransferSim(block, system, globalDSM, dWorkSrc, dsmIdx, yAddr, dsmElem, "read")>
    }
  %else
    %<FcnDataStoreElementTransferSim(block, system, globalDSM, dWorkSrc, dsmIdx, yAddr, dsmElem, "read")>
  %endif
%endfunction

%% LibSFcnWriteToDataStoreElement ==============================================
%% Abstract:
%%   This function is used by an sfunction to write to a global data store
%%   it has registered
%%
%function LibSFcnWriteToDataStoreElement(block, system, dsmIdx, uAddr,dsmElem) Output
  %assign dWorkSrc  = block.ParamSettings.DataStoreSource[dsmIdx]
  %assign globalDSM = block.ParamSettings.DataStoreGlobalDSM[dsmIdx]

  %if (IsModelReferenceSimTarget() && globalDSM)
    if(slIsRapidAcceleratorSimulating()) {
      %<FcnDataStoreElementTransferCodeGen(block, system, globalDSM, dWorkSrc, dsmIdx, uAddr, dsmElem, "write")>
    } else {
      %<FcnDataStoreElementTransferSim(block, system, globalDSM, dWorkSrc, dsmIdx, uAddr, dsmElem, "write")>
    }
  %else
    %<FcnDataStoreElementTransferSim(block, system, globalDSM, dWorkSrc, dsmIdx, uAddr, dsmElem, "write")>
  %endif
%endfunction

%% DocFunction{BlkPathAndErrFcns}: LibBlockReportWarning =======================
%% Abstract:
%%   This should be used when reporting warnings for a block. This function
%%   is designed to be used from block target files (e.g. the TLC file for an
%%   inlined S-function).
%%
%%   This function can be called with or without the block record scoped.
%%   To call this function without a block record scoped, pass the block record.
%%   To call this function when the block is scoped, pass block = [].
%%   Specifically:
%%
%%     LibBlockReportWarning([],"warn string")          -- If block is scoped
%%     LibBlockReportWarning(blockrecord,"warn string") -- If block record is
%%                                                         available
%%
%function LibBlockReportWarning(block,warnstring) void

  %if ISEMPTY(block)
    %<LibReportWarning(warnstring)>
  %else
    %if TYPE(block) != "Vector"
      %assign blockName = LibGetFormattedBlockPath(block)
      %assign type      = block.Type
    %else
      %assign blockName = LibMangledPathName(Name)
      %assign type      = Type
    %endif

    %openfile warnMessage
Simulink Coder -- In block "%<blockName>", block type "%<type>": %<warnstring>
    %closefile warnMessage

    %<SLibReportWarningWithIdAndArgs("RTW:tlc:GenericWarn", warnMessage)>
  
  %endif

%endfunction %% LibBlockReportWarning


%% DocFunction{BlkPathAndErrFcns}: LibBlockReportError =========================
%% Abstract:
%%   This should be used when reporting errors for a block. This function
%%   is designed to be used from block target files (e.g. the TLC file for
%%   an inlined S-function).
%%
%%   This function can be called with or without the block record scoped.
%%   To call this function without a block record scoped, pass the block
%%   record. To call this function when the block is scoped, pass block = [].
%%   Specifically:
%%
%%     LibBlockReportError([],"error string")          -- If block is scoped
%%     LibBlockReportError(blockrecord,"error string") -- If block record is
%%                                                        available
%%
%function LibBlockReportError(block,errorstring) void

  %if ISEMPTY(block)
    %<LibReportError(errorstring)>
  %else
    %<SLibReportError("Simulink Coder Error",block,errorstring)>
  %endif

%endfunction %% LibBlockReportError


%% DocFunction{BlkPathAndErrFcns}: LibBlockReportFatalError ====================
%% Abstract:
%%   This should be used when reporting fatal (assert) errors for a block.
%%   Use this function for defensive programming. TLC Error Message appendix in
%%   the TLC reference manual.
%%
%function LibBlockReportFatalError(block,errorstring) void

  %setcommandswitch "-v1"
  %<SLibReportError("Simulink Coder Fatal",block,errorstring)>

%endfunction %% LibBlockReportFatalError


%% Function{BlkPathAndErrFcns}: LibReportWarning ===============================
%% Abstract:
%%   This should be used when reporting non-block based warnings. This
%%   function prepends the errorstring argument with 'Simulink Coder: '
%%
%function LibReportWarning(warnstring) void
  %openfile warnMessage
Simulink Coder: %<warnstring>
  %closefile warnMessage

  %<SLibReportWarningWithIdAndArgs("RTW:tlc:GenericWarn", warnMessage)>

%endfunction %% LibReportWarning


%% Function: LibReportError{BlkPathAndErrFcns} =================================
%% Abstract:
%%   This should be used when reporting non-block based errors. This
%%   function prepends the errorstring argument with 'Simulink Coder
%%   Error: ').
%%
%function LibReportError(errorstring) void
  %openfile errorMessage
Simulink Coder Error: %<errorstring>
  %closefile errorMessage

  %exit %<errorMessage>

%endfunction %% LibReportError

%% Function: SLibReportErrorWithId =================================
%% Abstract:
%%   Reporting error using error ID.
%function SLibReportErrorWithId(errorId) void
  %if EXISTS("ShowErrorStackTrace") && ::ShowErrorStackTrace == TLC_TRUE
    %setcommandswitch "-v1"
  %endif
  %assign errorMessage = FEVAL("rtwprivate", "tlcreporterror", errorId)
  %exit %<errorMessage>
%endfunction

%% Function: SLibReportErrorWithIdAndArgs =================================
%% Abstract:
%%   Reporting error using error ID with additional input arguments.
%function SLibReportErrorWithIdAndArgs(errorId, args) void
  %if EXISTS("ShowErrorStackTrace") && ::ShowErrorStackTrace == TLC_TRUE
    %setcommandswitch "-v1"
  %endif
  %assign errorMessage = FEVAL("rtwprivate", "tlcreporterror", errorId, args)
  %exit %<errorMessage>
%endfunction

%% Function: SLibReportWarningWithId =================================
%% Abstract:
%%   Reporting warning using message ID.
%function SLibReportWarningWithId(messageId) void
  %assign message = FEVAL("rtwprivate", "tlcreporterror", messageId)
  %assign result_status = FEVAL("Simulink.output.warning", message, "MessageId", messageId)
%endfunction

%% Function: SLibReportWarningWithIdAndArgs =================================
%% Abstract:
%%   Reporting warning using message ID with additional input arguments.
%function SLibReportWarningWithIdAndArgs(messageId, args) void
  %assign message = FEVAL("rtwprivate", "tlcreporterror", messageId, args)
  %assign result_status = FEVAL("Simulink.output.warning", message, "MessageId", messageId)
%endfunction

%% Function{BlkPathAndErrFcns}: LibReportFatalError ============================
%% Abstract:
%%   This should be used when reporting non-block based fatal errors.
%%   This function should only be used for asserts. See the TLC Error
%%   Message appendix in the TLC reference manual. This function prepends
%%   the errorstring argument with 'Simulink Coder Fatal: ').
%%
%function LibReportFatalError(errorstring) void
  %setcommandswitch "-v1"
  %openfile errorMessage
Simulink Coder Fatal: %<errorstring>
  %closefile errorMessage

  %exit %<errorMessage>

%endfunction %% LibReportFatalError


%% Function{BlkPathAndErrFcns}: SLibReportError ================================
%% Abstract:
%%   Report either a usage or fatal error for a block.
%%
%function SLibReportError(location,block,errorstring) void

 %if TYPE(block) != "Vector"
    %assign blockName = LibGetFormattedBlockPath(block)
    %assign type      = block.Type
  %else
    %assign blockName = LibMangledPathName(Name)
    %assign type      = Type
  %endif

  %openfile errorMessage
%<location> in block: "%<blockName>", block type "%<type>": %<errorstring>
  %closefile errorMessage

  %exit %<errorMessage>
%endfunction %% SLibReportError

%% Function: LibRequestID ======================================================
%% Abstract:
%%  This should be used to register an ID using the Identifier Service.
%%  Throws an error if the ID cannot be registered.
%%
%function LibRequestID (requestedID,isGlobal, isFixed) void
  %assign id = FEVAL("rtwprivate","requestIdentifier","%<LibGetModelName()>",requestedID,isGlobal,isFixed)
  %<LibRequestIDError(id,requestedID)>
  %return id
%endfunction %%LibRequestID

%% Function: LibRequestIDWithLength ======================================================
%% Abstract:
%%  This should be used to register an ID using the Identifier Service.
%%  Throws an error if the ID cannot be registered.
%%
%function LibRequestIDWithLength (requestedID,isGlobal, isFixed, len) void
  %assign id = FEVAL("rtwprivate","requestIdentifier","%<LibGetModelName()>",requestedID,isGlobal,isFixed,len)
  %<LibRequestIDError(id,requestedID)>
  %return id
%endfunction %%LibRequestIDWithLength

%% Function: LibRequestIDError ================================================
%% Abstract:
%%  This should be used to register an ID using the Identifier Service.
%%  Throws an error if the ID cannot be registered.
%%
%function LibRequestIDError(id,requestedID) void
  %if TYPE(id) == "Number"
    %<SLibReportErrorWithIdAndArgs("RTW:tlc:IdentifierClash",requestedID)>
  %endif
%endfunction %%LibRequestIDError


%% Function: SLibReportNonAddressableError ======================================
%% Abstract:
%%    Report an attempt to take the address of nonaddressable data
%%
%function SLibReportNonAddressableError(type, block, record) void
  %switch type
    %case "Input"
      %assign errTxt = "block attempts to take the address of its " + ...
        "input signal " + ...
        "'%<LibGetRecordVarName(record)>' but that signal " + ...
        "is not addressable because of its custom storage class. " + ...
        "Consider inserting a Signal Conversion block at the input to the block. " + ...
        "Make sure to select the Signal Conversion block's parameter " + ...
        "'Exclude this block from 'Block reduction' optimization'"
      %break
    %case "Output"
      %assign errTxt = "block attempts to take the address of its " + ...
        "output signal " + ...
        "'%<LibGetRecordVarName(record)>' but that signal " + ...
        "is not addressable because of its custom storage class. " + ...
        "Consider inserting a Signal Conversion block at the output of the " + ...
        "block, and moving the signal '%<LibGetRecordVarName(record)>' " + ...
        "to the output of that Signal Conversion block. " + ...
        "Make sure to select the Signal Conversion block's parameter " + ...
        "'Exclude this block from 'Block reduction' optimization'"
      %break
    %case "Dwork"
      %assign errTxt = "block attempts to take the address of its " + ...
        "dwork '%<LibGetRecordVarName(record)>' but that dwork " + ...
        "is not addressable because of its custom storage class. "
      %break
    %default
      %assign errTxt = "block attempts to take the address of " + ...
        "'%<LibGetRecordVarName(record)>', but " + ...
        "'%<LibGetRecordVarName(record)>' is not addressable because " + ...
        "of its custom storage class."
  %endswitch
  %<LibBlockReportError(block, errTxt)>
%endfunction %% SLibReportNonAddressableError


%% DocFunction{Other Useful Functions}: LibIsComplex ===========================
%% Abstract:
%%   Returns 1 if the argument passed in is complex, 0 otherwise.
%%
%function LibIsComplex(arg) void
  %% This function determines if the argument passed in is complex.

  %%---------------------------------------
  %% Argument         Real        Complex
  %%---------------------------------------
  %% Double:          Real        Complex
  %% Single:          Real32      Complex32
  %% Signed ints:     Number      Gaussian
  %% Unsigned ints:   Unsigned    UnsignedGaussian
  %%---------------------------------------

  %assign arg_type = TYPE(arg[0])
  %return ( (arg_type == "Complex") || ...
            (arg_type == "Complex32") || ...
            (arg_type == "Gaussian") || ...
            (arg_type == "UnsignedGaussian") )

%endfunction %% LibIsComplex


%% DocFunction{Sample Time Functions}: LibIsDiscrete ===========================
%% Abstract:
%%   Returns 1 if the specified task identifier (TID) is discrete, 0 otherwise.
%%   Note, task identifiers equal to "triggered" or "constant" are not discrete.
%%
%function LibIsDiscrete(TID) void
  %if TYPE(TID) == "Number" || TYPE(TID) == "Vector"
    %assign period = ::CompiledModel.SampleTime[TID[0]].PeriodAndOffset[0]
    %if period > 0.0
      %return 1
    %else
      %return 0
    %endif
  %elseif LibTriggeredTID(TID) || ISEQUAL(TID, "constant")
    %return 0
  %else
    %<LibReportFatalError("Invalid TID (%<TID>)")>
  %endif
%endfunction %% LibIsDiscrete


%% DocFunction{Sample Time Functions}: LibIsContinuous =========================
%% Abstract:
%%   Returns 1 if the specified task identifier (TID) is continuous, 0 otherwise.
%%   Note, TIDs equal to "triggered" or "constant" are not continuous.
%%
%function LibIsContinuous(TID) void
  %if LibTriggeredTID(TID) || ...
      ISEQUAL(TID, "constant") || ...
      (TYPE(TID) == "Number" && TID < 0)
    %return 0
  %elseif TYPE(TID) == "Number"
    %if TID < 0
      %return 0
    %else
      %assign period = ::CompiledModel.SampleTime[TID].PeriodAndOffset[0]
      %assign offset = ::CompiledModel.SampleTime[TID].PeriodAndOffset[1]
      %if period == 0.0 && offset == 0.0
        %return 1
      %else
        %return 0
      %endif
    %endif
  %else
    %<LibReportFatalError("Invalid TID (%<TID>)")>
  %endif
%endfunction %% LibIsContinuous

%% DocFunction{Sample Time Functions}: LibIsZOHContinuous ======================
%% Abstract:
%%   Returns 1 if the specified task identifier (TID) is ZOH continuous,
%%   0 otherwise.
%%   Note, TIDs equal to "triggered" or "constant" are not ZOH continuous.
%%
%function LibIsZOHContinuous(TID) void
  %if TYPE(TID) == "Number" && TID >= 0
    %assign period = ::CompiledModel.SampleTime[TID].PeriodAndOffset[0]
    %assign offset = ::CompiledModel.SampleTime[TID].PeriodAndOffset[1]
    %if period == 0.0 && offset == 1.0
      %return 1
    %else
      %return 0
    %endif
  %elseif LibTriggeredTID(TID) || ISEQUAL(TID, "constant")
    %return 0
  %else
    %<LibReportFatalError("Invalid TID (%<TID>)")>
  %endif
%endfunction %% LibIsContinuous


%% DocFunction{Other Useful Functions}: LibIsMinorTimeStep=====================
%% Abstract:
%%
%%   Returns a string to access whether the current simulation step is
%%   is a minor time step.
%%
%%   This function is the TLC version of the SimStruct macro:  ssIsMinorTimeStep
%%
%function LibIsMinorTimeStep() void

  %return RTMIs("MinorTimeStep")

%endfunction %% LibIsMinorTimeStep


%% DocFunction{Other Useful Functions}: LibIsMajorTimeStep=====================
%% Abstract:
%%
%%   Returns a string to access whether the current simulation step is
%%   is a major time step.
%%
%%   This function is the TLC version of the SimStruct macro: ssIsMajorTimeStep
%%
%function LibIsMajorTimeStep() void

  %return RTMIs("MajorTimeStep")

%endfunction %% LibIsMajorTimeStep


%% DocFunction{Other Useful Functions}: LibGetT ================================
%% Abstract:
%%   Return a string to access the absolute time. You should only use this
%%   function to access time.
%%
%%   This function is the TLC version of the SimStruct macro: ssGetT.
%%
%function LibGetT() void
  %if SLibIsERTCodeFormat()
    %return LibGetTaskTime(0)
  %else
    %return RTMGet("T")
  %endif

%endfunction %% LibGetT


%% DocFunction{Other Useful Functions}: LibGenConstVectWithInit ================
%% Abstract:
%%   Return an initialized static constant variable string of form:
%%
%%      static const typeName varId[] = { data };
%%
%%   The typeName is generated from typeId which can be one of:
%%     tSS_DOUBLE, tSS_SINGLE, tSS_BOOLEAN, tSS_INT8, tSS_UINT8,
%%     tSS_INT16, tSS_UINT16, tSS_INT32, tSS_UINT32,
%%
%%   The data input argument must be a numeric scalar or vector and must
%%   be finite (no Inf, -Inf, or NaN values).
%%
%%   Note, this function is provided for C-code targets only.
%%
%function LibGenConstVectWithInit(data, typeId, varId)

  %if SIZE(data,0) > 1 && SIZE(data,1)
    %<SLibReportErrorWithId("RTW:tlc:LibGenConstVectWithInitErr")>
  %endif

  %assign tmpVar = temp { Value  data ; DataTypeIdx typeId }
  %assign vals   = LibPrepParameter(temp)
  %openfile initializer
  %if SLibIsNdIndexingFeatureOn()
    %assign nonFiniteIndices = GENERATE_FORMATTED_VALUE(vals, "", 0, 1)
  %else
    %assign nonFiniteIndices = GENERATE_FORMATTED_VALUE(vals, "")
  %endif
  %closefile initializer


  %if nonFiniteIndices[0][0] > 0
    %<SLibReportErrorWithId("RTW:tlc:LibGenConstVectWithInitErr2")>
  %endif
  %assign type = LibGetDataTypeNameFromId(typeId)

  %openfile str
  %if SIZE(data,0) == 1 && SIZE(data,1) == 1
    %assign brackets = ""
  %else
    %assign brackets = "[]"
  %endif
  static const %<type> %<varId>%<brackets> = %<initializer>;
  %closefile str

  %return str

%endfunction %% end LibGenConstVectWithInit


%% Function: LibTaskComment ====================================================
%% Abstract:
%%   Produces a sample time comment containing period
%%   and offset given a task identifier.
%%
%function LibTaskComment(tid) void
  %if TYPE(tid) == "Number" && tid >= 0
    %if SLibIsExportFcnDiagram() && LibAsynchronousTriggeredTID(tid)
      %return ""
    %endif
    %assign period = ::CompiledModel.SampleTime[tid].PeriodAndOffset[0]
    %assign offset = ::CompiledModel.SampleTime[tid].PeriodAndOffset[1]
    %return "/* Sample time: [%<period>s, %<offset>s] */"
  %elseif WHITE_SPACE(tid)
    %return ""
  %else
    %return "/* Sample time: %<tid> */"
  %endif
%endfunction %% LibTaskComment

%if EXISTS(UseGlobalTIDTracking) == 0
  %assign ::UseGlobalTIDTracking = TLC_FALSE
%else
  %assign ::UseGlobalTIDTracking = TLC_TRUE
%endif

%% Function: LibNeedTID ========================================================
%% Abstract:
%%   LibNeedTID sets the global flag ::CompiledModel.NeedTID to TLC_TRUE.
%%   TID is a argument that must be passed in from the parent, so the
%%   subsystem block propagates this flag up in the system hierarchy.
%%
%function LibNeedTID() void
  %<SLibCG_AccessTID()>
  %assign ::CompiledModel.NeedTID = %<::UseGlobalTIDTracking>
%endfunction %% LibNeedTID


%% Function: LibNeedCPI ========================================================
%% Abstract:
%%   LibNeedCPI sets the system flag NeedCPIInOutputUpdate (Control Port
%%   Index) flag.  This flag is needed when a function-call subsystem
%%   trigger port block has outputs and the control width is greater
%%   than one.  It needs to be attached to the system because system code
%%   generation recurses and using one global flag is not possible.
%%
%function LibNeedCPI(system) void
  %assign fcn = ::BlockFcn
  %if fcn == "Output" || fcn == "OutputUpdate"
    %assign fcn = "OutputUpdate"
  %endif
  %<SLibCG_AccessCPI()>
  %assign tempName = "NeedCPIIn" + fcn
  %<LibSetSystemField(system,tempName, TLC_TRUE)>
%endfunction


%% Function: LibTID ============================================================
%% Abstract:
%%   LibTID returns tid and informs the code generator that the tid is
%%   used in the context of this call.
%%   This function should always be used instead of hard-coding %<::tTID>.
%%
%function LibTID() void
  %if ::CompiledModel.NumSampleTimes == 1 || ...
    SLibSingleTasking()
    %return "0"
  %else
    %<LibNeedTID()>
    %return ::tTID
  %endif
%endfunction %% LibTID

%% Function: SLibSetNeedFirstTime ====================================
%% Abstract:
%%   SLibSetNeedFirstTime sets the global falg ::CompiledModel.NeedFirstTime
%%   to TLC_TRUE
%%
%function SLibSetNeedFirstTime() void
  %assign ::CompiledModel.NeedFirstTime = TLC_TRUE
%endfunction %%SLibSetNeedFirstTime

%% Function: SLibGetNeedFirstTime ====================================
%% Abstract:
%%   SLibSetNeedFirstTime returns the global falg ::CompiledModel.NeedFirstTime
%%
%%
%function SLibGetNeedFirstTime() void
  %return ::CompiledModel.NeedFirstTime
%endfunction %%SLibGetNeedFirstTime

%% Function: SLibFirstTime ========================================
%% Abstract:
%%  Returns "firstTime" and informs the code generator that "firstTime"
%%  is used.
%%
%function SLibFirstTime() void
  %<SLibSetNeedFirstTime()>
  %return "firstTime"
%endfunction %% SLibFirstTime


%% Function: SLibSetEmptyModelRefInitializeFcn ====================================
%% Abstract:
%%   SLibSetEmptyModelRefInitializeFcn sets the global falg ::CompiledModel.EmptyModelRefInitializeFcn
%%   to TLC_TRUE
%%   This flag indicates that whether the generated initialize function of the Referenced model is empty. 
%%
%function SLibSetEmptyModelRefInitializeFcn() void
  %assign ::CompiledModel.EmptyModelRefInitializeFcn = TLC_TRUE
%endfunction %%SLibSetEmptyModelRefInitializeFcn

%% Function: SLibGetEmptyModelRefInitializeFcn ====================================
%% Abstract:
%%   SLibGetEmptyModelRefInitializeFcn returns the global falg ::CompiledModel.EmptyModelRefInitializeFcn
%%
%%
%function SLibGetEmptyModelRefInitializeFcn() void
  %return ::CompiledModel.EmptyModelRefInitializeFcn
%endfunction %%SLibGetEmptyModelRefInitializeFcn

%% Function: SLibEmptyModelRefInitializeFcn ========================================
%% Abstract:
%%  Returns "EmptyModelRefInitializeFcn" and informs the code generator that "EmptyModelRefInitializeFcn"
%%  is used.
%%
%function SLibEmptyModelRefInitializeFcn() void
  %<SLibSetEmptyModelRefInitializeFcn()>
  %return "EmptyModelRefInitializeFcn"
%endfunction %% SLibEmptyModelRefInitializeFcn

%% DocFunction{Sample Time Functions}: LibGetTaskTimeFromTID ===================
%% Abstract:
%%   Returns a string to access the absolute time of the task accociated with
%%   the block.
%%   If the block is constant or the system is single rate, this is the TLC
%%   version of the SimStruct macro: "ssGetT(S)" and "ssGetTaskTime(S, tid)"
%%   otherwise.  In both cases, S is the name of the SimStruct.
%%
%function LibGetTaskTimeFromTID(block) void
  %% ----------------------
  %% This warning message it temporary turned off because State-flow has not updated yet.
  %% This warning message need to be turned after state-flow blocks have be updated, and
  %% register NeedAbsoluteTime whenever absolute time is required.
  %% ---------------------
  %% %if !ISFIELD(block, "NeedAbsoluteTime")
  %%   %LibBlockReportWarnin(block, "Absolute time is required. The block does not " + ...
  %% "regesiter NeedAbsolute Time. Obsolete absoluter time will be used."
  %% %endif
  %if ISEQUAL(TID, "constant")
    %if RTMChildSfunctionIsReqFcn()
      %% rtM has StartTime field
      %return RTMGet("TStart")
    %else
      %return ::CompiledModel.StartTime
    %endif
  %endif

  %assign tid = SLibGetNumericTID(block)
  %if ISFIELD(block, "StateflowChartType")
    %% Need hard code in tid value for StateflowChart
    %% because SF is single rate and it doesn't passed
    %% in tid via arg list
    %return RTMGetTaskTimeForTID(tid)
  %else
    %return LibGetTaskTime(tid)
  %endif

%endfunction %% LibGetTaskTimeFromTID

%% DocFunction{Sample Time Functions}: LibGetTaskTime ==========================
%% Abstract:
%%   Returns a string to access the absolute time of the task.
%%   This function is the TLC version of the SimStruct macro:
%%   "ssGetTaskTime(S,tid)"
%%
%function LibGetTaskTime(tid) void
  %if SLibIsERTCodeFormat()
    %return RTMGetTaskTimeForTID(tid)
  %else
    %if LibIsSingleRateSystem(System[NumSystems-1])
      %return RTMGet("T")
    %else
      %if ::BlockFcn == "Output" || ...
        ::BlockFcn == "OutputUpdate" || ...
        ::BlockFcn == "Update"
        %% tid is passed in for these functions
        %return RTMGetTaskTimeForTID(tid)
      %else
        %% tid is not passed in, need hard code here
        %return RTMGetTaskTimeForTID(tid)
      %endif
    %endif
  %endif
%endfunction %% LibGetTaskTime

%% DocFunction{Sample Time Functions}: LibGetClockTick =========================
%% Abstract:
%%   Returns integer task time (current clock tick of the task timer).
%%   The resolution of the timer can be obtained from
%%   LibGetClockTickStepSize(tid). The data type id of the timer can
%%   be obtained from LibGetClockTickDataTypeId(tid).
%%
%function LibGetClockTick(tid) void
  %assert TYPE(tid) == "Number" && tid >= 0
  %assign retVal = ""
  %if ClockTickForTIDIsReqFcn(tid)
    %<SLibSetNeedAbsoluteTime(tid)>
    %assign retVal = RTMGet("ClockTick%<tid>")
  %else
    %assign timer_resolution = SampleTime[tid].ClockTickStepSize
    %if timer_resolution == 0
       %assign retVal = LibGetTaskTime(tid)
     %else
       %assign clockTick_DTypeId = SampleTime[tid].ClockTickDataTypeId
       %if clockTick_DTypeId == tSS_TIMER_UINT32_PAIR
         %assign clockTick_DType   = LibGetDataTypeNameFromId(tSS_UINT32)
       %else
         %assign clockTick_DType = LibGetDataTypeNameFromId(clockTick_DTypeId)
       %endif
       %assign intTime = "%<LibGetTaskTime(tid)>/%<timer_resolution>+0.5"
       %assign floorTime = LibGenMathFcnCall("floor",  tSS_DOUBLE,"%<intTime>","")
       %assign retVal = "((%<clockTick_DType>)(%<floorTime>))"
     %endif
  %endif
  %return retVal
%endfunction %% LibGetClockTick

%% DocFunction{Sample Time Functions}: LibGetClockTickHigh =====================
%% Abstract:
%%   Returns high order word of integer task time. This function is used  when
%%   uint32 pairs are used to store absolute time. The resolution of the timer
%%   can be obtained from LibGetClockTickStepSize(tid).
%%
%function LibGetClockTickHigh(tid) void
  %assert TYPE(tid) == "Number" && tid >= 0
  %if LongClockTickForTIDIsReqFcn(tid)
    %<SLibSetNeedAbsoluteTime(tid)>
    %return RTMGet("ClockTickH%<tid>")
  %else
    %assign timer_resolution  = SampleTime[tid].ClockTickStepSize
    %assign weighedResolution = timer_resolution * 4.294967296e+09
    %assert timer_resolution > 0
    %assign clockTick_DType   = LibGetDataTypeNameFromId(tSS_UINT32)
    %assign clockTick = LibGenMathFcnCall("floor", tSS_DOUBLE, ...
      "%<LibGetTaskTime(tid)> / (%<weighedResolution>) + 0.5", "")
    %return "((%<clockTick_DType>)%<clockTick>)"
  %endif
%endfunction %% LibGetClockTick

%% DocFunction{Sample Time Functions}: LibGetClockTickStepSize =================
%% Abstract:
%%   Returns clock tick step size, which is the resolution of the integer task
%%   time. This function can't be used if the task doesn't have a timer.
%%
%function LibGetClockTickStepSize(tid) void
  %assert TYPE(tid) == "Number" && tid >= 0
  %assert ClockTickForTIDIsReqFcn(tid)
  %return SampleTime[tid].ClockTickStepSize
%endfunction %% LibGetClockTickStepSize

%% DocFunction{Sample Time Functions}: LibGetClockTickDataTypeId ===============
%% Abstract:
%%   Returns clock tick data type id.
%%
%function LibGetClockTickDataTypeId(tid) void
  %assert TYPE(tid) == "Number" && tid >= 0
  %assert ClockTickForTIDIsReqFcn(tid)
  %return SampleTime[tid].ClockTickDataTypeId
%endfunction %% LibGetClockTickDataTypeId

%% SLibGetDbBufReadBuf =========================================================
%% Abstract:
%%   Returns DbBufReadBuf. This flag is used by a double buffer algorithm.
%%   The algorithm insures data integrity when asynchronous task reads absolute
%%   time from base rate.
%%
%function SLibGetDbBufReadBuf(tid)
  %assert RTMClockTick0DbBufIsReqFcn(%<tid>) || RTMContTDbBufIsReqFcn(%<tid>)
  %return RTMGet("DbBufReadBuf%<tid>")
%endfunction %%SLibGetDbBufReadBuf

%% SLibGetDbBufWriteBuf ========================================================
%% Abstract:
%%   Returns DbBufWriteBuf. This flag is used by a double buffer algorithm. The
%%   algorithm insures data integrity when asynchronous task reads absolute
%%    time from base rate.
%%
%function SLibGetDbBufWriteBuf(tid)
  %assert RTMClockTick0DbBufIsReqFcn(%<tid>) || RTMContTDbBufIsReqFcn(%<tid>)

  %return RTMGet("DbBufWriteBuf%<tid>")
%endfunction %%SLibGetDbBufWriteBuf

%% SLibGetDbBufLastBufWr ======================
%% Abstract:
%%  Returns DbBufLastBufWr(last buffer written) . This flag is used by a double
%% buffer algorithm. The algorithm insures data integrity when
%% asynchronous task reads absolute time from base rate. %%
%function SLibGetDbBufLastBufWr(tid)
  %assert RTMClockTick0DbBufIsReqFcn(%<tid>) || RTMContTDbBufIsReqFcn(%<tid>)

  %return RTMGet("DbBufLastBufWr%<tid>")
%endfunction %%SLibGetDbBufLastBufWr


%% SLibGetDbBufClockTickForTid ==================================
%% Abstract:
%%  Returns the pointer of clock tick double buffers for specific tid.
%% The double is used to insures data integrity when
%% asynchronous task reads absolute time from base rate.
%%
%function SLibGetDbBufClockTickForTID(tid)
  %assert RTMClockTick0DbBufIsReqFcn(%<tid>)

  %return RTMGet("DbBufClockTick%<tid>")
%endfunction %%SLibGetDbBufClockTickForTID


%% SLibGetDbBufClockTickHForTID ==================================
%% Abstract:
%%  Returns the pointer of clock tick high word double buffers
%% for specific tid. The double is used to insures data integrity when
%% asynchronous task reads absolute time from base rate.
%%
%%
%function SLibGetDbBufClockTickHForTID(tid)
  %assert RTMClockTick0DbBufIsReqFcn(%<tid>) && LongClockTickForTIDIsReqFcn(0)

  %return RTMGet("DbBufClockTickH%<tid>")
%endfunction %%SLibGetDbBufClockTickHForTID

%% SLibGetDbBufContTForTID ===================================
%% Abstract::
%%  Returns the pointer of continuous double buffers for specific tid.
%% The double is used to insures data integrity when
%% asynchronous task reads absolute time from base rate.
%%
%function SLibGetDbBufContTForTID(tid)
  %assert RTMContTDbBufIsReqFcn(tid)

  %return RTMGet("DbBufContT%<tid>")
%endfunction %% SLibGetDbBufContTForTID


%% SLibGetH2LBufBeingRead ======================
%% Abstract:
%%  Return flag in Timing H2LBufBeingRead.
%%  This flag help to ensured data integrity
%%  of time when lower priority async task
%%  read time from base rate task. This flag
%%  keep track which buffer is being read
%%
%function SLibGetH2LBufBeingRead(tid)
  %assert RTMClockTick0H2LIsReqFcn(tid) || RTMContTH2LIsReqFcn(tid)

  %return RTMGet("H2LBufBeingRead%<tid>")
%endfunction %%SLibGetH2LBufBeingRead

%% SLibGetH2LLastBufWr ============================
%% Abstract:
%%  Return flag in Timing H2LLastBufWr.
%%  This flag help to insured data integrity
%%  of time when lower priority async task
%%  read time from base rate task. This flag
%%  keep track what is the buffer being written last.
%%
%function SLibGetH2LLastBufWr(tid)
  %assert RTMClockTick0H2LIsReqFcn(tid) || RTMContTH2LIsReqFcn(tid)

  %return RTMGet("H2LLastBufWr%<tid>")
%endfunction %%SLibGetH2LLastBufWr

%% SLibGetH2LDbBufClockTickForTID ==================================
%% Abstract::
%%  Return pointer of double buffer for clocktick0 used for H2L
%%  data transfer: H2LDbBufClockTick0
%%
%function SLibGetH2LDbBufClockTickForTID(tid)
  %assert RTMClockTick0H2LIsReqFcn(tid)

  %return RTMGet("H2LDbBufClockTick%<tid>")
%endfunction %%SLibGetH2LDbBufClockTickForTID

%% SLibGetH2LDbBufClockTickHForTID ==================================
%% Abstract::
%%  Return pointer of double buffer for clocktick0H used for H2L
%%  data transfer: H2LDbBufClockTickH0
%%
%function SLibGetH2LDbBufClockTickHForTID(tid)
  %assert RTMClockTick0H2LIsReqFcn(tid) && LongClockTickForTIDIsReqFcn(0)

  %return RTMGet("H2LDbBufClockTickH%<tid>")
%endfunction %%SLibGetH2LDbBufClockTickHForTID

%% SLibGetH2LDbBufContTForTID ===================================
%% Abstract::
%%  Return pointer of double buffer for ContT used for H2L
%%  data transfer: H2LDbBufContT
%%
%function SLibGetH2LDbBufContTForTID(tid)
  %assert RTMContTH2LIsReqFcn(tid)

  %return RTMGet("H2LDbBufContT%<tid>")
%endfunction %% SLibGetH2LDbBufContTForTID

%% SLibGetL2HLastBufWr ======================================
%% Abstract::
%%  Return flag in Timing L2HLastBufWr.
%%  This flag help to insured data integrity
%%  of time when higher priority async task
%%  read time from base rate task. This flag
%%  keep track what is the buffer being written last.
%%
%function SLibGetL2HLastBufWr()
  %assert RTMClockTick0L2HIsReqFcn() || RTMContTL2HIsReqFcn()

  %return RTMGet("L2HLastBufWr")
%endfunction %% SLibGetL2HLastBufWr

%% SLibGetL2HDbBufClockTick ==================================
%% Abstract::
%%  Return pointer of double buffer for clocktick0 used for L2H
%%  data transfer: L2HDbBufClockTick
%%
%function SLibGetL2HDbBufClockTick()
  %assert RTMClockTick0L2HIsReqFcn()

  %return RTMGet("L2HDbBufClockTick")
%endfunction %%SLibGetL2HDbBufClockTick

%% SLibGetL2HDbBufClockTickH ==================================
%% Abstract::
%%  Return pointer of double buffer for clocktick0H used for L2H
%%  data transfer: L2HDbBufClockTickH
%%
%function SLibGetL2HDbBufClockTickH()
  %assert RTMClockTick0L2HIsReqFcn() && LongClockTickForTIDIsReqFcn(0)

  %return RTMGet("L2HDbBufClockTickH")
%endfunction %%SLibGetL2HDbBufClockTickH

%% SLibGetL2HDbBufContT ===================================
%% Abstract::
%%  Return pointer of double buffer for ContT used for L2H
%%  data transfer: L2HDbBufContT
%%
%function SLibGetL2HDbBufContT()
  %assert RTMContTL2HIsReqFcn()

  %return RTMGet("L2HDbBufContT")
%endfunction %%SLibGetL2HDbBufContT

%function SLibGetTimerSemID(tid)
  %return RTMGet("SemIdForTask%<tid>")
%endfunction

%function SLibGetClockTickBufForTID(tid)
  %return RTMGet("ClockTickBuf%<tid>")
%endfunction

%function SLibGetClockTickHBufForTID(tid)
  %return RTMGet("ClockTickHBuf%<tid>")
%endfunction

%% DocFunction{Sample Time Functions}: LibGetElapseTimeCounter =================
%% Abstract:
%%     Returns an integer elapsed time. This is the number of clock ticks
%%  elapsed since the last time the system started. To get realworld elapsed time,
%%  this integer elapsed time must be multiplied by the applicable resolution.
%%  You can obtain the resolution by calling LibGetElapseTimeResolution(system).
%%  You can obtain the data type id of integer elapsed time counter
%%  by calling LibGetElapseTimeCounterDTypeId(system)
%%
%function LibGetElapseTimeCounter(system) void
  %assign callSites      = system.CallSites
  %assign sysIdx = system.CallSites[0][2]
  %assign blkIdx = system.CallSites[0][3]
  %assign ssBlock = ::CompiledModel.System[sysIdx].Block[blkIdx]

  %assert system.Type != "root"
  
  %if (ISFIELD(ssBlock, "NeedElapseTime") && ...
    ssBlock.NeedElapseTime)
    %if ISFIELD(ssBlock, "%<ssBlock.ElapseTimeSource>")
      %% pass in DW record
      %return LibBlockDWork(ssBlock.%<ssBlock.ElapseTimeSource>,"","",0)
    %else
      %% pass in string.
      %return LibBlockDWork("%<ssBlock.ElapseTimeSource>","","",0)
    %endif
  %else
    %assert LibIsSingleRateSystem(system)
    %return 1
  %endif

%endfunction %% LibGetElapseTimeCounter

%function LibGetElapseTimeCounterH(system) void
  %assign callSites      = system.CallSites
  %assign sysIdx = system.CallSites[0][2]
  %assign blkIdx = system.CallSites[0][3]
  %assign ssBlock = ::CompiledModel.System[sysIdx].Block[blkIdx]

  %assert system.Type != "root"

  %assert (ISFIELD(ssBlock, "NeedElapseTime") && ...
    ssBlock.NeedElapseTime)
  %assert LibGetElapseTimeCounterDTypeId(system) == ...
    tSS_TIMER_UINT32_PAIR

  %if ISFIELD(ssBlock, "%<ssBlock.ElapseTimeSource>")
    %% pass in DW record
    %return LibBlockDWork(ssBlock.%<ssBlock.ElapseTimeSource>,"","",1)
  %else
    %% pass in string.
    %return LibBlockDWork("%<ssBlock.ElapseTimeSource>","","",1)
  %endif

%endfunction %% LibGetElapseTimeCounter

%% SLibGetElapseTimeCounterUsesVector  =========================
%%  Determine if the Elapse Time Counter uses a two element
%%  vector of uint32_T's
%%
%function SLibGetElapseTimeCounterUsesVector(system) void
  %%
  %assign dtypeId = LibGetElapseTimeCounterDTypeId(system)
  %%
  %assign isVector = (dtypeId == tSS_TIMER_UINT32_PAIR)
  %return isVector
  %%
%endfunction %% SLibGetElapseTimeCounterUsesVector

%% LibBlockGetElapseTimeCounter =================
%% Abstract:
%%   for non timer_uint32_pair, return rt_elapsetime,
%%   for timer_uint32_pair, return rt_elapsetime[0]
%function LibBlockGetElapseTimeCounter(system) void
  %return LibGetElapseTimeCounter(system)
%endfunction

%% DocFunction{Sample Time Functions}: LibGetElapseTimeCounterDTypeId ===
%% Abstract:
%%  Returns the date type id of the integer elapsed time returned by
%% LibGetElapseTimeCounter(system)
%%
%function LibGetElapseTimeCounterDTypeId(system) void
  %if ISFIELD(system,"ElapseTimeDataTypeId")
    %return system.ElapseTimeDataTypeId
  %else
    %return tSS_UINT8
  %endif

%endfunction %% LibGetElapseTimeCounterDTypeId

%% DocFunction{Sample Time Functions}: LibGetElapseTimeResolution ===
%% Abstract:
%%  Returns resolution of integer elapsed time returned by
%% LibGetElapseTimeCounter
%%
%function LibGetElapseTimeResolution(system) void
  %assert LibIsSingleRateSystem(system)
  
  %if LibSystemIsRoot(system)
    %assign t_resolution = SampleTime[0].ClockTickStepSize
  %else 
    %assign sysIdx = system.CallSites[0][2]
    %assign blkIdx = system.CallSites[0][3]
    %assign ssBlock = System[sysIdx].Block[blkIdx]
    
    %with ssBlock
      %if LibAsynchronousTriggeredTID(SubsystemTID)
        %assign t_resolution =  SampleTime[SubsystemTID].ClockTickStepSize
      %else
        %assign tid = SLibGetNumericTID(ssBlock)
        %assign t_resolution = SampleTime[tid].ClockTickStepSize
      %endif
    %endwith
  %endif
  
  %return t_resolution

%endfunction %% LibGetElapseTimeResolution

%function FcnEffectiveTid(block) void
    %return ISFIELD(block, "TriggerTID") ? block.TriggerTID : block.TID
%endfunction

%% DocFunction{Sample Time Functions}: LibGetElapseTime ===================
%% Abstract:
%%  Returns time elapsed since the last time the
%% subsystem started.
%%
%function LibGetElapseTime(system) void
  %assign callSites      = system.CallSites

  %assert system.Type != "root"
  
  %assign t_resolution = LibGetElapseTimeResolution(system)
  %if t_resolution == 0
    %return LibGetElapseTimeCounter(system)
  %endif

  %assign elapse_T =  LibGetElapseTimeCounter(system)
  %if LibGetElapseTimeCounterDTypeId(system) == tSS_TIMER_UINT32_PAIR
    %assign elapse_T_H = LibGetElapseTimeCounterH(system)
    %if t_resolution == 1
      %return "(%<elapse_T> + " + ...
        "(%<LibGetDataTypeNameFromId(tSS_DOUBLE)>)" + ...
        "(%<elapse_T_H>)*4294967296.0)"
    %else
      %return "(%<elapse_T> + " + ...
        "(%<LibGetDataTypeNameFromId(tSS_DOUBLE)>)" + ...
        "(%<elapse_T_H>)*4294967296.0)" + ...
        " * %<t_resolution>"
    %endif
  %else
    %if t_resolution == 1
      %return "(%<elapse_T>)"
    %else
      %return "(%<elapse_T> * %<t_resolution>)"
    %endif
  %endif

%endfunction %% LibGetElapseTime


%% Function: LibNeedRealNonFinite ==============================================
%% Abstract:
%%   Set appropriate flags:
%%      o ::CompiledModel.NeedRealInf
%%      o ::CompiledModel.NeedRealMinusInf
%%      o ::CompiledModel.NeedRealNaN
%%   to indicate that non-finite values are being accessed.
%%
%%   The value argument can be one of: {inf, -inf, nan, "inf", "-inf", "nan"}
%%
%function LibNeedRealNonFinite(value) void
  %% Error out if this model should not be using nonfinites.
  %% This check should be migrated to TgtFcnLib which will
  %% cover both TLC and CGIR
  %assign supportNonFinite = FEVAL("get_param", LibGetModelName(), ...
    "SupportNonFinite")
  %%
  %% Get past a TLC bug which says
  %%  nan == inf
  %%  nan == -inf
  %% Also get past a TLC bug that doesn't allow you to change
  %% the value mid-stream of the if-then-else evaluation.
  %%
  %assign vType = TYPE(value)
  %if vType == "Real"
    %assign typeId = tSS_DOUBLE
  %else
    %assign typeId = tSS_SINGLE
  %endif
  %if vType == "Real" || vType == "Real32"
    %if ISNAN(value)
      %assign newValue = "nan"
    %elseif value == rtInf
      %assign newValue = "inf"
    %elseif value == rtMinusInf
      %assign newValue = "-inf"
    %else
      %<LibReportFatalError("Unknown value: %<value>")>
    %endif
    %assign value = newValue
  %endif

  %if TYPE(supportNonFinite) == "String" && supportNonFinite == "off"
    %assign errArgs = ["%<value>", "%<LibGetModelName()>"]
    %<SLibReportErrorWithIdAndArgs("RTW:tlc:NonFiniteSupport", errArgs)>
  %endif

  %switch value
    %case "inf"
      %assign ::CompiledModel.NeedRealInf = 1
      %assign dummy = SLibGenOneInputOneOutputFcnCallInfo("getInf",tSS_VOID,typeId,"")
      %break
    %case "-inf"
      %assign ::CompiledModel.NeedRealMinusInf = 1
      %assign dummy = SLibGenOneInputOneOutputFcnCallInfo("getMinusInf",tSS_VOID,typeId,"")
      %break
    %case "nan"
      %assign ::CompiledModel.NeedRealNaN = 1
      %assign dummy = SLibGenOneInputOneOutputFcnCallInfo("getNaN",tSS_VOID,typeId,"")
      %break
    %default
      %<LibReportFatalError("Unknown non-finite value: %<value>")>
  %endswitch

%endfunction %% end LibNeedRealNonFinite



%% Function: LibRealNonFinite ==================================================
%% Abstract:
%%   LibRealNonFinite returns the appropriate non-finite and sets the
%%   corresponding global flag indicating the non-finite value's usage.
%%   This function should always be used instead of hard-coding %<::tInf>,
%%   %<::tMinusInf>, or %<::tNaN>.
%%
%%   Arguments:
%%      value: One of {inf, -inf, nan, "inf", "-inf", "nan"}
%%
%function LibRealNonFinite(value) void
  %%
  %% Get past a TLC bug which say
  %%  nan == inf
  %%  nan == -inf
  %% Also get past a TLC bug that doesn't allow you to change
  %% the value mid-stream of the if-then-else evaluation.
  %%
  %if TYPE(value) == "Real"
    %if ISNAN(value)
      %assign newValue = "nan"
    %elseif value == rtInf
      %assign newValue = "inf"
    %elseif value == rtMinusInf
      %assign newValue = "-inf"
    %else
      %<LibReportFatalError("Unknown value: %<value>")>
    %endif
    %assign value = newValue
  %endif

  %switch value
    %case "inf"
      %<LibNeedRealNonFinite("inf")>
      %return ::tInf
    %case "-inf"
      %<LibNeedRealNonFinite("-inf")>
      %return ::tMinusInf
    %case "nan"
      %<LibNeedRealNonFinite("nan")>
      %return ::tNaN
    %default
      %<LibReportFatalError("Unknown non-finite value: %<value>")>
  %endswitch
%endfunction %% end LibRealNonFinite


%% Function: LibCheckValue =====================================================
%% Abstract:
%%   LibCheckValue determines if a value is non-finite and if so, sets the
%%   appropriate access flag.
%%
%function LibCheckValue(reserved, value) void
  %%multiwords/biglong fixpt value is in a string representation
  %if TYPE(value)!="String" && !ISFINITE(value)
    %<LibNeedRealNonFinite(value)>
  %endif
%endfunction %% LibCheckValue


%% Function: SLibRealNonFinitesRequired ========================================
%% Abstract:
%%   SLibRealNonFinitesRequired returns one if a non-finite value was used
%%   in the generated code or there is non-inline sfunction.
%%
%%
%function SLibRealNonFinitesRequired() void
  %assign retVal = (NeedRealInf || NeedRealMinusInf || NeedRealNaN) ? 1 : 0
  %assign retVal = retVal || NumChildSFunctions > 0 || MatFileLogging

  %% Consider nonfinite rtIsInf(F)/rtIsNaN(F) TFL function access
  %assign numcbs = FEVAL("rtwprivate", "rtw_get_tfl_used_fcns_info", ...
    LibGetModelName(), -1)
  %foreach i = numcbs
    %assign fctInfo = FEVAL("rtwprivate", "rtw_get_tfl_used_fcns_info", ...
      LibGetModelName(), i+1)
    %if fctInfo.FcnName == "rtIsInf" || fctInfo.FcnName == "rtIsInfF" || ...
        fctInfo.FcnName == "rtGetInf" || fctInfo.FcnName == "rtGetMinusInf" || ...
        fctInfo.FcnName == "rtGetInfF" || fctInfo.FcnName == "rtGetMinusInfF"

      %% Invoke error check to ensure nonfinite support is selected
      %<LibRealNonFinite("inf")>
      %assign retVal = 1
      %break
    %elseif fctInfo.FcnName == "rtIsNaN" || fctInfo.FcnName == "rtIsNaNF" || ...
            fctInfo.FcnName == "rtGetNaN" || fctInfo.FcnName == "rtGetNaNF"
      %% Invoke error check to ensure nonfinite support is selected
      %<LibRealNonFinite("nan")>
      %assign retVal = 1
      %break
    %elseif fctInfo.NonFiniteSupportNeeded == 1
      %% This will be true for TFL entries that will support non-finites
      %% in the gen callbacks.
      %assign retVal = 1
      %break
    %endif
  %endforeach

  %% make sure both non-finite support and floating point support are enabled
  %% if noninlined S-Functions exist
  %if (NumChildSFunctions > 0) && ((SupportNonFinite==0) || (PurelyIntegerCode==1))
    %<SLibReportErrorWithId("RTW:tlc:SupportNonInlinedSFcn")>
  %endif
  %return retVal
%endfunction %% SLibRealNonFinitesRequired


%% DocFunction{Sample Time Functions}: LibTriggeredTID =========================
%% Abstract:
%%   Returns whether this TID corresponds to a triggered rate
%%
%function LibTriggeredTID(tid) void

  %return ISEQUAL(tid, "triggered") || ...
    ISEQUAL(tid, -1) || ...
    LibAsynchronousTriggeredTID(tid)

%endfunction %% LibTriggeredTID


%% DocFunction{Sample Time Functions}: LibAsynchronousTriggeredTID ===================
%% Abstract:
%%   Returns whether this TID corresponds to a asynchronous triggered rate
%%
%function LibAsynchronousTriggeredTID(tid) void

  %return TYPE(tid) == "Number" && tid >= 0 && ...
    ::CompiledModel.SampleTime[tid].Asynchronous == "yes"

%endfunction %% LibAsynchronousTriggeredTID

%% Function SLibExplicitTaskingTID ===================
%% Abstract:
%%   Returns whether this TID corresponds to Explicit Tasking
%%
%function SLibExplicitTaskingTID(tid) void

  %return TYPE(tid) == "Number" && tid >= 0 && ...
    ::CompiledModel.SampleTime[tid].ExplicitTasking == "yes"

%endfunction %% LibExplicitTaskingTID

%% Function SLibExplicitPeriodicInExportFcnDiagram ===================
%% Abstract:
%%   Returns whether this TID is a Periodic Explicit Tasks in Export 
%%   Function diagram
%%
%function SLibExplicitPeriodicInExportFcnDiagram(tid) void

  %return TYPE(tid) == "Number" && tid >= 0 && ...
    SLibIsExportFcnDiagram() && ...
    SLibExplicitTaskingTID(tid) && !LibAsynchronousTriggeredTID(tid)

%endfunction %% SLibExplicitPeriodicInExportFcnDiagram


%function SLibLegacyAsynchronousTID(tid) void
  %return TYPE(tid) == "Number" && tid >= 0 && ...
    ISFIELD(::CompiledModel.SampleTime[tid], "EventSourceType") && ...
    ::CompiledModel.SampleTime[tid].EventSourceType =="AsyncSfcnBlk"
  %return
%endfunction %% SLibLegacyAsynchronousTID

%function SLibUnionSampletimeTID(tid) void
  %return TYPE(tid) == "Number" && tid >= 0 && ...
    ::CompiledModel.SampleTime[tid].IsUnionTs == "yes"
  %return
%endfunction %% SLibUnionSampletimeTID


%function SLibSynchronousTID(tid) void
  %return ::CompiledModel.SampleTime[tid].Asynchronous == "no"
%endfunction %% SLibLegacyAsynchronousTID

%function SLibControllableRateTID(tid) void
  %return TYPE(tid) == "Number" && tid > 0 && ...
    ISFIELD(::CompiledModel.SampleTime[tid], "CtrlRateInstanceIndex")
%endfunction %% SLibControllableRateTID 

%function SLibModelHasControllableRate() void
  %return ::CompiledModel.NumControllableSampleTimes > 0
%endfunction %% SLibModelHasControllableRate

%function SLibFirstControllableRateTID() void
  %assert SLibModelHasControllableRate()
  %foreach tid = NumRuntimeExportedRates
    %if SLibControllableRateTID(tid)
      %return tid
    %endif
  %endforeach
  %return -1
%endfunction %% SLibFirstControllableRateTID

%function SLibGetBlockCtrlRateIndex(block, locSTI) void  
  %% Currently, only single rate blocks could be ctrl rate onwers. In the future, this
  %% restriction will be removed.  
  %assign blockTid = block.TID
  %assert locSTI == 0 && TYPE(blockTid) == "Number" && SLibControllableRateTID(blockTid)  
  %if !IsModelReferenceTarget() && !Accelerator && !isRAccel      
    %return CompiledModel.SampleTime[blockTid].CtrlRateInstanceIndex    
  %else
    %return blockTid
  %endif
%endfunction %% SLibGetBlockCtrlRateIndex

%function SLibModelWideEventTID(tid) void
  %return TYPE(tid) == "Number" && tid >= 0 && ...
    ::CompiledModel.SampleTime[tid].IsModelWideEvent == "yes"
%endfunction %% SLibModelWideEventTID

%function SLibNonInlinedModelWideEventTID(tid) void
  %return SLibNonInlinedIRTEventTID(tid) || ...
    SLibParameterChangeEventTID(tid)
%endfunction %% SLibNonInlinedModelWideEventTID

%function SLibInitEventTID(tid) void
  %return TYPE(tid) == "Number" && tid >= 0 && ...
    ISFIELD(::CompiledModel.SampleTime[tid], "EventSourceType") && ...
    ::CompiledModel.SampleTime[tid].EventSourceType == "PowerUpEvent"
%endfunction %% SLibInitEventTID

%function SLibTermEventTID(tid) void
  %return TYPE(tid) == "Number" && tid >= 0 && ...
    ISFIELD(::CompiledModel.SampleTime[tid], "EventSourceType") && ...
    ::CompiledModel.SampleTime[tid].EventSourceType == "PowerDownEvent"
%endfunction %% SLibTermEventTID

%function SLibNonInlinedIRTEventTID(tid) void
  %return TYPE(tid) == "Number" && tid >= 0 && ...
    ISFIELD(::CompiledModel.SampleTime[tid], "EventSourceType") && ...
    (::CompiledModel.SampleTime[tid].EventSourceType == "ResetEvent" || ...
     ::CompiledModel.SampleTime[tid].EventSourceType == "ResetWithInitEvent" || ...
     (::CompiledModel.SampleTime[tid].EventSourceType == "PowerDownEvent" && ...
      IsModelReferenceSimTarget()))
%endfunction %% SLibNonInlinedIRTEventTID

%function SLibResetOrResetWithInitEventTID(tid) void
  %return TYPE(tid) == "Number" && tid >= 0 && ...
    ISFIELD(::CompiledModel.SampleTime[tid], "EventSourceType") && ...
    (::CompiledModel.SampleTime[tid].EventSourceType == "ResetEvent" || ...
     ::CompiledModel.SampleTime[tid].EventSourceType == "ResetWithInitEvent")
%endfunction %% SLibResetOrResetWithInitEventTID

%function SLibInitResetTermEventTID(tid) void
  %return TYPE(tid) == "Number" && tid >= 0 && ...
    ISFIELD(::CompiledModel.SampleTime[tid], "EventSourceType") && ...
    (::CompiledModel.SampleTime[tid].EventSourceType == "PowerUpEvent" || ...
     ::CompiledModel.SampleTime[tid].EventSourceType == "PowerDownEvent" || ...
     ::CompiledModel.SampleTime[tid].EventSourceType == "ResetEvent" || ...
     ::CompiledModel.SampleTime[tid].EventSourceType == "ResetWithInitEvent")
%endfunction %% SLibInitResetTermEventTID

%function SLibParameterChangeEventTID(tid) void
  %return TYPE(tid) == "Number" && tid >= 0 && ...
  ISFIELD(::CompiledModel.SampleTime[tid], "EventSourceType") && ...
    ::CompiledModel.SampleTime[tid].EventSourceType =="ParameterChangeEvent"
%endfunction %% SLibParameterChangeEventTID

%function SLibTidOfParameterChangeEvent() void
  %foreach tid = NumSampleTimes
    %if SLibParameterChangeEventTID(tid)
      %return tid
    %endif
  %endforeach
  %return -1
%endfunction %% SLibTidOfParameterChangeEvent

%% This function is used to check if the model parameterizes discrete rates.
%function SLibModelParameterizeDiscreteRates() void
  %return ISFIELD(::CompiledModel,"ParameterizeDiscreteRates") && ...
    ::CompiledModel.ParameterizeDiscreteRates == "yes"
%endfunction %% SLibModelParameterizeDiscreteRates

%function SLibGetFundamentalStepSize() void
  %if SLibModelParameterizeDiscreteRates()
    %return 1
  %else
    %return ::CompiledModel.FundamentalStepSize
  %endif
%endfunction 

%function FcnModelTaskToFirstTID(includeAsync) void
  %assign v = []
  %assign firstPeriodic = TLC_TRUE
  %foreach tid = NumSampleTimes
    %if SLibSynchronousTID(tid)
      %if ISEQUAL(SolverType, "FixedStep") && FixedStepOpts.TID01EQ && ...
        !ISEMPTY(v) && v[0] == 0 && tid == 1 && !IsModelReferenceTarget()
        %continue
      %endif
      
      %% UnionSampleTime doesn't have ModelEntryPoint.
      %if ::CompiledModel.SampleTime[tid].IsUnionTs == "yes"
        %continue
      %endif

      %% ExplicitTasking rate entry function is called
      %% explicitly by it caller.
      %if ::CompiledModel.SampleTime[tid].ExplicitTasking == "yes" 
        %if SLibIsExplicitPartitioningTID(tid)
          %assign v = v + tid
        %elseif SLibIsExportFcnDiagram()
          %if !LibIsModelReferenceTarget()
            %assign v = v + tid
          %endif
        %endif
        %continue
      %endif

      %if !SLibIsPeriodicRateGrouping()
        %if firstPeriodic
          %assign v = v + tid
          %assign firstPeriodic = TLC_FALSE
        %endif
      %else
        %assign v = v + tid
      %endif
    %elseif SLibNonInlinedModelWideEventTID(tid)
      %assign v = v + tid
    %elseif includeAsync
      %assign v = v + tid
    %endif
  %endforeach
  %return v
%endfunction

%function SLibModelEntryPointTid(idx, returnEmptyStringForNonRateGrouping) void
  %assign tidsWithEntryPoints = FcnModelTaskToFirstTID(TLC_FALSE)
  %assert (idx >= 0) && (idx < SIZE(tidsWithEntryPoints, 1))
  %assign tid = tidsWithEntryPoints[idx]
  %if returnEmptyStringForNonRateGrouping && ...
    SLibSynchronousTID(tid) && !SLibIsPeriodicRateGrouping()
    %return ""
  %else
    %return tid
  %endif
%endfunction

%function SLibNumTidsWithModelEntryPoints() void
  %assign tidsWithEntryPoints = FcnModelTaskToFirstTID(TLC_FALSE)
  %return SIZE(tidsWithEntryPoints, 1)
%endfunction


%% DocFunction{Sample Time Functions}: LibGetNumSFcnSampleTimes ================
%% Abstract:
%%   Returns the number of S-function sample times for a block.
%%
%function LibGetNumSFcnSampleTimes(block) void

  %%   See also:
  %%     LibIsSFcnSingleRate
  %%     LibGetGlobalTIDFromLocalSFcnTID
  %%     LibIsSFcnSampleHit
  %%     LibIsSFcnSpecialSampleHit
  %%     LibGetSFcnTIDType
  %%

  %return SIZE(TID,1)

%endfunction %% LibGetNumSFcnSampleTimes


%% DocFunction{Sample Time Functions}: LibIsSFcnSingleRate  ====================
%% Abstract:
%%   LibIsSFcnSingleRate returns a boolean value (1 or 0) indicating
%%   whether the S-function is single rate (one sample time) or multirate
%%   (multiple sample times).
%%
%function LibIsSFcnSingleRate(block) void

  %% See also:
  %%     LibIsRateTransitionBlock   (must be single rate block)
  %%     LibGetNumSFcnSampleTimes
  %%     LibGetGlobalTIDFromLocalSFcnTID
  %%     LibIsSFcnSampleHit
  %%     LibIsSFcnSpecialSampleHit
  %%     LibGetSFcnTIDType
  %%

  %return SIZE(TID,1) == 1

%endfunction %% LibIsSFcnSingleRate


%% DocFunction{Sample Time Functions}: LibGetGlobalTIDFromLocalSFcnTID =========
%% Abstract:
%%   Returns the model task identifier (sample time index) corresponding to the
%%   specified local S-function task identifier or port sample time.
%%   This function allows you to use one function to determine a global
%%   TID, independent of port- or block-based sample times.
%%
%%   Calling this function with an integer argument is equivalent to the
%%   statement SampleTimesToSet[sfcnTID][1]. SampleTimesToSet is a matrix
%%   that maps local S-function TIDs to global TIDs.
%%
%%   The input argument to this function should be either:
%%
%%      sfcnTID: integer (e.g. 2)
%%               For block-based sample times (e.g. in S-function
%%               mdlInitializeSizes, ssSetNumSampleTimes(S,N) with N > 1 was
%%               specified), sfcnTID is an integer corresponding local
%%               S-function sample time.
%%         or
%%
%%      sfcnTID: string of the form "InputPortIdxI", "OutputPortIdxI" where I
%%               is a number ranging from 0 to the number of ports (e.g.,
%%               "InputPortIdx0", "OutputPortIdx7").  For port-based sample
%%               times (e.g. in S-function mdlInitializeSizes,
%%               ssSetNumSampleTimes(S,PORT_BASED_SAMPLE_TIMES) was specified),
%%               sfcnTID is a string giving the input (or output) port index.
%%
%%   Examples:
%%   1) Multirate block:
%%      %assign globalTID = LibGetGlobalTIDFromLocalSFcnTID(2)
%%        or
%%      %assign globalTID = LibGetGlobalTIDFromLocalSFcnTID("InputPortIdx4")
%%
%%      %assign period  = ::CompiledModel.SampleTime[globalTID].PeriodAndOffset[0]
%%      %assign offset  = ::CompiledModel.SampleTime[globalTID].PeriodAndOffset[1]
%%
%%   2) Inherited sample time block:
%%      %switch (LibGetSFcnTIDType(0))
%%        %case "discrete"
%%        %case "continuous"
%%           %assign globalTID = LibGetGlobalTIDFromLocalSFcnTID(2)
%%           %assign period  = ...
%%             ::CompiledModel.SampleTime[globalTID].PeriodAndOffset[0]
%%           %assign offset  = ...
%%             ::CompiledModel.SampleTime[globalTID].PeriodAndOffset[1]
%%           %breaksw
%%        %case "triggered"
%%           %assign period = -1
%%           %assign offset = -1
%%           %breaksw
%%        %case "constant"
%%           %assign period = rtInf
%%           %assign offset = 0
%%           %breaksw
%%        %default
%%           %<LibBlockReportFatalError([],"Unknown tid type")>
%%      %endswitch
%%
%function LibGetGlobalTIDFromLocalSFcnTID(sfcnTID) void

  %% See also:
  %%   LibGetNumSFcnSampleTimes
  %%   LibIsSFcnSingleRate
  %%   LibIsSFcnSampleHit
  %%   LibIsSFcnSpecialSampleHit
  %%   LibGetSFcnTIDType
  %%
  %if TYPE(TID) == "String"
    %<LibReportFatalError("Invalid sample time (%<TID>)")>
  %endif

  %with ParamSettings

    %if TYPE(sfcnTID) == "String"
      %if PortBasedSampleTimes != "yes"
        %<LibReportFatalError("Incorrect sfcnTID argument")>
      %endif
      %return LibBlockPortSampleTime(sfcnTID)
    %elseif TYPE(sfcnTID) == "Number"
      %%
      %% SampleTimesToSet:
      %%   First column  = local TID (always the vector [0,1,...])
      %%   Second column = global TID
      %%
      %if PortBasedSampleTimes != "no"
        %<LibReportFatalError("Incorrect sfcnTID argument")>
      %endif

      %if !EXISTS("SampleTimesToSet")
        %<LibReportFatalError("S-function sample time translation table " ...
          "not found")>
      %endif

      %if sfcnTID < 0 || sfcnTID >= SIZE(SampleTimesToSet,0)
        %<LibReportFatalError("Invalid sample time index")>
      %endif
      %return SampleTimesToSet[sfcnTID][1]
    %endif

  %endwith

  %<LibReportFatalError("Invalid argument")>

%endfunction %% LibGetGlobalTIDFromLocalSFcnTID



%% DocFunction{Sample Time Functions}: LibIsSFcnSampleHit ======================
%% Abstract:
%%   Returns 1 if a sample hit occurs for the specified local S-function task
%%   identifier (TID), 0 otherwise.
%%
%%   The input argument to this function should be either:
%%
%%      sfcnTID: integer (e.g. 2)
%%               For block-based sample times (e.g. in S-function
%%               mdlInitializeSizes, ssSetNumSampleTimes(S,N)
%%               with N > 1 was specified), sfcnTID is an integer starting at
%%               0 of the corresponding local S-function sample time.
%%         or
%%
%%      sfcnTID: "InputPortIdxI", "OutputPortIdxI" (e.g. "InputPortIdx0",
%%               "OutputPortIdx7") For port based sample times (e.g. in
%%               S-function mdlInitializeSizes,
%%               ssSetNumSampleTimes(S,PORT_BASED_SAMPLE_TIMES) was specified),
%%               sfcnTID is a string giving the input (or output) port index.
%%
%%   Examples:
%%   1) Consider a multirate S-function block with 4 block sample times.
%%      The call LibIsSFcnSampleHit(2) will return the code to check
%%      for a sample hit on the 3rd S-function block sample time.
%%
%%   2) Consider a multirate S-function block with 3 input and 8 output
%%      sample times. The call LibIsSFcnSampleHit("InputPortIdx0") returns the
%%      code to check for a sample hit on the first input port. The call
%%      LibIsSFcnSampleHit("OutputPortIdx7") returns the code to check for
%%      a sample hit on the eight output port.
%%
%function LibIsSFcnSampleHit(sfcnTID) void

  %% See also:
  %%   LibGetNumSFcnSampleTimes
  %%   LibIsSFcnSingleRate
  %%   LibGetGlobalTIDFromLocalSFcnTID
  %%   LibIsSFcnSpecialSampleHit
  %%   LibGetSFcnTIDType
  %%   LibIsSampleHit
  %%   LibIsSpecialSampleHit
  %%

  %if Type != "S-Function"
    %<LibReportFatalError("Called with non-S-Function block")>
  %endif
  %if  ((SIZE(TID,1) == 1) && (PortBasedSampleTimes != "yes"))
    %<LibReportFatalError("Called non-multirate S-function block")>
  %endif
  
  %assign tid = LibGetGlobalTIDFromLocalSFcnTID(sfcnTID)
    %return LibIsSampleHit(tid)
%endfunction %% LibIsSFcnSampleHit



%% DocFunction{Sample Time Functions}: LibIsSFcnSpecialSampleHit ===============
%% Abstract:
%%   Returns the Simulink macro to promote a slow task (sfcnSTI) into a faster
%%   task (sfcnTID).
%%
%%   This advanced function is specifically intended for use in rate transition
%%   blocks. This function determines the global TID from the S-function TID
%%   and calls LibIsSpecialSampleHit using the global TIDs for both the sample
%%   time index (sti) and the task id (tid).
%%
%%   The input arguments to this function are:
%%
%%   o) For multirate S-function blocks:
%%      sfcnSTI: local S-function sample time index (sti) of the slow task that
%%               is to be promoted
%%      sfcnTID: local S-function task Id (tid) of the fast task where the slow
%%               task will be run.
%%
%%   o) For single rate S-function blocks using SS_OPTION_RATE_TRANSITION,
%%      the sfcnSTI and sfcnTID are ignored and should be specified as "".
%%
%%   The format of sfcnSTI and sfcnTID must follow that of the argument
%%   to LibIsSFcnSampleHit
%%
%%   Examples:
%%     1) A rate transition S-function (one sample time with
%%        SS_OPTION_RATE_TRANSITION):
%%
%%        if (%<LibIsSFcnSpecialSampleHit("","")>) {
%%
%%     2) A multi-rate S-function with port-based sample times where the
%%        output rate is slower than the input rate (e.g. a zero-order
%%        hold operation):
%%
%%        if (%<LibIsSFcnSpecialSampleHit("OutputPortIdx0","InputPortIdx0")>) {
%%
%function LibIsSFcnSpecialSampleHit(sfcnSTI, sfcnTID)

  %% See also:
  %%   LibGetNumSFcnSampleTimes
  %%   LibIsSFcnSingleRate
  %%   LibGetGlobalTIDFromLocalSFcnTID
  %%   LibIsSFcnSampleHit
  %%   LibGetSFcnTIDType
  %%   LibIsSampleHit
  %%   LibIsSpecialSampleHit
  %%

  %if SIZE(TID,1) == 1
    %if !EXISTS("SampleTimeIdx")
      %<LibReportFatalError("Called with non-multirate S-function block")>
    %endif
    %assign sti = SampleTimeIdx
    %assign tid = TID
  %else
    %assign sti = LibGetGlobalTIDFromLocalSFcnTID(sfcnSTI)
    %assign tid = LibGetGlobalTIDFromLocalSFcnTID(sfcnTID)
  %endif

  %% Run in task tid but at frequency of sti.
  %return LibIsSpecialSampleHit(sti,tid)

%endfunction %% LibIsSFcnSpecialSampleHit



%% DocFunction{Sample Time Functions}: LibGetSFcnTIDType =======================
%% Abstract:
%%   Returns the type of the specified S-Functions task identifier (sfcnTID).
%%
%%     "continuous" if the specified sfcnTID is continuous.
%%     "discrete"   if the specified sfcnTID is discrete.
%%     "triggered"  if the specified sfcnTID is triggered.
%%     "constant"   if the specified sfcnTID is constant
%%     "asynchronous" if the specified sfcnTID is asynchronous
%%
%%   The format of sfcnTID must follow be the same as for LibIsSFcnSampleHit
%%
%%   Note:
%%     This is useful primarily in the context of S-functions that specified an
%%     inherited sample time.
%%
%function LibGetSFcnTIDType(sfcnTID)

  %% See also:
  %%   LibGetNumSFcnSampleTimes
  %%   LibIsSFcnSingleRate
  %%   LibGetGlobalTIDFromLocalSFcnTID
  %%   LibIsSFcnSampleHit
  %%   LibIsSFcnSpecialSampleHit
  %%

  %if SIZE(TID,1) == 1
    %assign tid = TID
  %else
    %assign tid = LibGetGlobalTIDFromLocalSFcnTID(sfcnTID)
  %endif

  %if TYPE(tid) == "Number"
    %if SLibParameterChangeEventTID(tid)
      %return "constant"
    %endif
    
    %assign period = ::CompiledModel.SampleTime[tid].PeriodAndOffset[0]
    %assign offset = ::CompiledModel.SampleTime[tid].PeriodAndOffset[1]
    %if period == 0.0 && offset == 0.0
      %return "continuous"
    %elseif period > 0.0
      %return "discrete"
    %elseif period == -1.0 && offset < -1.0
      %return "asynchronous"
    %endif
  %elseif TYPE(tid) == "String" || TYPE(tid) == "Identifier"
    %return tid
  %endif

%endfunction %% LibGetSFcnTIDType

%% Function: SLibIsNdIndexingFeatureOn ====================================
%% Abstract:
%%   SLibIsNdIndexingFeatureOn true if the ND indexing feature is on.
%%
%function SLibIsNdIndexingFeatureOn() void
  %return CGMODEL_ACCESS("CGModel.IsNdIndexing")
%endfunction %% SLibIsNdIndexingFeatureOn

%% DocFunction{Other Useful Functions}: SLibIsContainerCGTypeND ===========
%% Abstract:
%%   Returns true if the container CG type for the given indexing is ND.
%%
%function SLibIsContainerCGTypeND(rec) void
  %if !ISEMPTY(rec) && ISFIELD(rec, "ContainerCGTypeIdx") && ...
      rec.ContainerCGTypeIdx >= 0 && ...
      LibCGTypeIsMatrix(rec.ContainerCGTypeIdx)
    %assign ctnrTypeIdx = rec.ContainerCGTypeIdx
    %assign recDims = LibCGTypeDimensions(ctnrTypeIdx)
    %if !ISEMPTY(recDims) && SIZE(recDims, 1) > 1
      %return TLC_TRUE
    %endif
  %endif
  %return TLC_FALSE
%endfunction %% SLibIsContainerCGTypeND

%% Function: LibOptionalMatrixDims ========================================
%% Abstract:
%%   LibOptionalMatrixDims returns a string that can be used for
%%   C declarations of 1-D arrays (1-D or 2-D arrays).
%%
%%   This functions returns
%%      ""             if the inputs are 0
%%      "[number]"     if non-zero inputs, where number is nRows*nCols
%%
%function LibOptionalMatrixDims(nRows, nCols) void
  %if nRows == 1 && nCols == 1
    %return ""
  %elseif nCols == 1 && nRows > 1
    %return "[%<nRows>]"
  %elseif nRows == 1 && nCols > 1
    %return "[%<nCols>]"
  %elseif nCols > 1 && nRows > 1
    %if SLibIsNdIndexingFeatureOn()
      %return "[%<nCols>][%<nRows>]"
    %else
    %return "[%<nRows*nCols>]"
    %endif
  %else
    %<LibReportFatalError("Invalid matrix size (%<nRows> x %<nCols>)")>
  %endif
%endfunction %% LibOptionalMatrixDims

%% Function: LibOptionalMatrixWidth ============================================
%% Abstract:
%%   LibOptionalMatrixWidth returns a string that can be used for
%%   C declarations of 1-D arrays (1-D or 2-D arrays).
%%
%%   This functions returns
%%      ""             if the inputs are 0
%%      "[number]"     if non-zero inputs, where number is nRows*nCols
%%
%function LibOptionalMatrixWidth(nRows, nCols) void
  %if nRows == 1 && nCols == 1
    %return ""
  %elseif nCols == 1 && nRows > 1
    %return "[%<nRows>]"
  %elseif nRows == 1 && nCols > 1
    %return "[%<nCols>]"
  %elseif nCols > 1 && nRows > 1
    %return "[%<nRows*nCols>]"
  %else
    %<LibReportFatalError("Invalid matrix size (%<nRows> x %<nCols>)")>
  %endif
%endfunction %% LibOptionalMatrixWidth

%% Function: LibGetDimensionDefString ========================================
%% Abstract:
%%   For the dimensions of the given parameter returns a string that can 
%% be used, for example, for variable definitions in C language.
%%
%%   [d1, d2, ..., dn] -> "[d1][d2]...[dn]"
%%
%function LibGetDimensionDefString(record) void
  %assign width = LibGetDataWidth(record)
  %if width == 1
    %return ""
  %else
    %assign tmpDims = LibGetDataSymbolicDims(record)
    %assign retDims = ""
    %foreach dimIdx = SIZE(tmpDims, 1)
      %assign retDims = retDims + "[%<tmpDims[dimIdx]>]"
    %endforeach
    %return retDims
  %endif
%endfunction %% LibGetDimensionDefString

%% Function: LibOptionalVectorWidth ============================================
%% Abstract:
%%   LibOptionalVectorWidth returns "[length]" if the length of the input
%%   vector is greater than one and returns "" otherwise.
%%
%function LibOptionalVectorWidth(length) void
  %if TYPE(length) == "Number"
    %if length == 1
      %return ""
    %elseif length > 1
      %return "[%<length>]"
    %else
      %<LibReportFatalError("Invalid vector length (%<length>) specified")>
    %endif
  %else
    %assert TYPE(length) == "String"
    %if length == "1"
      %return ""
    %else
      %return "[%<length>]"
    %endif
  %endif
%endfunction %% LibOptionalVectorWidth

%% Function: LibGetAddressOfFirstElement ==================================
%% Abstract:
%%   Returns the address of the first element for the given variable 
%% access, if the number of dimensions is larger than 1. For example:
%%
%% aVarAccessStr = "structVar.oneField"
%% aDims         = [3, 4, 10]
%% Returns       => "(&structVar.oneField[0][0][0])"
%% 
%% In the example above if aDims == "1", [1], or [n] then aVarAccessStr is
%% returned.
%%
%function LibGetAddressOfFirstElement(aVarAccessStr, aDims) void
  %if TYPE(aDims) != "Vector" || SIZE(aDims, 1) < 2
    %return aVarAccessStr
  %else
    %assign retAccess = "(&" + aVarAccessStr
    %foreach dimIdx = SIZE(aDims, 1)
      %assign retAccess = retAccess + "[0]"
    %endforeach
    %assign retAccess = retAccess + ")"
    %return retAccess
  %endif
%endfunction %% LibGetAddressOfFirstElement

%%DocFunction{Other Useful Functions}: LibIsNdIndex ==============================
%% Abstract:
%%   Returns true if the given index string is nD; e.g., [0][0], [x][y][z].
%% Warning, this function can only be applied to a string that is known to
%% contain indexing for variable access.
%%
%function LibIsNdIndex(aIndexStr) void
  %assign aIndexStrSize = SIZE(aIndexStr, 1)

  %if aIndexStrSize < 6
    %% nD indexes have at least 6 characters.
    %return TLC_FALSE
  %endif

  %% An nD index is always bounded by brackets.
  %assert aIndexStr[0] == "["
  %assert aIndexStr[aIndexStrSize - 1] == "]"

  %% And then there must be at least one additional bracket.
  %foreach strIdx = (aIndexStrSize - 2)
    %if aIndexStr[strIdx + 1] == "]"
      %return TLC_TRUE
    %endif
  %endforeach
  %return TLC_FALSE
%endfunction %% LibIsNdIndex

%% Function: LibBlockSetIsExpressionCompliant ==================================
%% Abstract:
%%   Specify that this block's TLC file is compliant with expression folding.
%%   To be called in BlockInstanceSetup function.
%%
%function LibBlockSetIsExpressionCompliant(block) void
  %<SETFIELD(block,"TLCExprCompliant", 1)>
%endfunction


%% Function: LibBlockSetIntegerDowncastUnnecessary ==================================
%% Abstract:
%%   Specify that this block does not need to enforce integer downcasts for its
%%   output expression
%%
%function LibBlockSetIntegerDowncastUnnecessary(block) void
  %<SETFIELD(block,"EnforceIntegerDowncast", 0)>
%endfunction


%% Function: LibBlockInputSignalAllowScalarExpandedExpr ========================
%% Abstract:
%%   Always allow the input signal to be an expression, even when any of the
%%   output signals are wide.  To be called in BlockInstanceSetup function.
%%
%function LibBlockInputSignalAllowScalarExpandedExpr(block,ipIdx) void
  %<SETFIELD(block.DataInputPort[ipIdx],"AllowScalarExpandedExpr",1)>
%endfunction


%% Function: SLibGet1DArrayIndexer =============================================
%% Abstract:
%%      If the variable (e.g. rtB.idname) is non-scalar 1-D vector, this
%%      function returns
%%            C: "[index_expression]" or
%%          Ada: "(index_expression)"
%%      otherwise this function returns
%%             ""
%%      for the scalar case (when width == 1)
%%
%%      The arguments determine how to index a variable depending on whether it
%%      is a scalar or a vector and whether or not it is in a rolled loop.
%%
%% Arguments:
%%      width - width of variable.
%%      ucv   - user control index variable
%%      lcv   - loop control index variable (when rolling)
%%      offset - offset into the source vector
%%
%% Returns:
%%      ""                 If signal is scalar (width is one)
%%      "[ucv+offset]"     If ucv specified (i.e. ucv not equal to "")
%%      "[lcv]"            If lcv specified (i.e. lcv not equal to "",
%%                         ucv equal to "").
%%      "[offset]"         otherwise (ucv equal to "" and lcv equal to "")
%%
%function SLibGet1DArrayIndexer(width, ucv, lcv, offset) void
  %return SLibGet1DStructFieldIndexer(width, "", ucv, lcv, offset)
%endfunction %% SLibGet1DArrayIndexer

%function SLibGetStructFieldIndexExpr(memberStr, ucv, lcv, offset) void
  %if ucv != ""
    %assign offsetStr = ""
    %if TYPE(offset) == "Number"
      %if offset > 0
        %assign offsetStr = "+%<offset>"
      %endif
    %endif
    %return memberStr + "[" + ucv + offsetStr + "]"
  %elseif lcv != ""
    %return memberStr + "[" + lcv + "]"
  %else
    %if TYPE(offset) == "String" && ISEMPTY(offset)
      %return memberStr
    %else
      %% Handle the case of idx being an integer literal or string
      %return memberStr + "[%<offset>]"
    %endif
  %endif
%endfunction %% SLibGetStructFieldIndexExpr

%% Function: SLibGet1DStructFieldIndexer ========================================
%% Abstract:
%%      If the variable (e.g. rtB.idname) is non-scalar 1-D vector, this
%%      function returns
%%            C: "memberStr[index_expression]" or
%%             ""
%%      for the scalar case (when width == 1)
%%
%%      The arguments determine how to index a variable depending on whether it
%%      is a scalar or a vector and whether or not it is in a rolled loop.
%%
%% Arguments:
%%      width     - width of variable.
%%      memberStr - additional strucutre member string
%%      ucv       - user control index variable
%%      lcv       - loop control index variable (when rolling)
%%      offset    - offset into the source vector
%%
%function SLibGet1DStructFieldIndexer(width, memberStr, ucv, lcv, offset) void
  %% scalar case
  %if TYPE(width) == "Number"
    %if width == 1
      %return memberStr
    %endif
    %% vector case
    %return SLibGetStructFieldIndexExpr(memberStr, ucv, lcv, offset)
  %else
    %assert TYPE(width) == "String"
    %if width == "1"
      %return memberStr
    %endif
    %return SLibGetStructFieldIndexExpr(memberStr, ucv, lcv, offset)
  %endif
%endfunction %% SLibGet1DStructFieldIndexer

%% Function: SLibGet2DArrayIndexer =============================================
%% Abstract:
%%   Generate the index string for accessing elements of a
%%   2-D Simulink Coder array.
%%
%%   Note: use LibOptionalMatrixDims to generate
%%         index string for declarations.
%%
%%   Matrices (2-D arrays) are saved within a vector in column-major format.
%%   If the accessed vector (e.g. rtB.idname) is non-scalar, this
%%   function returns
%%          C: "[index_expression]" or
%%        Ada: "(index_expression)"
%%   otherwise this function returns
%%        ""
%%   for the scalar case (when width == nRows*nCols == 1)
%%
%%   The general case for column order indexing is:
%%       [rowIdx + nRows * colIdx]
%%
%%   This function goes further by allowing for the abstraction of
%%   user and loop control variables analogous to SLibGet1DArrayIndexer.
%%
%%   The indexer string consists of a preceding delimiter, the row index
%%   summed with the product of the column index and the number of rows
%%   in the matrix, following by a close delimiter.  For row or column
%%   vectors, the result is the minimum amount of information necessary
%%   to correctly access the matrix.
%%
%%   Note: commonhdrlib.tlc collapses degenerate arrays into the minimum
%%         declaration, i.e., 1x1 => scalar and Nx1 or 1xN => N.  This function
%%         generates an indexer with this knowledge.
%%
%%   Arguments:
%%        offset: Offset to the base of the vector (generally 0).
%%        nRows:  Number of rows in matrix
%%        rucv:   User control variable string for row
%%        rlcv:   Loop control variable string for row
%%        ridx:   Row index (must be an integer)
%%        nCols:  Number of columns in matrix
%%        cucv:   User control variable string for columns
%%        clcv:   Loop control variable string for columns
%%        cidx:   Column index (must be an integer)
%%
%%   Returns:
%%      1) "" if signal is scalar (nRows*nCols equals one).
%%      2) "[offset + rowIdx + nRows * colIdx]" if signal is a matrix
%%           where rowIdx =
%%             rucv   if rcuv != ""
%%             rlcv   if rucv == "" and rlcv != ""
%%             ridx   if rucv == "" and rlcv == ""
%%           where colIdx =
%%             cucv   if ccuv != ""
%%             clcv   if cucv == "" and clcv != ""
%%             cidx   if cucv == "" and clcv == ""
%%
%function SLibGet2DArrayIndexer(offset, nRows, rucv, rlcv, ridx, ...
  nCols, cucv, clcv, cidx) void
  %return SLibGet2dArrayIndexer(offset, nRows, rucv, rlcv, ridx, ...
                                nCols, cucv, clcv, cidx, TLC_TRUE)
%endfunction %% SLibGet2DArrayIndexer

%% Function: SLibGet2dArrayIndexer ========================================
%% Abstract:
%%   Same as SLibGet2DArrayIndexer, with the addition of the flatIndex
%% argument. When this argument is true, a flat index is returned; e.g.,
%% [offset + col+Ncols*row]. If flatIndex is false, then 2-D index is
%% returned; e.g., [row][col]. Note that non-zero offset is not allowed
%% when flatIndex is false.
%function SLibGet2dArrayIndexer(offset, nRows, rucv, rlcv, ridx, ...
  nCols, cucv, clcv, cidx, flatIndex) void
  %if !flatIndex
    %assert offset == 0
  %endif

  %if rlcv != "" || clcv != ""
    %assign ::ShowErrorStackTrace = TLC_TRUE
    %<SLibReportErrorWithId("RTW:tlc:SLibGet2DArrayIndexerUsage")>
  %endif

  %if nRows*nCols == 1
    %return ""
  %elseif nRows > 1 && nCols > 1
    %%
    %% actual 2-D matrix case:
    %%   first, generate the row index
    %%
    %assign rowIdxIsConst = 0
    %assign colIdxIsConst = 0

    %if rucv != ""
      %assign rowIdx = rucv
    %elseif rlcv != ""
      %assign rowIdx = rlcv
    %else
      %if ridx > 0
        %assign rowIdx = "%<ridx>"
        %assign rowIdxIsConst = 1  %% possible optimization exists
      %else
        %assign rowIdx = ""
      %endif
    %endif

    %%
    %% now generate the column index
    %%
    %if flatIndex
      %if cucv != ""
          %assign colIdx = "%<nRows>*%<cucv>"
      %elseif clcv != ""
        %assign colIdx = "%<nRows>*%<clcv>"
      %else
        %if cidx > 0
          %assign colIdx = "%<nRows*cidx>"
          %assign colIdxIsConst = 1  %% possible optimization exists
        %else
          %assign colIdx = ""
        %endif
      %endif
    %else
      %if cucv != ""
          %assign colIdx = cucv
      %elseif clcv != ""
        %assign colIdx = clcv
      %else
        %if cidx > 0
          %assign colIdx = "%<cidx>"
          %assign colIdxIsConst = 1  %% possible optimization exists
        %else
          %assign colIdx = ""
        %endif
      %endif
    %endif

    %if !flatIndex
      %if rowIdx == ""
        %assign rowIdx = "0"
      %endif
      %if colIdx == ""
        %assign colIdx = "0"
      %endif
    %endif

    %%
    %% put row and column index calculation text together
    %%
    %if rowIdx != "" && colIdx != ""
      %if flatIndex
        %if rowIdxIsConst == 1 && colIdxIsConst == 1
          %assign returnVal = ridx+nRows*cidx  %% avoid expression
        %else
          %assign returnVal = "%<rowIdx> + %<colIdx>"
        %endif
      %else
        %return "[%<ridx>][%<colIdx>]"
      %endif
    %elseif rowIdx != ""
      %assign returnVal = rowIdx
    %elseif colIdx != ""
      %assign returnVal = colIdx
    %else
      %assign returnVal = "0" %% need to access first element
    %endif
  %else
    %if nRows > 1
      %assign ucv = rucv
      %assign lcv = rlcv
      %assign idx = ridx
    %else %% nCols > 1
      %assign ucv = cucv
      %assign lcv = clcv
      %assign idx = cidx
    %endif
    %if ucv != ""
      %assign returnVal = ucv
    %elseif lcv != ""
      %assign returnVal = lcv
    %else
      %assign returnVal = idx
    %endif
  %endif

  %%
  %% Add array offset
  %%
  %if offset != 0
    %if TYPE(returnVal) == "Number"
      %assign returnVal = offset + returnVal
    %else
      %assign returnVal = "%<offset>+%<returnVal>"
    %endif
  %endif
  %assign returnVal = "[%<returnVal>]"

  %return returnVal

%endfunction %% end SLibGet2dArrayIndexer



%% Function: LibComputeNumBlocks ===============================================
%% Abstract:
%%   LibComputeNumBlocks computes the number of nonvirtual blocks in the
%%   entire model.
%%
%function LibComputeNumBlocks() void
  %assign numBlocks = 0
  %foreach sysIdx = NumSystems
    %assign numBlocks = numBlocks + ::CompiledModel.System[sysIdx].NumBlocks
  %endforeach
  %return numBlocks
%endfunction %% LibComputeNumBlocks


%%adzc

%% Function: SLibGetZCAttributes =============================================
%% Abstract:
%%   Convert Simulink Coder zero crossing direction to a SimStruct
%%   representation.
%%
%%   Returns: zcAttribute vector
%%
%function SLibGetZCAttributes(isDisc, needEvent, zcDir) void
  %if (needEvent ==0) && (isDisc ==0)
    %return "(" + zcDir + ")"
  %endif
  %if (needEvent ==0) && (isDisc ==1)
    %return "(0x40|" + zcDir +")"
  %endif
  %if (needEvent ==1) && (isDisc ==0)
    %return "(0x80|" + zcDir +")"
  %endif
  %if (needEvent ==1) && (isDisc ==1)
    %return "(0xc0|" + zcDir +")"
  %endif
%endfunction %%  SLibGetZCAttribute

%% Function: SLibGetZCEvents =============================================
%% Abstract:
%%   Convert Simulink Coder zero crossing direction to a SimStruct
%%   representation.
%%
%%   Returns: zcEvent vector
%%
%function SLibGetZCEvents(needsSolverReset, reserved, zcDir) void
  %if (reserved ==0) && (needsSolverReset ==0)
    %return "(" + zcDir + ")"
  %endif
  %if (reserved ==0) && (needsSolverReset ==1)
    %return "(0x40|" + zcDir +")"
  %endif
  %if (reserved ==1) && (needsSolverReset ==0)
    %return "(0x80|" + zcDir +")"
  %endif
  %if (reserved ==1) && (needsSolverReset ==1)
    %return "(0xc0|" + zcDir +")"
  %endif
%endfunction %%  SLibGetZCEvents

%%adzc

%% Function: LibConvertZCDirection =============================================
%% Abstract:
%%   Convert Simulink Coder zero crossing direction to a SimStruct
%%   representation.
%%
%%   Returns:
%%        "RISING_ZERO_CROSSING"  if direction is "Rising"
%%        "ANY_ZERO_CROSSING"     if direction is "Any"
%%        "FALLING_ZERO_CROSSING" if direction is "Falling"
%%
%function LibConvertZCDirection(direction) void
  %switch direction
    %case "Falling"
    %case "ZC_EVENT_P2N"
    %case "ZC_EVENT_P2Z"
    %case "ZC_EVENT_Z2N"
    %case "ZC_EVENT_ALL_DN"
      %return "FALLING_ZERO_CROSSING"
      %%break
    %case "Any"
    %case "ALL"
      %return "ANY_ZERO_CROSSING"
      %%break
    %case "Rising"
    %case "ZC_EVENT_N2P"
    %case "ZC_EVENT_N2Z"
    %case "ZC_EVENT_Z2P"
    %case "ZC_EVENT_ALL_UP"
      %return "RISING_ZERO_CROSSING"
      %%break
    %default
      %<LibReportFatalError("Invalid zc direction (%<direction>)")>
  %endswitch
%endfunction %%  LibConvertZCDirection


%% Function: LibBaseAddrOfVariable =============================================
%% Abstract:
%%   Determine the base address of a C variable (prefix with &).
%%
%function LibBaseAddrOfVariable(variable, nrows, ncols) void
  %if nrows < 1 || ncols < 1
    %<LibReportFatalError("Invalid size (%<nrows> by %<ncols>)")>
  %elseif nrows == 1 && ncols == 1      /% scalar %/
    %return "&%<variable>"
  %elseif nrows > 1 && ncols == 1       /% vector %/
    %return "&%<variable>[0]"
  %elseif nrows > 1 && ncols > 1        /% matrix %/
    %return "&%<variable>[0]"
  %endif
%endfunction %% LibBaseAddrOfVariable

%% Function: SLibSafeIDNUM ====================================================
%% Abstract:
%%   Returns safe id and number for strings and arrays.
%%
%function SLibSafeIDNUM(aIdNumArray, aIdx) void
  %if "String" == TYPE(aIdNumArray)
    %assert 0 == aIdx
    %return IDNUM(aIdNumArray)
  %else
    %assert "Vector" == TYPE(aIdNumArray)
    %return IDNUM(aIdNumArray[aIdx])
  %endif
%endfunction

%% SLibGrBlock =============================================================
%% Abstract:
%%   SLibGrBlock returns the Simulink block for a given
%%   BlockHierarchyMap block index.
%%
%function SLibGrBlock(grBlockIndex) void
  %if grBlockIndex[1] != -1
    %with ::CompiledModel.BlockHierarchyMap
      %if Subsystem[grBlockIndex[0]].MaskType == "Stateflow"
        %assign grBlock = Subsystem[grBlockIndex[0]]
      %else
        %assign grBlock = Subsystem[grBlockIndex[0]].Block[grBlockIndex[1]]
      %endif
    %endwith
    %return grBlock
  %else
    %return ""
  %endif
%endfunction %% SLibGrBlock

%% SLibGrBlockName =============================================================
%% Abstract:
%%   SLibGrBlockName return the Simulink block name for a given
%%   BlockHierarchyMap block index.
%%
%function SLibGrBlockName(grBlockIndex) void
  %if grBlockIndex[1] != -1
    %assign grBlock = SLibGrBlock(grBlockIndex)
    %return grBlock.Name
  %else
    %return "synthesized block"
  %endif
%endfunction %% SLibGrBlockName

%% SLibGrBlockSIDComment ======================================================
%% Abstract:
%%   SLibGrBlockName returns a string with block name and 
%%   a compact SID without model name for the input graphical 
%%   block record
%function SLibGrBlockSIDComment(grBlock) void
  %if ISFIELD(grBlock, "RLSCommentName")
    %return grBlock.RLSCommentName
  %else
    %return grBlock.Name
  %endif
%endfunction

%% SLibGrBlockSIDCommentByIdx ======================================================
%% Abstract:
%%   SLibGrBlockName returns a string with block name and 
%%   a compact SID without model name for the input graphical 
%%   block index
%function SLibGrBlockSIDCommentByIdx(grBlockIndex) void
  %if grBlockIndex[1] != -1
    %assign grBlock = SLibGrBlock(grBlockIndex)
    %return SLibGrBlockSIDComment(grBlock)
  %else
    %return "synthesized block"
  %endif
%endfunction 

%% SLibGrBlockCommentName ======================================================
%% Abstract:
%%   SLibGrBlockName return the Simulink block name for a given
%%   BlockHierarchyMap block index, or the RLS comment name if
%%   the block resides in a reusable library subsystem.
%%
%function SLibGrBlockCommentName(grBlockIndex) void
  %if grBlockIndex[1] != -1
    %assign grBlock = SLibGrBlock(grBlockIndex)
    %if ISFIELD(grBlock, "RLSCommentName")
      %return grBlock.RLSCommentName
    %else
      %if BlockCommentType == "BlockPathComment"
        %return "'" + grBlock.Name + "'"
      %else
        %return grBlock.Name
      %endif
    %endif
  %else
    %return "synthesized block"
  %endif
%endfunction %% SLibGrBlockName


%% SLibGrBlockPath =============================================================
%% Abstract:
%%   SLibGrBlockPath return the full Simulink block path for a given
%%   BlockHierarchyMap block index.
%%
%function SLibGrBlockPath(grBlockIndex) void
  %if grBlockIndex[1] != -1
    %with ::CompiledModel.BlockHierarchyMap
      %assign grSubSys = Subsystem[grBlockIndex[0]]
      %assign grBlock  = grSubSys.Block[grBlockIndex[1]]
      %if grSubSys.SubsystemBlockIndex[0] == -1 %% root
        %return grSubSys.SLName + "/" + grBlock.SLName
      %elseif grSubSys.MaskType == "Stateflow" && grBlock.SLName == " SFunction "
        %return SLibGrBlockPath(grSubSys.SubsystemBlockIndex)
      %else
        %return SLibGrBlockPath(grSubSys.SubsystemBlockIndex) + ...
          "/" + grBlock.SLName
      %endif
    %endwith
  %else
    %return "synthesized block"
  %endif
%endfunction %% SLibGrBlockPath


%% SLibMangledGrBlockPath ======================================================
%% Abstract:
%%   SLibMangledGrBlockPath return the Simulink block name for a given
%%   BlockHierarchyMap block index.
%%
%function SLibMangledGrBlockPath(grBlockIndex) void
  %if grBlockIndex[1] != -1
    %with ::CompiledModel.BlockHierarchyMap
      %assign grSubSys = Subsystem[grBlockIndex[0]]
      %assign grBlock  = grSubSys.Block[grBlockIndex[1]]
      %if BlockCommentType == "BlockSIDComment"
        %return FEVAL("coder.internal.getMangledBlockFullPath", "%<LibGetModelName()>", grBlock.Name)  
      %else
        %assign sysName  = SYSNAME(grBlock.Name)
        %if grSubSys.SubsystemBlockIndex[0] == -1
          %return grSubSys.SLName + "/" + sysName[1]
        %elseif grSubSys.MaskType == "Stateflow" && sysName[1] == " SFunction "
          %return SLibMangledGrBlockPath(grSubSys.SubsystemBlockIndex)
        %else
          %return SLibMangledGrBlockPath(grSubSys.SubsystemBlockIndex) + ...
            "/" + sysName[1]
        %endif
      %endif
    %endwith
  %else
    %return "synthesized_block"
  %endif
%endfunction %% SLibGrBlockName

%% DocFunction{BlkPathAndErrFcns}: LibGetBlockName =============================
%% Abstract:
%%   LibGetBlockName returns the short block path name string for a block record
%%   excluding carriage returns and other special characters which may be
%%   present in the name.
%%
%function LibGetBlockName(block) void
  %if ISFIELD(block, "GrSrc") && block.GrSrc[1] != -1
    %return SLibGrBlockName(block.GrSrc)
  %else
    %return block.Name
  %endif
%endfunction


%% DocFunction{BlkPathAndErrFcns}: LibGetBlockPath =============================
%% Abstract:
%%   LibGetBlockPath returns the full block path name string for a block record
%%   including carriage returns and other special characters which may be
%%   present in the name.  Currently, the only other special string sequences
%%   defined are '/*' and '*/'.
%%
%%   The full block path name string is useful when accessing blocks from
%%   MATLAB.  For example, the full block name can be used with hilite_system()
%%   via FEVAL to match the Simulink path name exactly.
%%
%%   Use LibGetFormattedBlockPath to get a block path suitable for placing
%%   in a comment or error message.
%%
%function LibGetBlockPath(block) void
  %if ISFIELD(block, "GrSrc") && block.GrSrc[1] != -1
    %return SLibGrBlockPath(block.GrSrc)
  %elseif ISFIELD(block, "SLName")
    %return LibUnmangledPathName(block.SLName)
  %else
    %return LibUnmangledPathName(block.Name)
  %endif
%endfunction


%% DocFunction{BlkPathAndErrFcns}: LibGetFormattedBlockPath ====================
%% Abstract:
%%   LibGetFormattedBlockPath returns the full path name string of a block
%%   without any special characters. The string returned from this function
%%   is suitable for placing the block name, in comments or generated code, on
%%   a single line.
%%
%%   Currently, the special characters are carriage returns, '/*', and '*/'.
%%   A carriage return is converted to a space, '/*' is converted to '/+',
%%   and '*/' is converted to '+/'.  Note that a '/' in  the name is
%%   automatically converted to a '//' to distinguish it from a path separator.
%%
%%   Use LibGetBlockPath to get the block path needed by Matlab functions
%%   used in reference blocks in your model .
%%
%function LibGetFormattedBlockPath(block) void
  %if ISFIELD(block, "GrSrc") && block.GrSrc[1] != -1
    %return SLibMangledGrBlockPath(block.GrSrc)
  %else
    %return LibMangledPathName(block.Name)
  %endif
%endfunction


%% Function: LibUnmangledPathName =============================================
%% Abstract:
%%   This is an internal function that is called by LibGetBlockPath.
%%   You should use LibGetBlockPath if possible.
%%
%%   A block path can contain new-lines and troublesome character sequences
%%   such as /* and */. This function constructs the actual block path when
%%   passed SLName. The function LibMangledPathName transforms the path
%%   (mangles it) such that there are no new lines or troublesome characters.
%%
%function LibUnmangledPathName(name) void
  %if BlockCommentType == "BlockSIDComment"
    %return FEVAL("coder.internal.getBlockFullPath", "%<LibGetModelName()>", name)  
  %endif
  
  %if Accelerator || IsModelReferenceSimTarget()
    %% Accelerator encodes names, return its name.
    %return name
  %endif
  %assign sysName = SYSNAME(name)
  %if sysName[0] == ""
    %return name
  %elseif sysName[0] == "Root"
    %return ::CompiledModel.Name + "/" + sysName[1]
  %else
    %assign idNum = IDNUM(sysName[0])
    %assign subsystemNum = idNum[1] - 1
    %assign ssRef = ::CompiledModel.Subsystem[subsystemNum] 
    %if EXISTS("ssRef.SLName")
      %return LibUnmangledPathName(ssRef.SLName) + "/" + sysName[1]
    %else
      %return LibUnmangledPathName(ssRef.Name) + "/" + sysName[1]
    %endif
  %endif
%endfunction %% LibUnmangledPathName


%% Function: LibMangledPathName ===============================================
%% Abstract:
%%   This is an internal function that is called by LibGetFormattedBlockPath.
%%   You should use LibGetFormattedBlockPath if possible.  Only use this function
%%   if you don't have block record.
%%
%function LibMangledPathName(name) void
  %if BlockCommentType == "BlockSIDComment"
    %return FEVAL("coder.internal.getMangledBlockFullPath", "%<LibGetModelName()>", name)  
  %endif
  %% Can't issue a warning yet ... should be using LibGetFormattedBlockPath.
  %if Accelerator || IsModelReferenceSimTarget()
    %% Accelerator encodes names, return its name.
    %return name
  %endif
  %assign sysName = SYSNAME(name)
  %if sysName[0] == ""
    %return name
  %elseif sysName[0] == "Root"
    %return ::CompiledModel.Name + "/" + sysName[1]
  %else
    %assign idNum = IDNUM(sysName[0])
    %assign subsystemNum = idNum[1] - 1
    %return LibMangledPathName(Subsystem[subsystemNum].Name) + "/" + sysName[1]
  %endif
%endfunction %% LibMangledPathName


%% Function: SLibMangledSubsystemPathName =====================================
%% Abstract:
%%   This is an internal function that is called by commonhdrlib.
%%
%function SLibMangledSubsystemPathName(rootName, name) void
  %if BlockCommentType == "BlockSIDComment"
    %return FEVAL("coder.internal.getMangledBlockFullPath", rootName, name)  
  %endif
  %% Can't issue a warning yet ... should be using LibGetFormattedBlockPath.
  %if Accelerator
    %% Accelerator encodes names, return its name.
    %return name
  %endif
  %assign sysName = SYSNAME(name)
  %if sysName[0] == ""
    %return name
  %elseif sysName[0] == "Root"
    %return rootName + "/" + sysName[1]
  %else
    %assign idNum = IDNUM(sysName[0])
    %assign subsystemNum = idNum[1] - 1
    %return SLibMangledSubsystemPathName(rootName,...
                        Subsystem[subsystemNum].Name) + "/" + sysName[1]
  %endif
%endfunction %% SLibMangledSubsystemPathName

%function SLibAddTrace(prop, value) void
  %if prop != "BlockName"
    %return CGMODEL_ACCESS("CGModel.addCustomTraceInfo", prop, value)
  %else
    %return ""
  %endif
%endfunction

%function SLibAddTrace2(prop1, value1, prop2, value2) void
  %if prop1 == "BlockName"
    %return CGMODEL_ACCESS("CGModel.addCustomTraceInfo", prop2, value2)
  %elseif prop2 == "BlockName"
    %return CGMODEL_ACCESS("CGModel.addCustomTraceInfo", prop1, value1)
  %else
    %return CGMODEL_ACCESS("CGModel.addCustomTraceInfo2", prop1, value1, prop2, value2)
  %endif
%endfunction

%function SLibTraceBegin(traceMarker) void
  %if !ISEMPTY(traceMarker)
    %return traceMarker
  %endif
%endfunction

%function SLibTraceEnd(traceMarker) void
  %if !ISEMPTY(traceMarker)
    %return "/*@]*/"
  %endif
%endfunction

%% Function: LibBlockSFunctionFileExists =======================================
%% Abstract:
%%   LibBlockSFunctionFileExists determines if the TLC file for an
%%   S-function exists.  Because FILE_EXISTS can be very slow especially
%%   over a network, the existence of the file is cached in a global variable.
%%   Subsequent calls for the same S-Function will execute much quicker.
%%
%function LibBlockSFunctionFileExists(sfuncName) void
    %%
    %% check cache to see if file existence has already been checked
    %%
    %%
    %if ISFIELD(GblInlinedTLCFileAccessed,sfuncName)
        %assign fileExists = 1
    %elseif FILE_EXISTS(GENERATE_FILENAME(sfuncName))
        %assign fileExists = 1
        %<SETFIELD(GblInlinedTLCFileAccessed,sfuncName,1)>\
    %else
        %assign fileExists = 0
    %endif
    %%
    %return fileExists
    %%
%endfunction %% LibBlockSFunctionFileExists


%% Function: LibBlockFunctionExists ============================================
%% Abstract:
%%   LibBlockFunctionExists determines if a given block function (method)
%%   exists. For S-function blocks, it first checks to see if the
%%   corresponding TLC file exists and then it checks to see if the
%%   function exists.
%%
%function LibBlockFunctionExists(block, fcn) void
  %if block.Type == "S-Function"
    %assign sfuncName = block.ParamSettings.FunctionName
    %%
    %assign fileExists = LibBlockSFunctionFileExists(sfuncName)
    %%
    %if fileExists
      %return GENERATE_TYPE_FUNCTION_EXISTS(block, fcn, sfuncName)
    %else
      %return 0
    %endif
  %else
    %return GENERATE_FUNCTION_EXISTS(block, fcn)
  %endif
%endfunction


%% Function: LibIsValidCVariable ===============================================
%% Abstract:
%%   For a string s, LibIsValidCVariable(s) returns one for alphanumeric
%%   variables starting with [_a-zA-Z] and zero otherwise.
%%
%function LibIsValidCVariable(s) void
  %return FEVAL("iscvar", s)
%endfunction

%% Function: LibSFunctionLevel =================================================
%% Abstract:
%%   Determine the S-function version level {Level1, Level2, RTWLevel2}
%%
%function LibSFunctionLevel() void
  %if EXISTS("ParamSettings.RTWGenerated")
    %return "RTWLevel2"
  %elseif EXISTS("SFcnParamSettings")
    %% For backwards compatibility with R11
    %if EXISTS("SFcnParamSettings.RTWGenerated")
      %return "RTWLevel2"
    %endif
  %elseif ParamSettings.FunctionLevel == 1
    %return "Level1"
  %else
    %return "Level2"
  %endif
%endfunction


%% Function: LibParentMaskBlockName ============================================
%% Abstract:
%%   Returns the name of the parent subsystem (mask) block.
%%
%function LibParentMaskBlockName(block) void
  %if Accelerator
    %% Accelerator encodes names, return its name.
    %return block.Name
  %endif

  %if ISFIELD(block, "GrSrc") && block.GrSrc[0] != -1
    %with ::CompiledModel.BlockHierarchyMap
      %return Subsystem[block.GrSrc[0]].Name
    %endwith
  %endif

  %if EXISTS("block.SLName")
    %assign name = block.SLName
  %else
    %assign name = block.Name
  %endif
  %assign sysName = SYSNAME(name)
  %assert sysName[0] == "Root"
  %return name

%endfunction


%% Function: LibAddToCompiledModel =============================================
%% Abstract:
%%   Adds an identifier name/value pair to the global
%%   ::CompiledModel record.  An error is reported if the identifier already
%%   exists.
%%
%function LibAddToCompiledModel(name, value) void
  %if ISFIELD(::CompiledModel, name)
    %<LibReportFatalError("LibAddToCompiledModel, %<name> already exists")>
  %endif
  %addtorecord ::CompiledModel %<name> value
%endfunction


%% Function: LibAddIdentifier ==================================================
%% Abstract:
%%   Adds an identifier/value pair to a specified scope.
%%
%%   Adding a duplicate identifier (i.e. same name as one that already
%%   exists in rec) with a different value than that in rec will result
%%   in an error.
%%
%%   Adding a duplicate identifier with equal value has no effect.
%%
%function LibAddIdentifier(rec, name, value) void
  %if ISFIELD(rec, name)
    %%
    %% name already exists in rec, therefore, exit if value is
    %% different, otherwise, ignore
    %%
    %if !ISEQUAL(rec.%<name>, value)
      %%
      %% Trying to modify a name (note that if it's the same we'll
      %% just ignore the request)
      %%
      %assign oldValue = rec.%<name>
      %assign warnTxt = "Modifying %<name> from %<oldValue> to %<value>"
      %<LibReportWarning(warnTxt)>
      %openfile errTxt


      Adding %<name> would change the current record value.

      %if EXISTS("Type")
        Current Type: %<Type>
      %endif
      %if EXISTS("Name")
        Current Name: %<Name>
      %endif
      %closefile errTxt
      %<LibReportFatalError(errTxt)>
    %endif
  %else
    %%
    %% adding name is safe
    %%
    %addtorecord rec %<name> value
  %endif
%endfunction


%% Function: LibAddToFile ======================================================
%% Abstract:
%%   Used to create additional source files.
%%   Adds the buffer to the file, if the file is not already "opened", it
%%   will be created and added to.  During code generation, any files created
%%   with this function will be created on disk.
%%   Note: Should also call LibAddToModelSources() or LibCacheIncludes() as
%%   desired to get file into the build process.
%%
%function LibAddToFile(file, buffer) void
  %assign existingFile = 0
  %% scan for existing name
  %foreach idx = ::CompiledModel.NumFiles
    %if ::CompiledModel.Files.Name[idx] == file
      %assign existingFile = 1
      %assign fileIdx = idx
      %break
    %endif
  %endforeach
  %if existingFile
    %% Add buffer to file
    %assign contents    = "::CompiledModel.Files.File[%<fileIdx>]"
    %assign %<contents> = %<contents> + buffer
  %else
    %if ::CompiledModel.NumFiles == 0
      %% Create record to hold all files
      %assign tmpVar = Files { Name []; File [] }
      %assign ::CompiledModel = ::CompiledModel + Files
      %undef Files
      %undef tmpVar
    %endif
    %% Start file and buffer
    %assign ::CompiledModel.Files.Name = ::CompiledModel.Files.Name + file
    %assign ::CompiledModel.Files.File = ::CompiledModel.Files.File + buffer
    %assign ::CompiledModel.NumFiles   = ::CompiledModel.NumFiles   + 1
  %endif
%endfunction


%% Function: SLibCrudeParseSafeExpression ======================================
%%
%function SLibCrudeParseSafeExpression(blockName, in, checkSideEffects) void

  %assign eRetValNeedsParen = 1
  %assign eRetValHasSideEffect = 2
  %assign eRetValMismatchedDelimiters = 4
  %%
  %assert TYPE(in) == "String"
  %%
  %assign retVal = NEEDS_PAREN(in)
  %%
  %if checkSideEffects && (retVal & eRetValHasSideEffect)

    %<LibReportFatalError("Block: %<blockName>.  Expression '%<in>' has a side effect.")>

  %endif
  %%
  %if retVal & eRetValMismatchedDelimiters

    %<LibReportFatalError("Block: %<blockName>.  Expression '%<in>' has a [] or () mismatch.")>

  %endif
  %%
  %if !(retVal & eRetValNeedsParen)
    %%
    %return in
  %else
    %<LibReportWarning("Block: %<blockName>.  Expression '%<in>' does not protect precedence of operators with parentheses.")>
    %return "(%<in>)"
  %endif
  %%
%endfunction %% SLibCrudeParseSafeExpression(in)


%% Function: SLibProcessSafeExpression ======================================
%%
%%   This function converts negative numeric inputs into
%%   precedence immune expressions.
%%
%%   Input
%%       Type must be a string or a non-complex numeric type.
%%
%%   Output
%%       If the input is numeric and its value is negative, then
%%         the output is a string that wraps the input value in
%%         parentheses to make it a "precedence immune expression"
%%       Otherwise
%%         the output is identical to the input.
%%
%function SLibProcessSafeExpression(blockName, in, checkSideEffects) void
  %%
  %switch TYPE(in)
      %%
    %case "String"
      %%
      %assign in = SLibCrudeParseSafeExpression(blockName, in, checkSideEffects)
      %%
      %% Fall Thru is Desired Here
      %%
    %case "Unsigned"
      %%
      %return in
      %%
      %%break
      %%
    %case "Real"
    %case "Number"
    %case "Real32"
      %%
      %if in >= 0
        %%
        %return in
      %else
        %return "(%<in>)"
      %endif
      %%
      %%break
      %%
    %default
      %<LibReportFatalError("Block: %<blockName>.  Input required to be precedence immune expression, but had unsupported type.")>
  %endswitch
  %%
%endfunction %% SLibProcessSafeExpression

%% Function: SLibCreateSafeExpression ======================================
%%
%%   This function attempts to create safe expression that is immune to
%%   operator precedence interaction with the context of this expression
%%
%%   Input
%%       Type must be a string or a non-complex numeric type.
%%
%%   Output
%%       Original expression or parethesis protected expression
%%
%function SLibCreateSafeExpression(in) void
  %return SLibCG_SE(in)
%endfunction %% SLibCreateSafeExpression

%% Function: LibCallEventSystem ================================================
%% Abstract:
%%     This function is used by blocks that post events to call the subsystem
%%     for an event
%%
%function LibCallEventSystem(block, eventIdx) Output
  %assign sysIdx      = block.ModelEventSystemsToCall[eventIdx*2]
  %assign callSiteIdx = block.ModelEventSystemsToCall[eventIdx*2 + 1]
  %if sysIdx >= 0
    %assign ss = ::CompiledModel.System[sysIdx]
    %if !LibSystemFcnIsEmpty(ss, "Output")
      %<LibGenSystemFcnCall(ss, "Output", callSiteIdx)>\
    %endif
  %endif
%endfunction



%% DocFunction{Code Configuration Functions}: LibAddToModelSources =============
%% Abstract:
%%   This function serves two purposes:
%%     1) To notify the Simulink Coder build process that it must
%%        build with the specified source file, and
%%     2) To update the
%%          'SOURCES: file1.c file2.c ...'
%%        comment in the generated code.
%%
%%   For inlined S-functions, LibAddToModelSources is generally called from
%%   BlockTypeSetup. This function adds a file name to the list of sources
%%   needed to build this model. This functions returns 1 if the filename passed
%%   in was a duplicate (i.e. it was already in the sources list) and 0 if it
%%   was not a duplicate.
%%
%%   As an S-function author, we recommend using the SFunctionModules
%%   block parameter instead of this function. See Writing S-functions.
%%
%function LibAddToModelSources(newFile) void
    %assign duplicate = 0
    %% scan for duplicates
    %foreach idx = ::CompiledModel.NumSources
      %if (::CompiledModel.Sources[idx] == "%<newFile>")
        %assign duplicate = 1
        %break
      %endif
    %endforeach
    %if (!duplicate)
      %assign ::CompiledModel.Sources = ::CompiledModel.Sources + "%<newFile>"
      %assign ::CompiledModel.NumSources = ::CompiledModel.NumSources + 1
    %endif
    %return (duplicate)
%endfunction %% LibAddToModelSources

%function LibAddToReusableLibModelSources(newFile) void
    %assign duplicate = 0
    %% scan for duplicates
    %foreach idx = ::CompiledModel.NumReusableLibSources
      %if (::CompiledModel.ReusableLibSources[idx] == "%<newFile>")
        %assign duplicate = 1
        %break
      %endif
    %endforeach
    %if (!duplicate)
      %assign ::CompiledModel.ReusableLibSources = ::CompiledModel.ReusableLibSources + "%<newFile>"
      %assign ::CompiledModel.NumReusableLibSources = ::CompiledModel.NumReusableLibSources + 1
    %endif
    %return (duplicate)
%endfunction %% LibAddToReusableLibModelSources

%% Function: SLibAddToStaticSources =============================================
%% Abstract:
%%    To notify the Simulink Coder build process that it must build with
%% the specified static source file.
%%
%function SLibAddToStaticSources(newFile) void
    %assign duplicate = 0
    %% scan for duplicates
    %foreach idx = ::CompiledModel.NumStaticSources
      %if (::CompiledModel.StaticSources[idx] == "%<newFile>")
        %assign duplicate = 1
        %break
      %endif
    %endforeach
    %if (!duplicate)
      %assign ::CompiledModel.StaticSources = ::CompiledModel.StaticSources + "%<newFile>"
      %assign ::CompiledModel.NumStaticSources = ::CompiledModel.NumStaticSources + 1
    %endif
    %return (duplicate)
%endfunction %% LibAddToModelSources



%% Function: SLibGenSourcesComment =============================================
%% Abstract:
%%   Called by the model-wide TLC code to generate the
%%     '  * SOURCES: file1.c file2.c ...'
%%   comment.
%%
%function SLibGenSourcesComment() void
  %assign sources = "  * SOURCES: "
  %assign srcStr  = ""
  %foreach idx = ::CompiledModel.NumSources
    %assign mdlSrc  = ::CompiledModel.Sources[idx]
    %if (SIZE(srcStr, 1) + SIZE(mdlSrc, 1)) > 70
      %assign sources = sources + "\n  * SOURCES: "
      %assign srcStr  = ""
    %endif
    %assign srcStr = srcStr + "%<mdlSrc>.c "
    %assign sources = sources + "%<mdlSrc>.c "
  %endforeach
  %return(sources)
%endfunction %% SLibGenSourcesComment



%% Function: SLibCreateBuildSourcesTxtFile =====================================
%% Abstract:
%%   Create modelsources.txt, a list of module sources cached by
%%   LibAddToModelSources and SLibAddToStaticSources
%%
%function SLibCreateBuildSourcesTxtFile() void
  %assign sources = ""
  %foreach idx = ::CompiledModel.NumSources
     %assign sources = sources + ::CompiledModel.Sources[idx] + "." + ::LangFileExt + "\n"
  %endforeach
  %foreach  idx = ::CompiledModel.NumStaticSources
     %assign sources = sources + ::CompiledModel.StaticSources[idx] + "\n"
  %endforeach
  %openfile fid = "modelsources.txt"
  %<sources>
  %closefile fid
%endfunction %% SLibCreateBuildSourcesTxtFile

%% Function: SLibComparePriority ====================================
%% Abstract:
%%  Compare priority of tid1 and tid2.
%%  -1: tid1 or tid2 is not assigned a priority,
%%      comparing failed.
%%   0: tid1 has priority as tid2, this only
%%      happens if tid1==tid2.
%%   1: tid1 has higher priority than tid2
%%   2: tid1 has lower priority than tid2
%%
%function SLibComparePriority(tid1, tid2)

  %assert TYPE(tid1) == "Number" && TYPE(tid2) == "Number"

  %if tid1 == -2 || tid2 == -2
    %% either of the tids is constant,
    %return 0
  %endif

  %if tid1 < 0 || tid2 < 0 || ...
    !ISFIELD(::CompiledModel.SampleTime[tid1], "Priority") || ...
    !ISFIELD(::CompiledModel.SampleTime[tid2], "Priority")

    %assign retVal = -1
  %else
    %assign priority1 = ::CompiledModel.SampleTime[tid1].Priority
    %assign priority2 = ::CompiledModel.SampleTime[tid2].Priority

    %if priority1 > priority2
      %assign retVal = ::CompiledModel.PositivePriority == "yes" ? 1 : 2
    %elseif priority1 < priority2
      %assign retVal = ::CompiledModel.PositivePriority == "yes" ? 2 : 1
    %else
      %assign retVal = 0
    %endif
  %endif

  %return retVal
%endfunction %% SLibComparePriority

%% Function: SLibIsAsyncTaskOnlyModel =======================
%%
%%     Return true if the model has only Async task block.
%% Code for async task is empty. In this case don't need register
%% rtOneStep function.
%%
%%    The all the followings must be true if a model is an
%% AsyncTaskOnly model:
%%    1. Model is a single sync rate model.
%%    2. No async task need absolute time, or
%%       Async task that need absolute time manage own
%%       absolute time.
%%    3. Blocks in root subsystem must be
%%         fcn-call subsystem block, or
%%         block is an async top caller, or
%%         blocks output code is white space
%%    4. Not all async tasks are init/term/reset tasks.
%function SLibIsAsyncTaskOnlyModel()
  %assign retVal = TLC_TRUE %% assume

  %if ISFIELD(::CompiledModel, "IsAsyncTaskOnlyModel")
    %return IsAsyncTaskOnlyModel
  %endif

  %assign numIRT = 0
  %if MatFileLogging
    %assign retVal = TLC_FALSE
  %elseif  LibGetNumAsyncTasks() > 0 && ...
    NumRuntimeExportedRates <= 1
    %foreach idx = LibGetNumAsyncTasks()
      %assign tid = idx + NumRuntimeExportedRates      
      
      %if SLibInitResetTermEventTID(tid)
        %assign numIRT = numIRT + 1
        %continue
      %endif
      
      %if SampleTime[tid].NeedAbsoluteTime == "yes" && ...
        SampleTime[tid].TimeSource == "BaseRate"
        %assign retVal = TLC_FALSE
      %endif
    %endforeach
  %else
    %assign retVal = TLC_FALSE
  %endif

  %% Init/Reset/Term are not considered as async here.
  %if LibGetNumAsyncTasks() == numIRT
    %assign retVal = TLC_FALSE
  %endif
  
  %if retVal
    %assign rootSystem = System[NumSystems-1]
    %foreach tid = NumRuntimeExportedRates
      %if !LibSystemFcnIsEmptyHelper(rootSystem,"Output",tid)
         %assign retVal = TLC_FALSE
         %break
      %endif
    %endforeach
  %endif

  %addtorecord ::CompiledModel IsAsyncTaskOnlyModel retVal
  %return retVal
%endfunction

%% Function: BlkHasPeriodicAndAysncTid =======================
%% Abstract:
%%    Return true if block has perodic sample rate and
%% asynchronous sample time.
%%
%function BlkHasPeriodicAndAysncTid(block)
  %assign hasAsyncTid    = TLC_FALSE
  %assign hasPeriodicTid = TLC_FALSE
  %with block
    %if TYPE(block.TID) == "Vector"
      %assign TIDlen = SIZE(TID,1)
      %foreach tidIdx = TIDlen
        %if LibAsynchronousTriggeredTID(TID[tidIdx])
          %assign hasAsyncTid = TLC_TRUE
        %else
          %assign hasPeriodicTid = TLC_TRUE
        %endif
      %endforeach
    %endif
  %endwith
  %return hasAsyncTid && hasPeriodicTid
%endfunction


%% Function: GetSystemNameForComments  ========================================
%%   Return the name of the system to be used in the comments
%%
%function GetSystemNameForComments(sys) void
  %if IsModelReferenceBaseSys(sys)
    %assign sysInfo = "model '%<::CompiledModel.Name>'"
  %elseif  LibSystemIsReusedLibraryFcn(sys) && ISFIELD(sys, "RLSCommentName")
    %assign sysInfo =  "system %<sys.RLSCommentName>"
  %else
    %if BlockCommentType == "BlockSIDComment"
      %assign sysInfo = "system %<sys.SIDCommentName>"
    %else
      %assign sysInfo =  "system '%<sys.Name>'"
      %if sys.Synthesized && ISFIELD(sys,"OriginatorBlock")
        %assign sysInfo =  "system '%<sys.OriginatorBlock>'"
      %endif
    %endif
  %endif
  %return sysInfo
%endfunction


%% Function: GetSystemNameForStartOfComments  =================================
%%   Return the name of the system to be used at the start of comments
%%
%function GetSystemNameForStartOfComments(sys) void
  %if IsModelReferenceBaseSys(sys)
    %assign sysInfo = "Model '%<::CompiledModel.Name>'"
  %else
    %if BlockCommentType == "BlockPathComment"
      %assign sysInfo = "System '%<sys.Name>'"
    %else
      %assign sysInfo = "System %<sys.SIDCommentName>"
    %endif
  %endif
  %return sysInfo
%endfunction

%% Function: GetRTMErrorStatusPtr ===============================
%% Return pointer of RTModel ErrorStatus. When this pointer is
%% volatile, cast it to (const char_T **) to avoid compiler
%% warnning message
%function GetRTMErrorStatusPtr() void
  %assign esptr = "(&%<RTMGetErrStat()>)"
  %if RTMErrorStatusMustVolatile()
    %% must explict cast to avoid compiler warning
    %assign esptr = "((const char_T **)%<esptr>)"
  %endif
  %return esptr
%endfunction

%% Function:  CorCPPForBuildLogsandComment =================================
%%   Return the generated language to be displayed by build logs and comments
%%
%function CorCPPForBuildLogsandComments() void
 %if GenCPP
   %assign langForLogsandComments = "C++"
 %else
   %assign langForLogsandComments = "C"
 %endif
 %return langForLogsandComments
%endfunction

%% Function:  ExternorExternC =================================
%%   Return the appropriate extern declartions depending on target language.
%%
%function ExternorExternC () void
  %if ::LangFileExt == "cpp"
    %assign prefix = "extern \"C\""
  %else
    %assign prefix = LibExternInFcnDecls()
  %endif

  %return prefix
%endfunction

%% Function: SLibSetSystemMap =================================================
%% Abstract:
%%   Save system map to attic. Called in commonentry.tlc.
%%
%function SLibSetSystemMap() void
  %if !ISFIELD(::CompiledModel,"Subsystem") || ...
      !ISFIELD(::CompiledModel,"NumSubsystems")
    %return
  %endif
  %assign systemMap = "{"
  %foreach sysIdx = NumSubsystems
    %assign systemMap = systemMap + ...
      "'%<LibUnmangledPathName(Subsystem[sysIdx].Name)>',"
  %endforeach
  %assign systemMap = systemMap + "}"
  %matlab rtwprivate("rtwattic", "setSystemMap", systemMap)
%endfunction

%% Function: SLibGetModelIsLinearlyImplicit =================================================
%% Abstract:
%%   Return the corrected ModelIsLinearlyImplicit for the model.
%%
%function SLibGetModelIsLinearlyImplicit() void
  %assign isLinearlyImplicit = ::CompiledModel.ModelIsLinearlyImplicit
  %if (isLinearlyImplicit == "yes") && SLibIsDeploymentDiagramWithTopSolver()
    %foreach tgIdx = ::CompiledModel.NumEventHandlers
      %assign tg = ::CompiledModel.EventHandler[tgIdx]
      %% Only periodic tasks can have continuous states
      %if !ISEQUAL(tg.Periodicity.Type, "PeriodicTrigger") 
        %continue
      %endif
      %foreach tIdx = tg.NumTasks 
        %assign task = tg.Task[tIdx]
        %if (SLibDeploymentIsSynthesizedTask(tgIdx, tIdx) && (task.NumContStates > 0))
          %assign isLinearlyImplicit = task.IsLinearlyImplicit
        %endif
      %endforeach
    %endforeach
  %endif
  %return isLinearlyImplicit
%endfunction

%% Function: SLibMassMatrixType =================================================
%% Abstract:
%%   Convert MassMatrixType (enum) to a mnemonic.
%%
%function SLibMassMatrixType(massMatrixTypeId) void
  %assign retVal = "none"
  %if (::CompiledModel.ModelIsLinearlyImplicit == "yes")
    %switch massMatrixTypeId
        %case 0
          %assign retVal = "none"
          %break
        %case 1
          %assign retVal = "constant"
          %break
        %case 2
          %assign retVal = "timedep"
          %break
        %case 3
          %assign retVal = "statedep"
          %break
      %endswitch
  %endif  %% ModelIsLinearlyImplicit
  %return retVal
%endfunction

%% Function: SLibMassMatrixType =================================================
%% Abstract:
%%   Return the MassMatrixType (mnemonic) for the model.
%%
%function SLibModelMassMatrixType() void
  %assert (::CompiledModel.ModelIsLinearlyImplicit == "yes")
  %return SLibMassMatrixType(::CompiledModel.ModelMassMatrixType)
%endfunction

%% Function: SLibGetModelHasProjections =================================================
%% Abstract:
%%   Return the corrected ModelHasProjection for the model.
%%
%function SLibGetModelHasProjections() void
  %assign hasProjections = ::CompiledModel.ModelHasProjections
  %if (hasProjections == "yes") && SLibIsDeploymentDiagramWithTopSolver()
    %foreach tgIdx = ::CompiledModel.NumEventHandlers
      %assign tg = ::CompiledModel.EventHandler[tgIdx]
      %% Only periodic tasks can have continuous states
      %if !ISEQUAL(tg.Periodicity.Type, "PeriodicTrigger") 
        %continue
      %endif
      %foreach tIdx = tg.NumTasks 
        %assign task = tg.Task[tIdx]
        %if (SLibDeploymentIsSynthesizedTask(tgIdx, tIdx) && (task.NumContStates > 0))
          %assign hasProjections = task.HasProjections
        %endif
      %endforeach
    %endforeach
  %endif
  %return hasProjections
%endfunction

%% DocFunction{Advanced Functions}: LibIsModelReferenceTarget ==================
%% Abstract:
%%    Return true if we are generating code for model reference target
%%
%function LibIsModelReferenceTarget()
  %return IsModelReferenceTarget()
%endfunction

%% DocFunction{Advanced Functions}: LibIsModelReferenceSimTarget ===============
%% Abstract:
%%    Return true if we are generating code for model reference sim target
%%
%function LibIsModelReferenceSimTarget()
  %return IsModelReferenceSimTarget()
%endfunction

%function SLibIsHostBasedSimulationTarget()
  %return (CodeFormat == "S-Function" || Accelerator || isRSim || isRAccel || IsModelReferenceSimTarget())
%endfunction

%% DocFunction{Advanced Functions}: LibIsModelReferenceRTWTarget ===============
%% Abstract:
%%    Return true if we are generating code for model reference codegen target
%%
%function LibIsModelReferenceRTWTarget()
  %return IsModelReferenceRTWTarget()
%endfunction

%function SLibNonEmptyModel() void
  %assign rootSystem = ::CompiledModel.System[::CompiledModel.NumSystems-1]
  %return rootSystem.NumBlocks > 0
%endfunction

%% DocFunction{Sample Time Functions}: LibGetNumSyncPeriodicTasks ===============
%% Abstract:
%%    Return the number of periodic tasks in
%%  generated code.
%%
%function LibGetNumSyncPeriodicTasks()
  %assign numSyncTasks = 1 %% assume
  %if !SLibSingleTasking()
    %with ::CompiledModel
      %assign tid01Eq = ISEQUAL(SolverType, "FixedStep") && FixedStepOpts.TID01EQ
      %assign numSyncTasks = (NumSynchronousSampleTimes - tid01Eq)
    %endwith
  %endif

  %return numSyncTasks
%endfunction

%% DocFunction{Sample Time Functions}: LibGetNumRuntimeExportedTasks ===============
%% Abstract:
%%    Return the number of periodic and unconstrained tasks in
%%  generated code.
%%
%function LibGetNumRuntimeExportedTasks()
  %assign numRuntimeExportedTasks = 1 %% assume
  %if !SLibSingleTasking()
    %with ::CompiledModel
      %assign tid01Eq = ISEQUAL(SolverType, "FixedStep") && FixedStepOpts.TID01EQ
      %assign numSyncTasks = (NumRuntimeExportedRates - tid01Eq)
    %endwith
  %endif

  %return numRuntimeExportedTasks
%endfunction

%% DocFunction{Sample Time Functions}: LibGetNumAsyncTasks ===============
%% Abstract:
%%    Return the number of asynchronous tasks in
%%  generated code.
%%
%function LibGetNumAsyncTasks()
  %return ::CompiledModel.NumAsynchronousSampleTimes
%endfunction

%function SLibGetNumExplictTasksInUnion()
  %return ::CompiledModel.NumExplictTasksInUnionSampleTimes
%endfunction


%% DocFunction{Sample Time Functions}: LibGetNumTasks ===============
%% Abstract:
%%    Return the number of tasks in
%%  generated code.
%%
%function LibGetNumTasks()
  %return LibGetNumRuntimeExportedTasks() + LibGetNumAsyncTasks() + SLibGetNumExplictTasksInUnion()
%endfunction

%function SLibSetNeedRateInteraction(tid1, tid2) void
  %assert tid1 > tid2
  %assign ::CompiledModel.MatrixOfRequireRateInteraction[tid2][tid1] = TLC_TRUE
  %assign ::CompiledModel.RequireRateInteraction = TLC_TRUE
  %% if not SuppressMultiTaskScheduler, SpecialSampleHit is calculated from SampleHit flags
  %if !SuppressMultiTaskScheduler
    %assign ::CompiledModel.RequireMultiRateSampleHits = 1
  %endif
%endfunction

%function SLibGetNeedRateInteraction(tid1, tid2) void
  %return (::CompiledModel.MatrixOfRequireRateInteraction[tid1][tid2] == TLC_TRUE)
%endfunction

%% Function: SLibGetNullDefinitionFromTfl
%% Abstract:
%%   Return the definition of NULL in the TFL registration
%%
%function SLibGetNullDefinitionFromTfl()
%assign nulldef = LibGetMathConstant("NULL", tSS_INTEGER)
%if ISEMPTY(nulldef)
  %return "(NULL)"
%else
  %return nulldef
%endif
%endfunction

%% DocFunction{Other Useful Functions}: LibExternInFcnDecls ====================
%% Abstract:
%%   Returns "extern " if the Code style "Preserve extern in function
%%   declarations is on, "" otherwise
%%
%function LibExternInFcnDecls() void
  %if ::CompiledModel.PreserveExternInFcnDecls
    %return "extern "
  %else
    %return ""
  %endif
%endfunction

%% DocFunction{Other Useful Functions}: LibPreserveExternInFcnDecls ===========
%% Abstract:
%%   Returns 1 if the Code style "Preserve extern in function declarations is
%%   on, 0 otherwise
%%
%function LibPreserveExternInFcnDecls() void
  %return ::CompiledModel.PreserveExternInFcnDecls
%endfunction

%% Utility function. Convert the filesep in a path to double filesep
%function LibChangeSlashToDoubleSlash(inputStr)
  %assign filesep = FEVAL("filesep")
  %assign result = ""
  %assign len = SIZE(inputStr,1)
  %foreach idx = len
    %if inputStr[idx] == filesep
      %assign result = result + filesep
    %endif
    %assign result = result + inputStr[idx]
  %endforeach
  %return result
%endfunction

%% Utility Function: SLibIsPragmaOnDecls ===========
%% Abstract:
%%   Returns true to indicate pragmas are applied to data and function declarations
%%   Define and set global variable PragamOnDecls to TLC_FALSE to turn it off
%%
%function SLibIsPragmaOnDecls() void
  %if EXISTS(::_PragmaOnDecls) == 0
      %return TLC_TRUE
  %elseif ::_PragmaOnDecls > 0
      %return TLC_TRUE
  %else
      %return TLC_FALSE
  %endif
%endfunction

%% Utility Function: SLibGetMemSecCategoryForUtilityFcn() ===========
%% Abstract:
%%   Return proper memory section function category based upon shared or not
%%
%function SLibGetMemSecCategoryForUtilityFcn() void
  %assign msfcn = "MemSecFuncSharedUtil"
  %return msfcn
%endfunction


%function LibUpdateBlockCStateAbsoluteTolerance(block, system) Output
  %assign ncStates  = ContStates[0]
  %if EXISTS(AbsoluteTolerance)
    %assign rollRegions = [0:%<ncStates-1>]
    %assign rollVars = ["xAbsTol", "<param>/AbsoluteTolerance"]
    %roll sigIdx = rollRegions, lcv = RollThreshold, block, "Roller", rollVars
      %assign absTol = LibBlockParameter(AbsoluteTolerance, "", lcv, sigIdx)
      %<LibBlockContStateAbsoluteTolerance("", lcv, sigIdx)> = %<absTol>;
    %endroll
  %endif
%endfunction

%%namespace utility functions
%function SLibSystemNeedsNamespace(system)
  %assign needNamespace = TLC_FALSE

  %if ::GenerateClassInterface && EXISTS(::NamespaceName) && (::NamespaceName != "")
    %if (system.SystemNamespaceFlag == 0)
      %assign needNamespace = TLC_TRUE
    %endif
  %endif
  %return needNamespace
%endfunction

%function SLibEmitNamespaceStartForSystem(system)
  %assign namespaceStr = "namespace %<::NamespaceName> {"
  %assign system.SystemNamespaceFlag = 1

  %return namespaceStr
%endfunction

%function SLibEmitNamespaceCloseForSystem(system)
  %assign closeStr = ""
  %% No need to check if using CPP Encap since
  %% SystemNamespaceFlag will never be 1 if it is not
  %if system.SystemNamespaceFlag == 1
    %assign closeStr = "}"
    %assign system.SystemNamespaceFlag = 0
  %endif

  %return closeStr
%endfunction

%% Function: SLibNeedWrapperStepFcn ============================================
%% Abstract:
%%   Does wrapper step function need to be generated?
%%
%%   Return Value:
%%      0: Not generated
%%      1: Generated in <model>.c
%%      2: Generated in rtmodel.c (Featured off)
%%
%function SLibNeedWrapperStepFcn() void
  %assign retVal = 0
  %assign rootSystem = System[NumSystems-1]
  %if SLibIsMultiRateAndPeriodicRateGrouping(rootSystem) && ...
    !IsModelReferenceTarget()
    %if GenerateGRTWrapper || SLibGenerateNativeThreads() || ...
      !(GenerateSampleERTMain || RateBasedStepFcn)
      %% Generate wrapper step function in <model>.c
      %assign retVal = 1
    %elseif !GenerateSampleERTMain && TLC_FALSE %% Featured off
      %% Generate wrapper step function in rtmodel.c
      %assign retVal = 2
    %endif
  %endif
  %return retVal
%endfunction

%% Function: LibIsServer =======================================================
%% Abstract:
%%    Return true if system is a server
%%
%function LibIsServer(system) void
  %return system.IsService 
%endfunction

%% Function: LibIsGlobalServer =================================================
%% Abstract:
%%    Return true if system is a global server
%%
%function LibIsGlobalServer(system) void
  %return system.IsService && (system.IsGlobal || ...
            (SLibIsExportFcnDiagram() && ...
             system.IsModelScopedSLFcn && ...
             !system.IsMultiInstanceSLFcn))
%endfunction


%% Function: SLibIsMultiInstanceServer =================================================
%% Abstract:
%%    Return true if system is a multi-instance server
%%
%function SLibIsMultiInstanceServer(system) void
  %return system.IsService && system.IsMultiInstanceSLFcn
%endfunction

%% Function: SLibIsModelScopedServer ===========================================
%% Abstract:
%%    Return true if system is a model scoped server
%%
%function SLibIsModelScopedServer(system) void
  %return system.IsService && system.IsModelScopedSLFcn
%endfunction

%% Function: LibHasClientsOrServers ============================================
%% Abstract:
%%    Return true if we are generating code for a model that contains
%%    clients or servers
%%
%function LibHasClientsOrServers() void
  %return ::CompiledModel.HasClientsOrServers == "yes"
%endfunction

%% Function: SLibHasSimulinkFunctionRootIO ======================================
%% Abstract:
%%    Return true if we are generating code for a model that contains
%%    simulink functions connected directly to root I/O
%%
%function SLibHasSimulinkFunctionRootIO() void
  %if IsModelReferenceTarget()
    %assign baseSystemIdx = GetBaseSystemIdx()
    %assign intf = ::CompiledModel.System[baseSystemIdx].Interface
    %foreach idx = intf.NumCanonicalInputArgDefs
      %assign argdef = intf.CanonicalInputArgDef[idx]
      %if argdef.ConnectedToSimulinkFunction == "yes"
        %return TLC_TRUE
      %endif
    %endforeach
    %foreach idx = intf.NumCanonicalOutputArgDefs
      %assign argdef = intf.CanonicalOutputArgDef[idx]
      %if argdef.ConnectedToSimulinkFunction == "yes"
        %return TLC_TRUE
      %endif
    %endforeach
  %endif
  %return TLC_FALSE
%endfunction

%% Function: SLibCacheModelArgsInStart =========================================
%% Abstract:
%%   Returns true if global model reference arguments should be cached in the
%%   start function.
%%
%function SLibCacheModelArgsInStart(system) void
  %return IsModelReferenceBaseSys(system) && ...
    (system.Interface.CacheCanonicalPrmInStart ...
    || SLibHasSimulinkFunctionRootIO())
%endfunction %% SLibCacheModelArgsInStart

%% Function: SLibEndIfVariantConditionForm =====================================
%% Abstract:
%%   Return endif or ""
%%
%function SLibEndIfVariantConditionForm(condition) void
  %%if ISEMPTY(condition)
    %return ""
  %%else
   %%return "\n #endif"
  %%endif
%endfunction

%% Function: SLibIfVariantConditionForm =====================================
%% Abstract:
%%   Return if condition or ""
%%
%function SLibIfVariantConditionForm(condition) void
  %%if ISEMPTY(condition)
    %return ""
  %%else
    %%return "#if %<condition> \n"
  %%endif
%endfunction

%% Function: SLibEndIfVariantConditionForm16b =====================================
%% Abstract:
%%   Return endif or ""
%%
%function SLibEndIfVariantConditionForm16b(condition) void
  %if ISEMPTY(condition)
    %return ""
  %else
   %return "\n #endif \n"
  %endif
%endfunction

%% Function: SLibIfVariantConditionForm16b =====================================
%% Abstract:
%%   Return if condition or ""
%%
%function SLibIfVariantConditionForm16b(condition) void
  %if ISEMPTY(condition)
    %return ""
  %else
    %return "\n #if %<condition> \n"
  %endif
%endfunction

%% Function: SLibIfVariantCondition =====================================
%% Abstract:
%%   Return the opening preprocessor condition
%%   uses the compiled version not the graphical one!
%%   variantcondition = LocalInlineVariantsPreprocessorCondition
%%
%function SLibIfVariantCondition(Element) void
  %if (!ISEMPTY(Element) && ISFIELD(Element, "VariantCondition"))
    %return SLibIfVariantConditionForm(Element.VariantCondition)
  %else
    %return ""
  %endif
%endfunction


%% Function: SLibEndIfVariantCondition ==================================
%% Abstract:
%%   Return the closing preprocessor condition
%%   use the compiled version not the graphical one!
%%   variantcondition = LocalInlineVariantsPreprocessorCondition
%%
%function SLibEndIfVariantCondition(Element) void
  %if (!ISEMPTY(Element) && ISFIELD(Element, "VariantCondition"))
    %return SLibEndIfVariantConditionForm(Element.VariantCondition)
   %else
    %return ""
  %endif
%endfunction

%% Function: SLibVariantConditionForTID =========================
%% Abstract:
%% Return propagated CGVCE condition set on Tasks (TID's)
%% return empty when model has no code variants or tasks have no
%% associated propagated condition
%%
%function SLibVariantConditionForTID(tid) void
  %assign condition = ""
  %if (!::CompiledModel.HasCodeVariants) 
      %return condition %% return empty
  %endif
  
  %if EXISTS(CodeVariants.TIDWithCGVCE[tid]) && !ISEMPTY(CodeVariants.TIDWithCGVCE[tid])
    %if EXISTS(CodeVariants.TIDWithCGVCE[tid].NetCGVCEPoundIf)
      %assign condition = CodeVariants.TIDWithCGVCE[tid].NetCGVCEPoundIf
    %endif
  %endif

  %return condition
%endfunction

%% Function SLibVariantEMVCEForTID ==============================
%% Abstract:
%% Return the EMVCE object representing NetCGVCE (M and C expression)
%% NetSVCE and EMVCE expression. This is required to populate the 
%% VariantInfo field in CodeInfo.
%% TopTester: matlab/test/toolbox/simulink/variants/inlineVariants/variantSource/codeGen/ExportFcns/tExportFcnsWithInlineVariants.m -testspec:g1760200
%function SLibVariantEMVCEForTID(tid) void
  %assign result = ["", "", "", 1]
   %if (!::CompiledModel.HasCodeVariants) 
      %return result %% return empty
  %endif
  
  %if EXISTS(CodeVariants.TIDWithCGVCE[tid]) && !ISEMPTY(CodeVariants.TIDWithCGVCE[tid])
    %if EXISTS(CodeVariants.TIDWithCGVCE[tid].NetCGVCEPoundIf)
      %assign result[0] = CodeVariants.TIDWithCGVCE[tid].NetCGVCEPoundIf
      %assign result[1] = CodeVariants.TIDWithCGVCE[tid].NetCGVCE
      %assign result[2] = CodeVariants.TIDWithCGVCE[tid].EMVCE
      %assign result[3] = CodeVariants.TIDWithCGVCE[tid].NetSVCE
    %endif
  %endif
  %return result 
%endfunction  

%% Function: SLibMakeSingleLine ==================================
%% Abstract:
%%   Ensure a statement is output on its own line
%%
%function SLibMakeSingleLine(stmt)
  %return "\n" + stmt + "\n"
%endfunction


%% Function: SLibVarGroupHasElementDefine ==================================
%% Abstract:
%%   Define the has element preprocessor define for this vargroup
%%
%function SLibVarGroupHasElementDefine(varGroup)
  %return SLibMakeSingleLine("#define " + varGroup.HasElement)
%endfunction


%% Function: SLibWrapBody ==================================
%% Abstract:
%%   Wrap a body with some preprocessor conditions
%%
%function SLibWrapBody(ifCond, body, endIfCond)
  %openfile response
  %if ISEMPTY(ifCond)
    %<body>
  %else
    %<SLibMakeSingleLine(ifCond)>
    %<body>
    %<SLibMakeSingleLine(endIfCond)>
  %endif
  %closefile response
  %return response
%endfunction


%% Function: SLibWrapHasElement ==================================
%% Abstract:
%%   Wrap a body with some preprocessor conditions
%%
%function SLibWrapDefinedHasElement(varGroup, body)
  %assign hasElementName = varGroup.HasElement
  %return SLibWrapBody("#ifdef " + hasElementName, body, "#endif /* %<hasElementName> */")
%endfunction


%% Function: SLibWrapDoesNotHaveElement ==================================
%% Abstract:
%%   Wrap a body with some preprocessor conditions
%%
%function SLibWrapUndefinedHasElement(varGroup, body)
  %assign hasElementName = varGroup.HasElement
  %return SLibWrapBody("#ifndef " + hasElementName, body, "#endif /* %<hasElementName> undefined */")
%endfunction


%% Function: SLibIfVariantCondition16b =====================================
%% Abstract:
%%   A workaround for 16a; to be removed in 16b
%%   Return the opening preprocessor condition
%%   uses the compiled version not the graphical one!
%%   variantcondition = LocalInlineVariantsPreprocessorCondition
%%
%function SLibIfVariantCondition16b(Element) void
  %if SLibHasVariantCondition(Element)
    %return SLibIfVariantConditionForm16b(Element.VariantCondition)
  %else
    %return ""
  %endif
%endfunction

%% Function: SLibIfNetVariantConditionForData =====================================
%% Abstract:
%%   Return the opening preprocessor condition
%%   uses the compiled version not the graphical one!
%%
%function SLibIfNetVariantConditionForData(Element) void
  %if SLibHasNetVariantConditionForData(Element)
    %return SLibIfVariantConditionForm16b(Element.NetVariantConditionForData)
  %else
    %return ""
  %endif
%endfunction


%% Function: SLibEndIfVariantCondition16b ==================================
%% Abstract:
%%   A workaround for 16a; to be removed in 16b
%%   Return the closing preprocessor condition
%%   use the compiled version not the graphical one!
%%   variantcondition = LocalInlineVariantsPreprocessorCondition
%%
%function SLibEndIfVariantCondition16b(Element) void
  %if SLibHasVariantCondition(Element)
    %return SLibEndIfVariantConditionForm16b(Element.VariantCondition)
   %else
    %return ""
  %endif
%endfunction

%% Function: SLibEndIfNetVariantConditionForData ==================================
%% Abstract:
%%   Return the closing preprocessor condition
%%   use the compiled version not the graphical one!
%%
%function SLibEndIfNetVariantConditionForData(Element) void
  %if SLibHasNetVariantConditionForData(Element)
    %return SLibEndIfVariantConditionForm16b(Element.NetVariantConditionForData)
   %else
    %return ""
  %endif
%endfunction


%% Function: SLibWrapVariantCondition ==================================
%% Abstract:
%%   Wrap a body with a variant condition
%%
%function SLibWrapVariantCondition(element, body) void
  %assign ifCond = SLibIfVariantCondition16b(element)
  %assign endIfCond = SLibEndIfVariantCondition16b(element)
  %return SLibWrapBody(ifCond, body, endIfCond)
%endfunction


%% Function: SLibHasVariantCondition ==================================
%% Abstract:
%%   Tell whether an element has a variant condition
%%
%function SLibHasVariantCondition(element) void
  %return !ISEMPTY(element) && ISFIELD(element, "VariantCondition") && element.VariantCondition != ""
%endfunction

%% Function: SLibHasNetVariantConditionForData ==================================
%% Abstract:
%%   Tell whether an element has a variant condition
%%
%function SLibHasNetVariantConditionForData(element) void
  %return !ISEMPTY(element) && ISFIELD(element, "NetVariantConditionForData") && element.NetVariantConditionForData != ""
%endfunction

%% Function: SLibIfSystemVariantCondition =====================================
%% Abstract:
%%   Return the opening system preprocessor condition
%%   uses the compiled version not the graphical one!
%%
%function SLibIfSystemVariantCondition(system) void
  %if SLibHasSystemVariantCondition(system)
    %return SLibIfVariantConditionForm(system.SystemInlineVariantPreprocessorCondition)
  %else
    %return ""
 %endif
%endfunction


%% Function: SLibEndIfSystemVariantCondition ==================================
%% Abstract:
%%   Return the closing system preprocessor condition
%%   use the compiled version not the graphical one!
%%
%function SLibEndIfSystemVariantCondition(system) void
  %if SLibHasSystemVariantCondition(system)
    %return SLibEndIfVariantConditionForm(system.SystemInlineVariantPreprocessorCondition)
  %else
    %return ""
  %endif
%endfunction


%% Function: SLibIfSystemVariantCondition16b =====================================
%% Abstract:
%%   Return the opening system preprocessor condition
%%   uses the compiled version not the graphical one!
%%
%function SLibIfSystemVariantCondition16b(system) void
  %if SLibHasSystemVariantCondition(system)
    %return SLibIfVariantConditionForm16b(system.SystemInlineVariantPreprocessorCondition)
  %else
    %return ""
 %endif
%endfunction


%% Function: SLibEndIfSystemVariantCondition16b ==================================
%% Abstract:
%%   Return the closing system preprocessor condition
%%   use the compiled version not the graphical one!
%%
%function SLibEndIfSystemVariantCondition16b(system) void
  %if SLibHasSystemVariantCondition(system)
    %return SLibEndIfVariantConditionForm16b(system.SystemInlineVariantPreprocessorCondition)
  %else
    %return ""
  %endif
%endfunction


%% Function: SLibWrapSystemVariantCondition ==================================
%% Abstract:
%%   Wrap a body with a variant condition
%%
%function SLibWrapSystemVariantCondition(element, body) void
  %assign ifCond = SLibIfSystemVariantCondition16b(element)
  %assign endIfCond = SLibEndIfSystemVariantCondition16b(element)
  %return SLibWrapBody(ifCond, body, endIfCond)
%endfunction


%% Function: SLibVariantConditionRecord ==================================
%% Abstract:
%%   A record to hold a pair of variant conditions
%%
%function SLibVariantConditionRecord()
  %createrecord emptyRecord { ifCond ""; endIfCond ""; hasConds TLC_FALSE}
  %return emptyRecord
%endfunction


%% Function: SLibGetSystemVariantConditions ==================================
%% Abstract:
%%   Return the pair of system inline variant conditions
%%
%function SLibGetSystemVariantConditions(element)
  %assign vcRecord = SLibVariantConditionRecord()
  %assign vcRecord.ifCond = SLibIfSystemVariantCondition16b(element)
  %assign vcRecord.endIfCond = SLibEndIfSystemVariantCondition16b(element)
  %assign vcRecord.hasConds = SLibHasSystemVariantCondition(element)
  %return vcRecord
%endfunction

%% Function: SLibGetInlineVariantConditions ==================================
%% Abstract:
%%   Return the pair of inline variant conditions
%%
%function SLibGetInlineVariantConditions(element)
  %assign vcRecord = SLibVariantConditionRecord()
  %assign vcRecord.ifCond = SLibIfVariantCondition16b(element)
  %assign vcRecord.endIfCond = SLibEndIfVariantCondition16b(element)
  %assign vcRecord.hasConds = SLibHasVariantCondition(element)
  %return vcRecord
%endfunction

%% Function: SLibGetNetInlineVariantConditionForData ==================================
%% Abstract:
%%   Return the inline variant conditions for DWORKs and Block I/O
%%
%function SLibGetNetInlineVariantConditionForData(element)
  %assign vcRecord = SLibVariantConditionRecord()
  %assign vcRecord.ifCond = SLibIfNetVariantConditionForData(element)
  %assign vcRecord.endIfCond = SLibEndIfNetVariantConditionForData(element)
  %assign vcRecord.hasConds = SLibHasNetVariantConditionForData(element)
  %return vcRecord
%endfunction

%% Function: SLibGetSystemFromVarGroup ==================================
%% Abstract:
%%   If a vargroup represents a system, return it
%%
%function SLibGetSystemFromVarGroup(varGroup)
  %createrecord system {}
  %if ::CompiledModel.NumSystems > 1
    %assign systemIndex = varGroup.SysIdx
    %if systemIndex != -1
      %assign systems = ::CompiledModel.System
      %assign system = systems[systemIndex]
    %endif
  %endif
  %return system
%endfunction


%% Function: SLibGetInlineSystemNetConditionFromVarGroup ==================================
%% Abstract:
%%   If a net condition exists, return it
%%
%function SLibGetInlineSystemNetConditionFromVarGroup(varGroup)
  %return SLibGetIndexedSystemCondition(varGroup, "NetInlineVariantPreprocessorInstanceConditions")
%endfunction


%% Function: SLibGetInlineSystemRelativeConditionFromVarGroup ==================================
%% Abstract:
%%   If a relative condition exists, return it
%%
%function SLibGetInlineSystemRelativeConditionFromVarGroup(varGroup)
  %return SLibGetIndexedSystemCondition(varGroup, "RelativeInlineVariantPreprocessorInstanceConditions")
%endfunction


%% Function: SLibGetIndexedSystemCondition ==================================
%% Abstract:
%%   If an indexed system condition exists, return it
%%
%function SLibGetIndexedSystemCondition(varGroup, fieldName)
  %assign vcRecord = SLibVariantConditionRecord()
  %assign instanceIndex = varGroup.InstanceIdx
  %if instanceIndex == -1
    %assign instanceIndex = 0
  %endif
  %assign system = SLibGetSystemFromVarGroup(varGroup)
  %if !ISEMPTY(system)
    %if ISFIELD(system, fieldName)
      %assign conditions = GETFIELD(system, fieldName)
      %% The vargroup has indexed conditions
      %if !ISEMPTY(conditions)
        %assign condition = conditions[instanceIndex]
        %if condition != ""
          %assign vcRecord.ifCond = SLibIfVariantConditionForm16b(condition)
          %assign vcRecord.endIfCond = SLibEndIfVariantConditionForm16b(condition)
          %assign vcRecord.hasConds = TLC_TRUE
        %endif
      %endif
    %endif
  %endif
  %return vcRecord
%endfunction


%% Function: SLibGetInlineSystemNetConditions ==================================
%% Abstract:
%%   If the containing system has a net condition, return it
%%
%function SLibGetInlineSystemNetConditions(dataRecord)
  %assign vcRecord = SLibVariantConditionRecord()
  %if ISFIELD(dataRecord, "VarGroupIdx")
    %assign varGroup = ::CompiledModel.VarGroups.VarGroup[dataRecord.VarGroupIdx[0]]
    %assign vcRecord = SLibGetInlineSystemNetConditionFromVarGroup(varGroup)
  %endif
  %return vcRecord
%endfunction


%% Function: SLibGetDataInlineVariantNetConditions ==================================
%% Abstract:
%%   Return the pair of net conditions for either instance data or a plain data
%%      record
%%
%function SLibGetDataInlineVariantNetConditions(element)
  %assign netInstanceCondition = SLibGetNetInlineVariantConditionForData(element)
  %assign elementConds = SLibGetInlineVariantConditions(element)

  %assign vcRecord = SLibVariantConditionRecord()
  
  %if netInstanceCondition.hasConds
    %assign vcRecord = netInstanceCondition
  %% Instance data for a parent system
  %elseif elementConds.hasConds
    %assign vcRecord = elementConds
  %endif

  %return vcRecord
%endfunction


%% Function: SLibHasSystemVariantCondition ==================================
%% Abstract:
%%   Tell whether an element has a system variant condition
%%
%function SLibHasSystemVariantCondition(element) void
  %return !ISEMPTY(element) && ISFIELD(element, "SystemInlineVariantPreprocessorCondition") ...
    && element.SystemInlineVariantPreprocessorCondition != ""
%endfunction


%% Function: SLibRegisterSharedUtility ==================================
%% Abstract:
%%   This function provides an interface to register TLC utilities
%%   It registers the TLC utility in the Shared Code Manager and
%%   returns the update utility string (based on Shared utilities
%%   identifier format control in Configuration Parameters).
%%
%function SLibRegisterSharedUtility(block, utilFcnStr) void
  %if ((!ISEMPTY(block)) && (ISFIELD(block, "TLCBlockSID")))
    %assign blockSID = block.TLCBlockSID
  %else
    %assign blockSID = ""
  %endif
  %assign rtwCtx = ::CompiledModel.RTWContext
  %assign updatedUtilFcnStr = FEVAL("rtwprivate", "rtwcgtlc", "RegisterSCMUtility", rtwCtx, utilFcnStr, blockSID)
  %return updatedUtilFcnStr
%endfunction

%% Function: SLibGetSelfCoderDataGroupVarGroupIndex
%% Abstract:
%%   Returns the VarGroup Index for the Self Coder Data Group
%%   Returns -1 if there is no Coder Data Group associated with Self
%function SLibGetSelfCoderDataGroupVarGroupIndex() void
  %assign selfCoderDataGroupVarGroupIndex = ...
    ::CompiledModel.SelfCoderDataGroupVarGroupIndex
  %if selfCoderDataGroupVarGroupIndex != -1
    %assign selfCoderDataGroupVarGroup = ...
      ::CompiledModel.VarGroups.VarGroup[selfCoderDataGroupVarGroupIndex]
    %assert selfCoderDataGroupVarGroup.IsSelfCoderDataGroupVarGroup == 1
    %return selfCoderDataGroupVarGroupIndex
  %else
    %return -1
  %endif
%endfunction

%% Function: SLibGetSelfCoderGroupArgumentName
%% Abstract:
%%   Returns the self argument name of the self group, if there is any.
%%   If there is no self group, returns empty string.
%function SLibGetSelfCoderGroupArgumentName() void
  %assign selfCoderGroupVarGroupIndex = SLibGetSelfCoderDataGroupVarGroupIndex()
  %if selfCoderGroupVarGroupIndex != -1
    %assign selfCoderGroupVarGroup = ::CompiledModel.VarGroups.VarGroup[selfCoderGroupVarGroupIndex]
    %assert ISFIELD(selfCoderGroupVarGroup, "SelfStructureArgumentName")
    %return selfCoderGroupVarGroup.SelfStructureArgumentName
  %endif
  
  %return ""
%endfunction

%% Function: SLibGetSelfVarGroupIndex
%% Abstract:
%%   Returns the VarGroup index for Self
%%   Self can be mapped (Coder Group) or unmapped (RTM)
%%   Note: This utility is more general than SLibGetSelfCoderDataGroupVarGroupIndex
%function SLibGetSelfVarGroupIndex() void
  %assign rootSystem = ::CompiledModel.System[::CompiledModel.NumSystems-1]
  %if SLibGetDoesSelfHasCoderDataGroup()
    %return SLibGetSelfCoderDataGroupVarGroupIndex()
  %elseif ISFIELD(rootSystem,"SelfVarGroupIndex")
    %return rootSystem.SelfVarGroupIndex[0]
  %else
    %return -1
  %endif
%endfunction

%% Function: SLibGetDoesSelfExist
%% Abstract:
%%   Forwarding function to see if self was created for a model
%%   Otherwise, returns false
%function SLibGetDoesSelfExist() void
  %assign selfCoderDataGroupVarGroupIndex = ...
    SLibGetSelfCoderDataGroupVarGroupIndex()
  %return selfCoderDataGroupVarGroupIndex != -1
%endfunction

%% Function SLibIsSynthesizedRTMEmpty
%% Abstract:
%%   Return true if self is synthesized but empty (i.e. no self var group is created)
%function SLibIsSynthesizedRTMEmpty()
  %assign isempty = TLC_FALSE
  %with ::CompiledModel
    %if SelfCoderDataGroupIndex != -1 && !SLibGetDoesSelfExist()
      %assign selfGroup = CoderDataGroup[SelfCoderDataGroupIndex]
      %assert selfGroup.IsSelf
      %assign isempty = selfGroup.IsSynthesized
    %endif
  %endwith
  %return isempty
%endfunction

%% Function SLibGetUseRTMcgType
%% Abstract:
%%   Return true if RTM is created in IR.
%%   RTM can be packaged as struct (multi-instance models) or asStruct is none (single-instance)
%function SLibGetUseRTMcgType()
  %if !ISFIELD(::CompiledModel, "DoesUseRTMcgType")
    %addtorecord ::CompiledModel DoesUseRTMcgType (SLibGetDoesSelfExist() || SLibIsSynthesizedRTMEmpty())
  %endif
  %return ::CompiledModel.DoesUseRTMcgType
%endfunction

%% Function: SLibIsSelfInPluggableInterface()
%% Abstract:
%%   useRTMcgType and base module uses pluggable interface
%function SLibIsSelfInPluggableInterface()
  %with ::CompiledModel
    %assign baseModule = RTWCGModules.RTWCGModule[System[GetBaseSystemIdx()].CGIRModuleIdx]
    %assign ret = SLibGetUseRTMcgType() && (baseModule.SimplifiedInterface || IsModelReferenceSimTarget()) && SLibIsSelfStructured()
  %endwith
  %return ret
%endfunction

%% Function SLibIsSelfInSimTarget()
%% Abstract:
%%   useRTMcgType and SimTarget
%function SLibIsSelfInSimTarget()
  %return SLibGetUseRTMcgType() && IsModelReferenceSimTarget()
%endfunction


%% Function: SLibGetDoesSelfHasCoderDataGroup
%% Abstract:
%%   Returns true if and only if Self has a Coder Data Group associated with it
%%   Otherwise, returns false.
%%   Note: Self always has a coder data group (synthesized or user defined) so we
%%   only detect if self exsists for a model
%function SLibGetDoesSelfHasCoderDataGroup() void
  %return SLibGetDoesSelfExist()
%endfunction

%% Function: SLibIsSelfUserDefined() void
%% Abstract:
%%   Returns true iff the user has mapped Self to a coder group
%function SLibIsSelfUserDefined() void
  %if SLibGetDoesSelfHasCoderDataGroup() && !SLibSynthesizedRTM()
    %return TLC_TRUE
  %endif

  %return TLC_FALSE  
%endfunction

%% Function: SLibIsSelfStructured()
%% Abstract:
%%   Returns true iff Self coder group exists and it is packaged as struct
%function SLibIsSelfStructured() void
  %assign selfCoderGroupIndex = SLibGetSelfCoderDataGroupIndex()
  %if selfCoderGroupIndex >= 0
    %assign selfCoderGroup = ::CompiledModel.CoderDataGroup[selfCoderGroupIndex]
    %assert (ISFIELD(selfCoderGroup, "AsStructure"))
    %return SLibCoderGroupPackageAsStruct(selfCoderGroup)
  %endif
  
  %return TLC_FALSE
%endfunction

%% Function: SLibIsSelfImported() void
%% Abstract:
%%   Returns true iff Self coder group exists and it is of imported scope
%function SLibIsSelfImported() void
  %assign selfCoderGroupIndex = SLibGetSelfCoderDataGroupIndex()
  %if selfCoderGroupIndex >= 0
    %assign selfCoderGroup = ::CompiledModel.CoderDataGroup[selfCoderGroupIndex]
    %return selfCoderGroup.DataScope == "Imported"
  %endif
  
  %return TLC_FALSE
%endfunction

%% Function: SLibIsSelfUserDefinedAndStructured()
%% Abstract:
%%   Returns true iff the user has mapped Self to a coder group
%%   and that coder group has AsStructure != "None"
%function SLibIsSelfUserDefinedAndStructured() void
  %return SLibIsSelfUserDefined() && SLibIsSelfStructured()
%endfunction

%% Function: SLibGetSelfCoderDataGroupIndex
%% Abstract:
%%   Returns the index of the Coder Data Group corresponding to Self
%%   Returns -1 if there is no Coder Data Group associated with Self
%function SLibGetSelfCoderDataGroupIndex() void
  %if SLibGetDoesSelfHasCoderDataGroup()
  %assign selfCoderDataGroupVarGroupIndex = ...
    SLibGetSelfCoderDataGroupVarGroupIndex()
    %assign selfCoderDataGroupVarGroup = ...
      ::CompiledModel.VarGroups.VarGroup[selfCoderDataGroupVarGroupIndex]
    %assign selfCoderDataGroupIndex = selfCoderDataGroupVarGroup.CoderDataGroupIndex
    %assert selfCoderDataGroupIndex != -1
    %return selfCoderDataGroupIndex
  %else
    %return -1
  %endif
%endfunction

%% Function: SLibIsGroupSelfCoderGroup
%% Abstract:
%%  Is group synthesized RTm?
%function SLibIsGroupSelfCoderGroup(group) void
  %return group.IsSelf
%endfunction

%% Function: SLibIsSynthesizedRTM
%% Abstract:
%%  Is group synthesized RTm?
%function SLibIsSynthesizedRTM(group) void
  %return group.IsSelf && group.IsSynthesized
%endfunction

%% Function: SLibSynthesizedRTM
%% Abstract:
%%  Is RTM using a synthesized coder group?
%function SLibSynthesizedRTM() void
  %return SLibGetDoesSelfHasCoderDataGroup() && ...
    SLibIsSynthesizedRTM(::CompiledModel.CoderDataGroup[SLibGetSelfCoderDataGroupIndex()])
%endfunction

%% Function: SLibSuppressRTM
%% Abstract:
%%  When do we suppress Legacy RTM in TLC?
%function SLibSuppressRTM() void
  %return SLibGetUseRTMcgType() && ...
    !SLibSynthesizedRTM() && ...
    SLibGetDoesSelfHasCoderDataGroup()
%endfunction

%% Function: SLibIsSelfCoderGroupField
%% Abstract: 
%%  Returns true iff the given self field is a pointer to coder group
%function SLibIsSelfCoderGroupField(aSelfVarGroupElementIndex) void
  %assign selfVarGroupIndex = SLibGetSelfVarGroupIndex()
  %if selfVarGroupIndex == -1
    %return TLC_FALSE
  %endif
  
  %assign selfVarGroup = ::CompiledModel.VarGroups.VarGroup[selfVarGroupIndex]
  %if aSelfVarGroupElementIndex >= selfVarGroup.NumVarGroupElements
    %return TLC_FALSE
  %endif
  %assign selfVarGroupElement = selfVarGroup.VarGroupElements[aSelfVarGroupElementIndex]
  %assign idNumElement = IDNUM(selfVarGroupElement)
  %if (idNumElement[0] == "RCDG")
    %return TLC_TRUE
  %endif
  
  %return TLC_FALSE
%endfunction

%% Function: SLibGetCoderGroupIndexFromSelfElementIndex
%% Abstract:
%%  Parses the self element to get the coder group index.
%%  Returns -1 if can't find one.
%function SLibGetCoderGroupIndexFromSelfElementIndex(aSelfVarGroupElementIndex) void
  %if SLibIsSelfCoderGroupField(aSelfVarGroupElementIndex)
    %assign selfVarGroup = ::CompiledModel.VarGroups.VarGroup[SLibGetSelfVarGroupIndex()]
    %assign selfVarGroupElement = selfVarGroup.VarGroupElements[aSelfVarGroupElementIndex]
    %assign idNumElement = IDNUM(selfVarGroupElement)
    %return idNumElement[1]
  %endif
  
  %return -1
%endfunction

%% Function: SLibGetQualifiedRTMType
%% Abstract:
%%  Get the RTM or Coder Group Self type qualifier
%function SLibGetQualifiedRTMType() void
  %assign selfCoderGroupIndex = SLibGetSelfCoderDataGroupIndex()
  %if selfCoderGroupIndex != -1  
    %assign selfCoderGroup = ::CompiledModel.CoderDataGroup[selfCoderGroupIndex]
    %assign typeQualifier = SLibTypeQualifierForGroup(selfCoderGroup)
    %return typeQualifier + " " + ::tSimStructType
  %endif
  
  %return ::tSimStructType
%endfunction

%% Function: SLibGetChildSelfCoderGroupIndex
%% Abstract:
%%   Returns the index for child self coder group in the block
%%   interface coder group record. If there is no such child
%%   self group, returns -1
%function SLibGetChildSelfCoderGroupIndex(mBlock) void
  %assign blockInterface = GetModelrefInterface(mBlock)  
  %if ISFIELD(blockInterface, "CoderDataGroups")
    %assign childCoderGroupsRecord = blockInterface.CoderDataGroups.CoderDataGroup    
    %assign numGroups = SIZE(childCoderGroupsRecord, 1)
    %foreach groupIndex = numGroups
      %if numGroups == 1
        %assign childCoderGroup = childCoderGroupsRecord
      %else
        %assign childCoderGroup = childCoderGroupsRecord[groupIndex]        
      %endif
      
      %assign childCoderGroupIsSelf = ...
        ISFIELD(childCoderGroup, "IsSelf") && childCoderGroup.IsSelf
      %if childCoderGroupIsSelf
        %return groupIndex
      %endif
    %endforeach
  %endif
  
  %return -1
%endfunction

%% Function: SLibPassGlobalInstanceForBlocksSelf
%% Abstract:
%%   This function returns true if and only if we pass
%%   a global self instance for the child block's self.
%%   Note that we either pass global chilf self instances
%%   or access child self instance through self structure.
%function SLibPassGlobalInstanceForBlocksSelf(aBlock) void
  %assert aBlock.Type == "ModelReference"

  %% Look for global self instance
  %assign childSelfCoderGroupIndex = SLibGetChildSelfCoderGroupIndex(aBlock)
  %if childSelfCoderGroupIndex != -1
    %assign blockInterface = GetModelrefInterface(aBlock)
    %assign childCoderGroupsRecord = blockInterface.CoderDataGroups.CoderDataGroup
    %assign numChildCoderGroups = SIZE(childCoderGroupsRecord, 1)
    %if numChildCoderGroups > 1
      %assign childSelfCoderGroup = childCoderGroupsRecord[childSelfCoderGroupIndex]
    %else
      %assign childSelfCoderGroup = childCoderGroupsRecord
    %endif
    %assign groupIndexWithChildSelfNameInCurrentModel = ...
      SLibCoderDataGroupIndex(childSelfCoderGroup.Name)      
    %assign childSelfGroupNameRegisteredInCurrentModel = ...
       groupIndexWithChildSelfNameInCurrentModel != -1
    %assign childSelfGroupIsInParent = ...
      ISFIELD(childSelfCoderGroup, "AsStructure") && ...
      childSelfCoderGroup.AsStructure == "InParent"
    %assign groupWithChildSelfNameInCurrentModelIsAsStructureNone = ...
      childSelfGroupNameRegisteredInCurrentModel && ...
      ::CompiledModel.CoderDataGroup[groupIndexWithChildSelfNameInCurrentModel].AsStructure == "None" && ...
      !IsModelReferenceSimTarget()
    %if childSelfGroupIsInParent && ...
        (!childSelfGroupNameRegisteredInCurrentModel || ...
        groupWithChildSelfNameInCurrentModelIsAsStructureNone)
      %return TLC_TRUE
    %endif
  %endif
  
  %return TLC_FALSE
%endfunction

%% Function: SLibGetGlobalInstanceNameForBlocksSelf
%% Abstract:
%%   Returns the global self instance name for block's self
%%   if we use a global instance. 
%function SLibGetGlobalInstanceNameForBlocksSelf(aBlock) void
  %assert SLibPassGlobalInstanceForBlocksSelf(aBlock)
  %return "&" + aBlock.Identifier
%endfunction

%% Function: FcnApplyMemSec =================================================
%% Abstract:
%%   Should memory sections be honored for the data structures of this model?
%function FcnApplyMemSec() void
  %% This Fcn controls whether Memory Sections
  %% are emitted or not based on whether there 
  %% are memory sections registered in Dicty.
  %% So we need to add a way for it to return true for
  %% synthesized memory sections (task based partitioning).
  %% Here I chose the feature flag. Needs Refactoring.
  %return (SLibIsERTTarget() && ...
    !FcnIsERTMalloc() && ...
    !IsModelReferenceSimTarget() && ...
    (SLibAreInternalMemorySectionsDefined() || ...
     SLibIsCoderDictionaryActiveForDefaults() || ...
     (FEVAL("slfeature", "TaskBasedPartitionOfData") > 0) || ...
    SLibAutosarActive()))
%endfunction

%function SLibMultiInstance() void
  %if IsModelReferenceTarget()
    %return ::CompiledModel.OkToMultiInstanceModelref
  %else
    %return MultiInstanceERTCode
  %endif
%endfunction

%% DocFunction{Other Useful Functions}: LibIsRowMajorLayout ==================
%% Abstract:
%% Is the model generating code in Row Major Layout
%function LibIsRowMajorLayout() void
  %return %<CGMODEL_ACCESS("CGModel.IsRowMajor")>
%endfunction

%% Function: LibGetStaticStorageSpecifierIfNeeded
%%
%% Abstract: If the function needs to be appended with static storage 
%%           specifier, this function returns the keyword "static"
%%           else it returns an empty string
%function LibGetStaticStorageSpecifierIfNeeded() void
  %assign staticSpecifier = ""
  %assign genToShared = (::CompiledModel.GenUtilsSrcInSharedLocation == 1)
  %if(SLibIsCompactFileFormat() && !genToShared && CGMODEL_ACCESS("CGModel.AddStaticKeywordToFcn"))
    %assign staticSpecifier = "static "
  %endif
  %return staticSpecifier
%endfunction

%%DocFunction{Other Useful Functions}:  LibIsRecordMutiDimension =================
%% Abstract:
%% Returns if the record has multiple dimensions and preserves the array 
%% dimensions in the generated code
%function LibIsRecordMultiDimension(record) void
  %return SLibIsContainerCGTypeND(record)
%endfunction

%endif %% _UTILLIB_
%% [EOF] utillib.tlc
