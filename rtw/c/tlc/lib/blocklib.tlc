%%
%% 
%%
%%
%% Copyright 1994-2017 The MathWorks, Inc.
%%
%% Abstract:
%%   This TLC library contains all the routines for accessing internal block
%%   information.
%%

%if EXISTS("_BLOCKLIB_") == 0
%assign _BLOCKLIB_ = 1

%%
%% (1) Global Library Functions (Lib functions)
%%

%% DocFunction{BlkStateAndWorkVectFcns}: LibBlockDiscreteState =================
%% Abstract:
%%   Returns a string corresponding to the specified block discrete state
%%   (DSTATE) element.
%%
%function LibBlockDiscreteState(ucv, lcv, idx) void

  %% See Also:
  %%   LibBlockContinuousState
  %%

  %assign dwIdx = DiscStates[1]
  %assign dwRec = ::CompiledModel.DWorks.DWork[dwIdx]

  %% Set use of floating-point types if integer only code
  %if PurelyIntegerCode
    %%START_ASSERT
    %assign dTypeId = LibGetDataTypeIdAliasedThruToFromId(LibGetRecordDataTypeId(dwRec))
    %if dTypeId == tSS_DOUBLE || dTypeId == tSS_SINGLE
      %<SLibCacheIntegerOnlyWarning(Name,"State")>
    %endif
    %%END_ASSERT
  %endif

  %createrecord optionalArgs {}
  %with FcnLoopInfo(ucv, lcv, idx)
    %return FcnSimpleGetDWork(dwRec, dwIdx, DiscStates[0], "xd", optionalArgs)
  %endwith
%endfunction %% LibBlockDiscreteState

%% Function: FcnCsHStructDeclSystemIdx =========================================
%% Abstract: return what system owns the continuous state data
%%
%function FcnCsHStructDeclSystemIdx(cs) void
  %assign varGroupIdx = cs.VarGroupIdx[0]
  %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIdx]
  %return varGroup.SysIdx
%endfunction  
  
%% DocFunction{BlkStateAndWorkVectFcns}: LibBlockContinuousState ===============
%% Abstract:
%%   Returns a string corresponding to the specified block continuous state
%%   (CSTATE) element.
%%
%% See Also:
%%   LibBlockDiscreteState
%%
%function LibBlockContinuousState(ucv, lcv, idx) void
  %assign cs = ::CompiledModel.ContStates.ContState[ContStates[1]]

  %% Set use of floating-point types if integer only code
  %if PurelyIntegerCode
    %%START_ASSERT
    %<SLibCacheIntegerOnlyWarning(Name,"State")>
    %%END_ASSERT
  %endif

  %return SLibContinuousState(cs, ucv, lcv, idx, ...
    SLibGetHStructWithLocalScopeSystemIdx(FcnCsHStructDeclSystemIdx(cs)), CrossNoArgFcnBound)

%endfunction %% LibBlockContinuousState

%% Function FcnOwnerBlkType =============================================
%% Abstract:
%%   Given a data record, return the owner block type
%function FcnOwnerBlkType(rec) void
  %assign grBlockIndex = rec.GrSrc
  %assign grSubSys = ::CompiledModel.BlockHierarchyMap.Subsystem[grBlockIndex[0]]
  %assign grBlock  = grSubSys.Block[grBlockIndex[1]]
  %return grBlock.Type
%endfunction
  
%% Function
%% Function SLibContinuousState ================================================
%% Abstract:
%%   Returns a string corresponding to the specified continuous state element.
%%
%function SLibContinuousState(cs, ucv, lcv, idx, accSysIdx, cross) void

  %% ucv and empty index handling
  %if ucv != "" || TYPE(idx) != "Number"
    %assign idx = 0
  %endif

  %assign isMdlRef = FcnOwnerBlkType(cs) == "ModelReference"
  %if isMdlRef
    %% This is a structure 
    %assert(idx == 0)
  %endif
  
  %if ucv != "" || lcv == "" || (lcv != "" && cs.Width == 1)
    %assign varGroupIdx = cs.VarGroupIdx[0]
    %assign memberIdx = cs.VarGroupIdx[4]
    %assign vgIdx = SLibVarGroupCGTypeIdx(varGroupIdx)
    %assign memberCgTypeIdx = LibCGTypeMemberCGTypeIdx(vgIdx, memberIdx)
    %assign width = LibCGTypeWidth(memberCgTypeIdx)
    %return SLibCG_VarGroupElement(varGroupIdx, memberIdx, cross, accSysIdx, ...
      width, ucv, idx)
  %else
    %% rolling
    %assign sigIndexer = SLibGet1DArrayIndexer(cs.Width, ucv, lcv, idx)
    %return "xc%<sigIndexer>"
  %endif

%endfunction %% SLibContinuousState

%% SLibContinuousStateAddr ================================================
%%
%% This function provides special handling to access the continuous statesof
%% model reference blocks. For other blocks it is the same as adding "&" to
%% the front of value returned from LibBlockContinuousState
%%
%function SLibContinuousStateAddr(cs, mSysIdx) void

  %assign thisSys = ::CompiledModel.System[mSysIdx]
  
  %% Set use of floating-point types if integer only code
  %if PurelyIntegerCode
    %%START_ASSERT
    %<SLibCacheIntegerOnlyWarning(Name,"State")>
    %%END_ASSERT
  %endif

  %assign varGroupIdx = cs.VarGroupIdx[0]
  %assign accessSysIdx = SLibGetHStructWithLocalScopeSystemIdx(::CompiledModel.VarGroups.VarGroup[varGroupIdx].SysIdx)
  %if SLibIsMappedSystemInDeploymentDiagram(mSysIdx)
    %assign path = SLibCGIRVarGroupPath(varGroupIdx, mSysIdx, thisSys.CrossNoArgFcnBound)
  %else
    %assign path = SLibCGIRVarGroupPath(varGroupIdx, accessSysIdx, thisSys.CrossNoArgFcnBound)
  %endif
  %assign base = path + cs.Identifier
  %assign isMdlRef = FcnOwnerBlkType(cs) == "ModelReference"
  %if isMdlRef
    %assign blk = System[cs.SigSrc[0]].Block[cs.SigSrc[2]]
    %assign intrf = GetModelrefInterface(blk)
    %if intrf.xOptWidth > 1
      %assign base = base + "[0]"
    %endif
  %endif
  %if cs.Width == 1 || isMdlRef
    %assign base = "&(" + base + ")"
  %endif
  %return base
%endfunction %% SLibContinuousStateAddr

%% DocFunction{BlkStateAndWorkVectFcns}: LibBlockContinuousStateDerivative ====
%% Abstract:
%%   Returns a string corresponding to the specified block continuous state
%%   (CSTATE) element.
%%
%% See Also:
%%   LibBlockDiscreteState
%%
%function LibBlockContinuousStateDerivative(ucv, lcv, idx) void
  %assign cs = ::CompiledModel.ContStates.ContState[ContStates[1]]

  %% Set use of floating-point types if integer only code
  %if PurelyIntegerCode
    %<SLibCacheIntegerOnlyWarning(Name,"StateDerivatives")>
  %endif

  %return SLibContinuousStateDerivative(cs, ucv, lcv, idx)
%endfunction %% LibBlockContinuousStateDerivative


%% Function SLibContinuousStateDerivative ===========================
%% Abstract:
%%   Returns a string corresponding to the specified continuous state element.
%%
%function SLibContinuousStateDerivative(cs, ucv, lcv, idx) void
  
  %% ucv and empty index handling
  %if ucv != "" || TYPE(idx) != "Number"
    %assign idx = 0
  %endif


  %if ucv != "" || lcv == "" || (lcv != "" && cs.Width == 1)
    %assign varGroupIdx = cs.VarGroupIdx[2]
    %assign memberIdx = cs.VarGroupIdx[4]
    %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIdx]
    %assign sysIdx = varGroup.SysIdx
    %assign accSysIdx = SLibGetHStructWithLocalScopeSystemIdx(sysIdx)
    %assign cross = CrossNoArgFcnBound
    %assign vgIdx = SLibVarGroupCGTypeIdx(varGroupIdx)
    %assign memberCgTypeIdx = LibCGTypeMemberCGTypeIdx(vgIdx, memberIdx)
    %assign width = LibCGTypeWidth(memberCgTypeIdx)
    %return SLibCG_VarGroupElement(varGroupIdx, memberIdx, cross, accSysIdx, ...
      width, ucv, idx)
  %else
    %% rolling
    %assign sigIndexer = SLibGet1DArrayIndexer(cs.Width, ucv, lcv, idx)
    %return "xdot%<sigIndexer>"
  %endif
%endfunction %% SLibContinuousStateDerivative


%% Function SLibContinuousStateDerivativeAddr ==================================
%%
%function SLibContinuousStateDerivativeAddr(mSysIdx) void

  %assign cs = ::CompiledModel.ContStates.ContState[ContStates[1]]

  %% Set use of floating-point types if integer only code
  %if PurelyIntegerCode
    %%START_ASSERT
    %<SLibCacheIntegerOnlyWarning(Name,"StateDerivatives")>
    %%END_ASSERT
  %endif

  %assign varGroupIdx = cs.VarGroupIdx[2]
  %assign accessSysIdx = SLibGetHStructWithLocalScopeSystemIdx(::CompiledModel.VarGroups.VarGroup[varGroupIdx].SysIdx)
  %if SLibIsMappedSystemInDeploymentDiagram(mSysIdx)
    %assign path = SLibCGIRVarGroupPath(varGroupIdx, mSysIdx, CrossNoArgFcnBound)
  %else
    %assign path = SLibCGIRVarGroupPath(varGroupIdx, accessSysIdx, CrossNoArgFcnBound)
  %endif
  %assign base = path + cs.Identifier
  %assign isMdlRef = FcnOwnerBlkType(cs) == "ModelReference"
  %if isMdlRef
    %assign blk = System[cs.SigSrc[0]].Block[cs.SigSrc[2]]
    %assign intrf = GetModelrefInterface(blk)
    %if intrf.xOptWidth > 1
      %assign base = base + "[0]"
    %endif
  %endif
  %if (cs.Width == 1 || isMdlRef)
    %assign base = "&(" + base + ")"
  %endif
  %return base

%endfunction %% SLibContinuousStateDerivativeAddr


%% DocFunction{BlkStateAndWorkVectFcns}: LibBlockContStateDisabled ====
%% Abstract:
%%   Returns a string corresponding to the specified block continuous state
%%   (CSTATE) element.
%%
%% See Also:
%%   LibBlockDiscreteState
%%
%function LibBlockContStateDisabled(ucv, lcv, idx) void
  %assign cs = ::CompiledModel.ContStates.ContState[ContStates[1]]

  %% Set use of floating-point types if integer only code
  %if PurelyIntegerCode
    %<SLibCacheIntegerOnlyWarning(Name,"StateDisabled")>
  %endif

  %return SLibContStateDisabled(cs, ucv, lcv, idx)
%endfunction %% LibBlockContStateDisabled


%% Function SLibContStateDisabled ============================================
%% Abstract:
%%   Returns a string corresponding to the specified continuous state element.
%%
%function SLibContStateDisabled(cs, ucv, lcv, idx) void

  %% ucv and empty index handling
  %if ucv != "" || TYPE(idx) != "Number"
    %assign idx = 0
  %endif

  %if ucv != "" || lcv == "" || (lcv != "" && cs.Width == 1)
    %assign varGroupIdx = cs.VarGroupIdx[1]
    %assign memberIdx = cs.VarGroupIdx[4]
    %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIdx]
    %assign sysIdx = varGroup.SysIdx
    %assign accSysIdx = SLibGetHStructWithLocalScopeSystemIdx(sysIdx)
    %assign cross = CrossNoArgFcnBound
    %assign vgIdx = SLibVarGroupCGTypeIdx(varGroupIdx)
    %assign memberCgTypeIdx = LibCGTypeMemberCGTypeIdx(vgIdx, memberIdx)
    %assign width = LibCGTypeWidth(memberCgTypeIdx)
    %return SLibCG_VarGroupElement(varGroupIdx, memberIdx, cross, accSysIdx, ...
      width, ucv, idx)
  %else
    %% rolling
    %assign sigIndexer = SLibGet1DArrayIndexer(cs.Width, ucv, lcv, idx)
    %return "xdis%<sigIndexer>"
  %endif
%endfunction %% SLibContStateDisabled

%% Function SLibContStateDisabledAddr ==================================
%%
%function SLibContStateDisabledAddr(mSysIdx) void

  %assign cs = ::CompiledModel.ContStates.ContState[ContStates[1]]

  %% Set use of floating-point types if integer only code
  %if PurelyIntegerCode
    %%START_ASSERT
    %<SLibCacheIntegerOnlyWarning(Name,"StateDisabled")>
    %%END_ASSERT
  %endif

  %assign varGroupIdx = cs.VarGroupIdx[1]
  %assign accessSysIdx = SLibGetHStructWithLocalScopeSystemIdx(::CompiledModel.VarGroups.VarGroup[varGroupIdx].SysIdx)
  %if SLibIsMappedSystemInDeploymentDiagram(mSysIdx)
    %assign path = SLibCGIRVarGroupPath(varGroupIdx, mSysIdx, CrossNoArgFcnBound)
  %else
    %assign path = SLibCGIRVarGroupPath(varGroupIdx, accessSysIdx, CrossNoArgFcnBound)
  %endif
  %assign base = path + cs.Identifier
  %assign isMdlRef = FcnOwnerBlkType(cs) == "ModelReference"
  %if isMdlRef
    %assign blk = System[cs.SigSrc[0]].Block[cs.SigSrc[2]]
    %assign intrf = GetModelrefInterface(blk)
    %if intrf.xOptWidth > 1
      %assign base = base + "[0]"
    %endif
  %endif
  %if (cs.Width == 1 || Type == "ModelReference")
    %assign base = "&(" + base + ")"
  %endif
  %return base

%endfunction %% SLibContStateDisabledAddr

%% DocFunction{BlkStateAndWorkVectFcns}: LibBlockContStateAbsoluteTolerance ====
%% Abstract:
%%   Returns a string corresponding to the specified block continuous state
%%   (CSTATE) element.
%%
%function LibBlockContStateAbsoluteTolerance(ucv, lcv, idx) void
  %assign cs = ::CompiledModel.ContStates.ContState[ContStates[1]]

  %% Set use of floating-point types if integer only code
  %if PurelyIntegerCode
    %<SLibCacheIntegerOnlyWarning(Name,"StateAbsoluteTolerance")>
  %endif

  %return SLibContStateAbsoluteTolerance(cs, ucv, lcv, idx)
%endfunction %% LibBlockContStateAbsoluteTolerance


%% Function SLibContStateAbsoluteTolerance ============================================
%% Abstract:
%%   Returns a string corresponding to the specified continuous state absolute tolerance 
%%   element.
%%
%function SLibContStateAbsoluteTolerance(cs, ucv, lcv, idx) void

  %% ucv and empty index handling
  %if ucv != "" || TYPE(idx) != "Number"
    %assign idx = 0
  %endif

  %if ucv != "" || lcv == "" || (lcv != "" && cs.Width == 1)
    %assign varGroupIdx = cs.VarGroupIdx[3]
    %assign memberIdx = cs.VarGroupIdx[4]
    %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIdx]
    %assign sysIdx = varGroup.SysIdx
    %assign accSysIdx = SLibGetHStructWithLocalScopeSystemIdx(sysIdx)
    %assign cross = CrossNoArgFcnBound
    %assign vgIdx = SLibVarGroupCGTypeIdx(varGroupIdx)
    %assign memberCgTypeIdx = LibCGTypeMemberCGTypeIdx(vgIdx, memberIdx)
    %assign width = LibCGTypeWidth(memberCgTypeIdx)
    %return SLibCG_VarGroupElement(varGroupIdx, memberIdx, cross, accSysIdx, ...
      width, ucv, idx)
  %else
    %% rolling
    %assign sigIndexer = SLibGet1DArrayIndexer(cs.Width, ucv, lcv, idx)
    %return "xAbsTol%<sigIndexer>"
  %endif
%endfunction %% SLibContStateAbsoluteTolerance

%% Function SLibContStateAbsoluteToleranceAddr ==================================
%%
%function SLibContStateAbsoluteToleranceAddr(mSysIdx) void

  %assign cs = ::CompiledModel.ContStates.ContState[ContStates[1]]

  %% Set use of floating-point types if integer only code
  %if PurelyIntegerCode
    %%START_ASSERT
    %<SLibCacheIntegerOnlyWarning(Name,"StateAbsoluteTolerance")>
    %%END_ASSERT
  %endif

  %assign varGroupIdx = cs.VarGroupIdx[3]
  %assign accessSysIdx = SLibGetHStructWithLocalScopeSystemIdx(::CompiledModel.VarGroups.VarGroup[varGroupIdx].SysIdx)
  %if SLibIsMappedSystemInDeploymentDiagram(mSysIdx)
    %assign path = SLibCGIRVarGroupPath(varGroupIdx, mSysIdx, CrossNoArgFcnBound)
  %else
    %assign path = SLibCGIRVarGroupPath(varGroupIdx, accessSysIdx, CrossNoArgFcnBound)
  %endif
  %assign base = path + cs.Identifier
  %assign isMdlRef = FcnOwnerBlkType(cs) == "ModelReference"
  %if isMdlRef
    %assign blk = System[cs.SigSrc[0]].Block[cs.SigSrc[2]]
    %assign intrf = GetModelrefInterface(blk)
    %if intrf.xOptWidth > 1
      %assign base = base + "[0]"
    %endif
  %endif
  %if (cs.Width == 1 || Type == "ModelReference")
    %assign base = "&(" + base + ")"
  %endif
  %return base

%endfunction %% SLibContStateAbsoluteToleranceAddr


%function SLibBlockMassMatrixPrOffsetInternal(ucv, lcv, idx, dwIdx, dwRec, Pr0) void

  %% See Also:
  %%   LibBlockRWork, LibBlockIWork, LibBlockPWork
  %%

  %createrecord optionalArgs {}

  %with FcnLoopInfo(ucv, lcv, idx)
    %return FcnSimpleGetDWork(dwRec, dwIdx, Pr0, "massMatrixPr", optionalArgs)
  %endwith
%endfunction %% SLibBlockMassMatrixPrOffsetInternal


%% SLibBlockMassMatrixPrOffset ==========================
%% Abstract:
%%   Returns a string corresponding to the specified block MASS_MATRIX DWork element
%%
%function SLibBlockMassMatrixPrOffset(ucv, lcv, idx) void

  %% See Also:
  %%   LibBlockRWork, LibBlockIWork, LibBlockPWork
  %%

  %assign dwIdx = MassMatrixPr[1]
  %assign dwRec = ::CompiledModel.DWorks.DWork[dwIdx]
  
  %return SLibBlockMassMatrixPrOffsetInternal(ucv, lcv, idx, dwIdx, dwRec, MassMatrixPr[0])

%endfunction %% SLibBlockMassMatrixPrOffset


%% SLibBlockMassMatrixPr ==========================
%% Abstract:
%%   Returns a string corresponding to the specified block MassMatrixPr location
%%
%function SLibBlockMassMatrixPr() void
  %return "&(%<LibGetMassMatrixGlobalPr()>[%<SLibBlockMassMatrixPrOffset("", "", 0)>])" 
%endfunction


%% DocFunction{BlkStateAndWorkVectFcns}: LibBlockRWork =========================
%% Abstract:
%%   Returns a string corresponding to the specified block RWORK element.
%%
%%   The first argument, "definedrwork", would typically be a symbol defined
%%   in the mdlRTW() routine of the C MEX file with something like the code
%%   below.
%%
%%     ssWriteRTWWorkVect([...], "RWork", [...], "MyRWorkName", [...])
%%
%%  Alternately, if no such RWork defines have been made, "definedrwork" will
%%  be ignored and the raw RWork vector will be accessed.  In this case
%%  all uses in a loop rolling context are disallowed.
%%
%function LibBlockRWork(definedrwork, ucv, lcv, idx) void

  %% Set use of floating-point types if integer only code
  %if PurelyIntegerCode
    %%START_ASSERT
    %<SLibCacheIntegerOnlyWarning(Name,"WorkVector")>
    %%END_ASSERT
  %endif

  %with FcnLoopInfo(ucv, lcv, idx)
    %return FcnBlockXWork(definedrwork, RWork, NumRWorkDefines, "r")
  %endwith

%endfunction %% LibBlockRWork


%% DocFunction{BlkStateAndWorkVectFcns}: LibBlockIWork =========================
%% Abstract:
%%   Returns a string corresponding to the specified block IWORK element.
%%
%%   See LibBlockRWork().
%%
%function LibBlockIWork(definediwork, ucv, lcv, idx) void

  %with FcnLoopInfo(ucv, lcv, idx)
    %return FcnBlockXWork(definediwork, IWork, NumIWorkDefines, "i")
  %endwith

%endfunction %% LibBlockIWork


%% DocFunction{BlkStateAndWorkVectFcns}: LibBlockPWork =========================
%% Abstract:
%%   Returns a string corresponding to the specified block PWORK element.
%%
%%   See LibBlockRWork().
%%
%function LibBlockPWork(definedpwork, ucv, lcv, idx) void

  %with FcnLoopInfo(ucv, lcv, idx)
    %return FcnBlockXWork(definedpwork, PWork, NumPWorkDefines, "p")
  %endwith

%endfunction %% LibBlockPWork


%function FcnBlockXWork(definedxwork, XWork, NumXWorkDefines, XWorkVarNamePrefix) void

  %assign dwIdx = XWork[1]
  %assign dwRec = ::CompiledModel.DWorks.DWork[dwIdx]

  %if (NumXWorkDefines > 0)
    %assign rollName = XWorkVarNamePrefix + "w_" + definedxwork.Name
    %createrecord optionalArgs ...
    { ...
      StartIdx definedxwork.StartIndex; ...
      DotName  "." + definedxwork.Name  ...
    }
    %return FcnSimpleGetDWork(dwRec, dwIdx, definedxwork.Width, rollName, ...
                              optionalArgs)
  %else

    %% prevent loop rolling if XWork is not explicitly defined
    %if Lcv != ""
      %%START_ASSERT
      %setcommandswitch "-v1"
      %assign errTxt = "Don't know how to roll " + dwRec.Origin + " for " ...
	"%<Type> Block: %<LibGetFormattedBlockPath(block)>"
      %exit Simulink Coder Fatal: %<errTxt>
      %%END_ASSERT
    %endif

    %if TYPE(definedxwork) == "Scope"
      %createrecord optionalArgs { Name definedxwork.Name }
    %else
      %createrecord optionalArgs {}
    %endif
    %return FcnNonRollingDWork(dwRec, dwIdx, XWork[0], optionalArgs)

  %endif

%endfunction %% FcnBlockXWork


%% DocFunction{BlkStateAndWorkVectFcns}: LibBlockMode ==========================
%% Abstract:
%%   Returns a string corresponding to the specified block MODE element.
%%
%function LibBlockMode(ucv, lcv, idx) void

  %% See Also:
  %%   LibBlockRWork, LibBlockIWork, LibBlockPWork
  %%


  %assign dwIdx = ModeVector[1]
  %assign dwRec = ::CompiledModel.DWorks.DWork[dwIdx]
  %createrecord optionalArgs {}

  %with FcnLoopInfo(ucv, lcv, idx)
    %return FcnSimpleGetDWork(dwRec, dwIdx, ModeVector[0], "mode", optionalArgs)
  %endwith
%endfunction %% LibBlockMode

%% Function: FcnGetDworkRec ====================================================
%% Abstract:
%%  return data store memory's dwork record
%%
%function FcnGetDworkAndRec(DworkIn) void
  %%
  %% Dwork can be an identifier or a record. For simplicity, if it is an
  %% identifier, create a local record.
  %assign isRecord = TLC_TRUE
  %assign idNum    = ["",0]
  %assign interface = []

  %if TYPE(DworkIn) == "Identifier" || TYPE(DworkIn) == "String"
    %assign idNum = IDNUM(DworkIn) %%"di", "Di" or "dpi"
    %assign isRecord = TLC_FALSE
  %endif

  %if isRecord %% passed as record
    %assign dwork = DworkIn
    %if ISFIELD(dwork, "SigSrc") %% passed global DWork record
      %assign dwRec = dwork
    %else %% passed local block DWork record
      %assign dwIdx = dwork.FirstRootIdx
      %assign dwRec = ::CompiledModel.DWorks.DWork[dwIdx]
    %endif
  %else %% passed as 'Di', 'di', 'dpi' or 'db' string
    %if (idNum[0] == "d" || idNum[0] == "D" || idNum[0] == "db")
      %assign firstRootIdx =  idNum[1]
    %else %% dpi
      %% Get the relative index and convert it to the global index
      %assign relIdx        = idNum[1]
      %assign hStructSysIdx = System[SystemIdx].ReusedParentSystemIdx
      %assign interface     = System[hStructSysIdx].Interface
      %assign firstRootIdx  = interface.CanonicalDWorkArgDef[relIdx].FirstSignalSrc
    %endif
    %createrecord dwork { Name DworkIn; FirstRootIdx %<firstRootIdx>}
    %assign dwRec = ::CompiledModel.DWorks.DWork[firstRootIdx]
  %endif

  %createrecord dworkAndRec { DWork dwork; DWorkRec dwRec ; IsRecord isRecord ; IdNum idNum; Interface interface }
  %return dworkAndRec

%endfunction %% FcnGetDworkAndRec


%% Function: FcnGetDworkContentsOrAddress ======================================
%% Abstract:
%%   Returns a string corresponding to the contents or address of the
%%   specified dwork element. Dwork can be
%%     1- a record which contains two fields, i.e., Name and FirstRootIdx
%%        In this case, the Dwork is used by its owner, i.e., the dwork
%%        is local to the block.
%%     2- an identifier, i.e., di, Di or dpi, where
%%       Di   -> The block is accessing another block's dwork. The blocks
%%               are in the root system.
%%               ('i' is an index to the global dwork table)
%%       di   -> The block is accessing another block's dwork. The blocks
%%               are parented by the same reused system.
%%               ('i' is an index to the global dwork table)
%%       dpi  -> The block is parented by a reused system, and is accessing
%%               another block's dwork that is outside of the reused system.
%%               ('i' is a relative index to System's CanonicalDWork)
%%
%function FcnGetDworkContentsOrAddress(access, DworkIn, ucv, lcv, sigIdx) void

  %assign dworkAndRec = FcnGetDworkAndRec(DworkIn)
  %assign dwork = dworkAndRec.DWork
  %assign dwRec = dworkAndRec.DWorkRec
  %assign isRecord = dworkAndRec.IsRecord
  %assign idNum = dworkAndRec.IdNum
  %assign interface = dworkAndRec.Interface

  %% First split sigIdx into idx and reim
  %assign tmpVect = SLibGetReimAndIdx(sigIdx)
  %assign reim    = tmpVect[0]
  %assign idx     = tmpVect[1]

  %% The imaginary part of a non-complex dwork is ""
  %if !SLibDWorkIsComplex(dwRec) && reim == tImagPart
    %return ""
  %endif

  %% Check for floating-point types if integer only code
  %if PurelyIntegerCode
    %%START_ASSERT
    %assign dTypeId = LibGetDataTypeIdAliasedThruToFromId(SLibGetRecordDataTypeId(dwRec))
    %if dTypeId == tSS_DOUBLE || dTypeId == tSS_SINGLE
      %<SLibCacheIntegerOnlyWarning(Name,"WorkVector")>
    %endif
    %%END_ASSERT
  %endif

  %assign width = LibCGTypeWidth(LibGetRecordCGTypeIdx(dwRec))

  %assign sigIndexer = SLibGet1DArrayIndexer(width, ucv, lcv, idx)

  %assign hasCustomStorage = LibHasCustomStorage(dwRec)
  %assign pureSFcnTarget = (CodeFormat == "S-Function" && !Accelerator)
  %assign bAddr = ("address" == access)
    
  %if  ucv != "" || lcv == "" || (lcv != "" && width == 1)
    %% ucv specified, or not rolling, or rolling but scalar
    %if pureSFcnTarget
      %with FcnLoopInfo(ucv, lcv, idx)
	%assign answer = FcnGetGlobalDWork(dwRec, dwork.FirstRootIdx, width, 0)
      %endwith
    %else
      %if dwRec.StorageClass != "Auto" || SLibIsLegacyStorageClassForDataRecord(dwRec)
	%if hasCustomStorage
	  %if bAddr && !LibCustomDataIsAddressable(dwRec)
            %<SLibReportNonAddressableError("Dwork", thisBlock, dwRec)>
          %endif
	  %assign answer = LibCustomData(dwRec,access,sigIndexer,reim)
	  %return answer
	%else
	  %assign answer = LibGetRecordIdentifier(dwRec) + sigIndexer
	%endif
      %else
        %if EXISTS("BlockIdx") && ...
          BlockIdx[0] == dwRec.SigSrc[0] && BlockIdx[2] == dwRec.SigSrc[2]
          %assign thisBlock = SLibGetCurrentBlock()
          %if "Opaque" != thisBlock.Type
            %assign thisDWorkIdx = dwRec.SigSrc[3]
            %assert DworkIn.FirstRootIdx == ...
              thisBlock.DWork[thisDWorkIdx].FirstRootIdx
            %assert DworkIn.Name == thisBlock.DWork[thisDWorkIdx].Name
            %assign ident = SLibInvokeTLCInterface(thisBlock, ...
              "DWork", thisDWorkIdx, 0, bAddr, lcv, ucv, idx, reim)
            %assign tlcIFv2Enable = !ISEMPTY(ident)
            %if tlcIFv2Enable
              %return ident
            %endif
          %endif
        %endif
        %%
        %% 
        %%
        %assign cross = CrossNoArgFcnBound
	%if isRecord || idNum[0] == "d" || idNum[0] == "D"
          %if dwRec.IsLocalScratchDWork == 1
            %if dwRec.VarGroupVarIdx > -1              
              %assign varGroupIdx = ...
                ::CompiledModel.VarGroups.VarGroupVarIdx[dwRec.VarGroupVarIdx]
              %assign answer = SLibCG_GetVarGroupElementPath(varGroupIdx, ...
                SLibGetHStructWithLocalScopeSystemIdx(HStructDeclSystemIdx), cross) + sigIndexer
            %else
              %assign activeFcn = FcnGetActiveFcnForDecl()
              %assign declareInFcnScope = "DeclareIn%<activeFcn>FcnScope"
              %assign dwRec.%<declareInFcnScope> = 1
              %assign answer = LibGetRecordIdentifier(dwRec) + sigIndexer
            %endif
          %else
            %assign answer = SLibCG_GetVarGroupElementPath(dwRec.VarGroupIdx, ...
              SLibGetHStructWithLocalScopeSystemIdx(HStructDeclSystemIdx), cross) + sigIndexer
          %endif
	%else
	  %assign dworkArgDef = interface.CanonicalDWorkArgDef[idNum[1]]
	  %assign dworkArgDefId = LibGetRecordIdentifier(dworkArgDef)
          %if cross
            %<LibAccessGlobalArg(dworkArgDef)>
            %assign name = dworkArgDef.GlobalIdentifier

            %if width == 1
              %assign answer = "(*%<name>)"
            %else
              %assign answer = name + sigIndexer
            %endif

          %else
            %assert idNum[0] == "dp"
            %assign name = LibGetRecordIdentifier(dworkArgDef) %% canonical arg name

            %if width == 1
              %assign answer = "(*%<name>)"
            %else
              %assign answer = name + sigIndexer
            %endif
          %endif
	  %assign hStructSysIdx = System[SystemIdx].HStructDeclSystemIdx
	  %assign interface     = System[hStructSysIdx].Interface
          %with System[SystemIdx]
            %assign tid = FcnGetCurrentAccessTid()
          %endwith
	  %<SLibAccessArgHelper(dworkArgDef,"",tid)>
	%endif
      %endif
    %endif
  %else
    %% rolling
    %assign answer = "dw_%<dwork.Name>%<sigIndexer>"
  %endif

  %if SLibDWorkIsComplex(dwRec) && reim != ""
    %assign answer = answer + ".%<reim>"
  %endif

  %assign scalarIEP = ((dwRec.StorageClass == "ImportedExternPointer") && ...
                       (width == 1))
  %if bAddr && (!scalarIEP)
    %assign answer = "&" + answer
  %elseif ((access == "contents") && (scalarIEP) && (!pureSFcnTarget))
    %assign answer = "(*%<answer>)"
  %endif
  %return answer

%endfunction %% FcnGetDworkContentsOrAddress


%% DocFunction{BlkStateAndWorkVectFcns}: LibBlockDWorkAddr =====================
%% Abstract:
%%   Returns a string corresponding to the address of the specified block DWORK
%%   element.
%%
%function LibBlockDWorkAddr(dwork, ucv, lcv, idx) void

  %return FcnGetDworkContentsOrAddress("address", dwork, ucv, lcv, idx)

%endfunction %% LibBlockDWorkAddr


%% DocFunction{BlkStateAndWorkVectFcns}: LibBlockDWork =========================
%% Abstract:
%%   Returns a string corresponding to the specified block DWORK element.
%%
%%   Note, the last input argument is overloaded to handle complex DWorks:
%%
%%   sigIdx = "re3" => returns the real part of element 3 if the dwork is
%%                      complex, otherwise returns element 3.
%%   sigIdx = "im3" => returns the imaginary part of element 3 if the dwork
%%                      is complex, otherwise returns "".
%%   sigIdx = "3"   => returns the complex container of element 3, if
%%                     dwork is complex, otherwise returns element 3.
%%
%%   If either ucv or lcv is specified (i.e. it is not equal to  "") then
%%   the index part of the last input argument (sigIdx) is ignored.
%%
%function LibBlockDWork(dwork, ucv, lcv, idx) void
  %return FcnGetDworkContentsOrAddress("contents", dwork, ucv, lcv, idx)
%endfunction %% LibBlockDWork


%% DocFunction{BlkStateAndWorkVectFcns}: LibBlockDWorkWidth ====================
%% Abstract:
%%   Returns the width of specified block DWORK.
%%
%function LibBlockDWorkWidth(dwork) void
  %assign cgTypeIdx = ISFIELD(dwork, "CGTypeIdx") ? dwork.CGTypeIdx : ...
    LibGetRecordCGTypeIdx(::CompiledModel.DWorks.DWork[dwork.FirstRootIdx])
  %return LibCGTypeWidth(cgTypeIdx)
%endfunction %% LibBlockDWorkWidth


%% Function: SLibDWorkWidth ================================================
%% Abstract:
%%   Returns width of dwork
%%
%function SLibDWorkWidth(dwRec) void
  %return LibCGTypeWidth(LibGetRecordCGTypeIdx(dwRec))
%endfunction %% SLibDWorkWidth


%% DocFunction{BlkStateAndWorkVectFcns}: LibBlockDWorkStorageClass =============
%% Abstract:
%%   Returns the storage class of specified block DWORK.
%%
%% Function: LibBlockDWorkStorageClass(dwork) void
%function LibBlockDWorkStorageClass(dwork) void
  %assign dwRec = ::CompiledModel.DWorks.DWork[dwork.FirstRootIdx]
  %return dwRec.StorageClass
%endfunction %% LibBlockDWorkStorageClass

%% DocFunction{BlkStateAndWorkVectFcns}: LibBlockDWorkStorageTypeQualifer ======
%% Abstract:
%%   Returns the storage type qualifier of specified block DWORK.
%%
%% Function: LibBlockDWorkStorageTypeQualifier(dwork) void
%function LibBlockDWorkStorageTypeQualifier(dwork) void
  %assign dwRec = ::CompiledModel.DWorks.DWork[dwork.FirstRootIdx]
  %return dwRec.StorageTypeQualifier
%endfunction %% LibBlockDWorkStorageTypeQualifier

%% DocFunction{BlkStateAndWorkVectFcns}: LibBlockDWorkDataTypeId ===============
%% Abstract:
%%   Returns the data type Id of specified block DWORK.
%%
%function LibBlockDWorkDataTypeId(dwork) void
  %assign dwRec = ::CompiledModel.DWorks.DWork[dwork.FirstRootIdx]
  %return SLibGetRecordDataTypeId(dwRec)
%endfunction %% LibBlockDWorkDataTypeId


%% Function: SLibDWorkDataTypeId ================================================
%% Abstract:
%%   Returns data type of dwork
%%
%function SLibDWorkDataTypeId(dwRec) void
  %return LibCGTypeToSLType(LibGetRecordCGTypeIdx(dwRec))
%endfunction %% SLibDWorkDataTypeId


%% DocFunction{BlkStateAndWorkVectFcns}: LibBlockDWorkDataTypeName =============
%% Abstract:
%%   Returns the data type name of specified block DWORK.
%%
%function LibBlockDWorkDataTypeName(dwork, reim) void
  %assign dwRec = ::CompiledModel.DWorks.DWork[dwork.FirstRootIdx]
  %return SLibGetRecordDataTypeName(dwRec, reim)
%endfunction %% LibBlockDWorkDataTypeName


%% DocFunction{BlkStateAndWorkVectFcns}: LibBlockDWorkIsComplex ================
%% Abstract:
%%   Returns 1 if the specified block DWORK is complex, returns 0 otherwise.
%%
%function LibBlockDWorkIsComplex(dwork) void
  %return LibCGTypeIsComplex(LibGetRecordCGTypeIdx(::CompiledModel.DWorks.DWork[dwork.FirstRootIdx]))
%endfunction %% LibBlockDWorkIsComplex


%% Function: SLibDWorkIsComplex ================================================
%% Abstract:
%%   Returns 1 if the specified DWORK record is complex, returns 0 otherwise.
%%
%function SLibDWorkIsComplex(dwRec) void
  %return LibCGTypeIsComplex(LibGetRecordCGTypeIdx(dwRec))
%endfunction %% SLibDWorkIsComplex


%% DocFunction{BlkStateAndWorkVectFcns}: LibBlockDWorkUsedAsDiscreteState ======
%% Abstract:
%%   Returns 1 if the specified block DWORK is used as a discrete state,
%%   returns 0 otherwise.
%%
%function LibBlockDWorkUsedAsDiscreteState(dwork) void
  %assign dwRec = ::CompiledModel.DWorks.DWork[dwork.FirstRootIdx]
  %return (dwRec.UsedAs == "DSTATE")
%endfunction %% LibBlockDWorkUsedAsDiscreteState


%% DocFunction{BlkStateAndWorkVectFcns}: LibBlockDWorkName =====================
%% Abstract:
%%   Returns the name of specified block DWORK.
%%
%function LibBlockDWorkName(dwork) void
  %return STRING(dwork.Name)
%endfunction %% LibBlockDWorkName


%% Function: SLibGetSystemAndCallSideIndex =====================================
%% Abstract:
%%   This function robustly determines the system and callsite index for a
%%   record considering the special nature of subsystem blocks.
%%
%function SLibGetSystemAndCallSideIndex(rec)
  %assign retVal = [-1, -1]
  %if ISFIELD(rec,"SysCsIdx") 
    %return rec.SysCsIdx
  %elseif rec.RecordType == "ModelParameter"
    %return rec.OwnerSysIdx
  %else
    %assign varGroup = ::CompiledModel.VarGroups.VarGroup[rec.VarGroupIdx[0]]
    %assign retVal[0] = varGroup.SysIdx
    %assign retVal[1] = varGroup.InstanceIdx
    %return retVal
  %endif
%endfunction

%%adzc

%% Function: LibBlockPrevZCSignalState ===============================================
%% Abstract:
%%   LibBlockPrevZCSignalState returns the appropriate element for the previous
%%   zero crossing event based on ucv, lcv, and zcsIdx, zcElIdx
%%
%%   Arguments:
%%        ucv: User control variable string
%%        lcv: Loop control variable string
%%        zcsIdx : which zcSignal 
%%        zcElIdx : idx of zcSignalElement in the zcSignal
%%
%function LibBlockPrevZCSignalState(ucv, lcv, zcsIdx, zcElIdx) void  
  
  %assign blkZcRecIdx = BlkZcRec.BlkZcRecIdx
  %assign zcs = ::CompiledModel.ZcRec.BlkZcRec[blkZcRecIdx].ZcSignalInfo[zcsIdx]
  %return SLibPrevZCSignalState(zcs, ucv, lcv, zcsIdx, zcElIdx)
  
%endfunction %% LibBlockPrevZCSignalState

%% Function: FcnGetZCEventCGVarName ==================================================
%% Abstract:
%%   Returns the name of CG::Var for ZCEvent corresponding to zcsInfo
%%
%function FcnGetZCEventCGVarName(zcsInfo) void
  %assign varGroupIdx = zcsInfo.VarGroupIdx[0]
  %assign memberIdx   = zcsInfo.VarGroupIdx[1]
  %return SLibCGVarGroupMemberName(varGroupIdx, memberIdx)
%endfunction

%% Function: FcnGetZCSignalCGVarName =================================================
%% Abstract:
%%  Returns the name of CG::Var for continuous ZC corresponding to zcsInfo
%%
%function FcnGetZCSignalCGVarName(zcsInfo) void
  %assign varGroupIdx = zcsInfo.VarGroupIdx[2]
  %assign memberIdx   = zcsInfo.VarGroupIdx[3]
  %return SLibCGVarGroupMemberName(varGroupIdx, memberIdx)
%endfunction

%% Function: FcnGetZCEventCGVarWidth =================================================
%% Abstract:
%%   Returns the width of CG::Var for ZCEvent corresponding to zcsInfo
%%
%function FcnGetZCEventCGVarWidth(zcsInfo) void
  %assign varGroupIdx = zcsInfo.VarGroupIdx[0]
  %assign memberIdx   = zcsInfo.VarGroupIdx[1]
  %assign cgTypeIdx   = SLibCGVarGroupMemberCGTypeIdx(varGroupIdx, memberIdx)
  %return LibCGTypeWidth(cgTypeIdx)
%endfunction

%% Function: FcnGetZCSignalCGVarWidth ================================================
%% Abstract:
%%   Returns the width of CG::Var for continuous ZC corresponding to zcsInfo
%%
%function FcnGetZCSignalCGVarWidth(zcsInfo) void
  %assign varGroupIdx = zcsInfo.VarGroupIdx[2]
  %assign memberIdx   = zcsInfo.VarGroupIdx[3]
  %assign cgTypeIdx   = SLibCGVarGroupMemberCGTypeIdx(varGroupIdx, memberIdx)
  %return LibCGTypeWidth(cgTypeIdx)
%endfunction

%% Function: SLibPrevZCSignalState ===================================================
%% Abstract:
%%   SLibPrevZCSignalState returns the appropriate identifier for the previous
%%   zero crossing event based on the zcsignal record ucv, lcv, and pzcIdx.
%%
%%   Arguments:
%%        zcs: zcSignal record
%%        ucv: User control variable string
%%        lcv: Loop control variable string
%%        zcElIdx: idx of zcSignalElement in the zcSignal
%function SLibPrevZCSignalState(zcs, ucv, lcv, zcsIdx, zcElIdx) void
  %assign  blkZcRecIdx = zcs.BlkZcRecIdx
  %assign  blkZcRec = ::CompiledModel.ZcRec.BlkZcRec[blkZcRecIdx]
  %assign  sigIndexer = SLibGet1DArrayIndexer(zcs.Width, ucv, lcv, zcElIdx)  
  %if ucv != "" || lcv == "" || (lcv != "" && zcs.Width == 1)
    %% user control variable specified, not rolling, or rolling a scalar
    %assign idxVec = SLibGetSystemAndCallSideIndex(blkZcRec)
    %assign sysIdx = idxVec[0]
    %assign varGroupIdx = zcs.VarGroupIdx[0]
    %assign zcPath = SLibCGIRVarGroupPath(...
      varGroupIdx, NonInlinedParentSystemIdx, System[NonInlinedParentSystemIdx].CrossNoArgFcnBound)
    %assign   name = FcnGetZCEventCGVarName(zcs)
    %return zcPath + name + sigIndexer
  %else
    %% rolling
    %return "pzc%<zcsIdx>" + sigIndexer
  %endif
%endfunction

%% DocFunction{BlkStateAndWorkVectFcns}: LibBlockZCSignalValue ================
%% Abstract:
%%   Returns a string corresponding to the specified block ZCSignalValue
%%
%%   LibBlockZCSignalValue returns the appropriate element for the 
%%   zero crossing state based on ucv, lcv, and zcsIdx.
%%
%%   Arguments:
%%        ucv: User control variable string
%%        lcv: Loop control variable string
%%        zcsIdx: zcsignal Idx
%%        zcElIdx: idx of zcSignalElement in the zcSignal
%%
%function LibBlockZCSignalValue(ucv, lcv, zcsIdx, zcElIdx) void
  %assign blkZcRecIdx = BlkZcRec[0].BlkZcRecIdx
  %assign zcs  = ::CompiledModel.ZcRec.BlkZcRec[blkZcRecIdx].ZcSignalInfo[zcsIdx]
  %return SLibZCSignalValueState(zcs, ucv, lcv, zcsIdx, zcElIdx)
%endfunction %% LibBlockZCSignalValue

%% Function: SLibZCSignalValueState ============================================
%% Abstract:
%%   SLibZCValueState returns the appropriate identifier for the zcsignal 
%%   vector based on the record ucv, lcv, and zcElIdx
%%
%%   Arguments
%%           zcs: global zcSignal record
%%           ucv: User control variable string
%%           lcv: Loop control variable string
%%       zcsIdx: zcSignalInfo record Idx
%%     zcElIdx : idx of zcSignalElement in the zcSignal
%%       
%%
%function SLibZCSignalValueState(zcs, ucv, lcv, zcsIdx, zcElIdx) void
  %assign  blkZcRecIdx = zcs.BlkZcRecIdx
  %assign  blkZcRec = ::CompiledModel.ZcRec.BlkZcRec[blkZcRecIdx]
  %assign  sigIndexer = SLibGet1DArrayIndexer(zcs.Width, ucv, lcv, zcElIdx)
  
  %if ucv != "" || lcv == "" || (lcv != "" && zcs.Width == 1)
    %% user control variable specified, not rolling, or rolling a scalar
    %assign idxVec = SLibGetSystemAndCallSideIndex(blkZcRec)
    %assign sysIdx = idxVec[0]
    %assign  csIdx = idxVec[1]
    %assign varGroupIdx = FcnSysVarGroupIndex(System[sysIdx], "ZCSV", csIdx)
    %assign cross = System[sysIdx].CrossNoArgFcnBound
    %assign zcPath = SLibCGIRVarGroupPath...
      (varGroupIdx, HStructDeclSystemIdx, cross)
    %assign   name = FcnGetZCSignalCGVarName(zcs)
    %return zcPath + name + sigIndexer
  %else
    %% rolling
    %return "zcsv%<zcsIdx>" + sigIndexer
  %endif
%endfunction

%% Function: SLibZCSignalValueAddr ==============================================
%%
%% Abstract:
%%  SLibZcSignalValueAddr 
%%
%%   Arguments zcsIdx
%%        
%%
%function SLibZCSignalValueAddr(zcsIdx) void
  %assign blkZcRecIdx       = BlkZcRec[0].BlkZcRecIdx
  %assign blkZcRec          = ::CompiledModel.ZcRec.BlkZcRec[blkZcRecIdx]
  %assign zcs               = blkZcRec.ZcSignalInfo[zcsIdx]
  %assign idxVec            = SLibGetSystemAndCallSideIndex(blkZcRec)
  %assign sysIdx            = idxVec[0]
  %assign csIdx             = idxVec[1]
  %assign declSysIdx        = HStructDeclSystemIdx
  %assign varGroupIdx       = zcs.VarGroupIdx[2]
  %assign path              = SLibCGIRVarGroupPath(...
    varGroupIdx, declSysIdx, System[sysIdx].CrossNoArgFcnBound)
  %assign base              = path + FcnGetZCSignalCGVarName(zcs)
  %assign blk               = System[sysIdx].Block[blkZcRec.SigSrc[2]]
  %if (TYPE(blk.Type) == "Identifier" && blk.Type == "ModelReference")
    %assign intrf = GetModelrefInterface(blk)
    %%if intrf.xOptWidth > 1
    %if intrf.zcOptWidth > 1 
      %assign base = base + "[0]"
    %endif
  %endif
  %if ((zcs.Width == 1) || Type == "ModelReference")
    %assign base = "&(" + base + ")"
  %endif
  %return base
  
%endfunction %% SLibZCSignalValueAddr

%%adzc


%% Function: LibBlockPortSampleTime ============================================
%%
%function LibBlockPortSampleTime(portTID)

    %if PortBasedSampleTimes != "yes"
      %<LibReportFatalError("LibBlockPortSampleTime called for block that does not have port-based sample times")>
    %endif

    %if TYPE(portTID) != "String"
      %<LibReportFatalError("Incorrect portTID argument")>
    %endif

    %% Assume case of "InputPortIdxI" or "OutputPortIdxI"
    %assign portLocAndIdx = IDNUM(portTID)
    %if SIZE(portLocAndIdx,1) == 2
      %if portLocAndIdx[1] >= 0
	%assign port = portLocAndIdx[1]
	%if portLocAndIdx[0] == "InputPortIdx" && port < NumDataInputPorts
	  %if InputPortSampleTimes[port] == rtInf && InputPortOffsetTimes[port] == rtInf
	    %return "constant"
	  %else
	    %return InputPortTIDs[port]
	  %endif
	%elseif portLocAndIdx[0]=="OutputPortIdx" && port < NumDataOutputPorts
	  %if OutputPortSampleTimes[port] == rtInf && OutputPortOffsetTimes[port] == rtInf
	    %return "constant"
	  %else
	    %return OutputPortTIDs[port]
	  %endif
	%else
	  %<LibReportFatalError("Incorrect portTID argument")>
	%endif
      %endif
    %else
      %<LibReportFatalError("Incorrect portTID argument")>
    %endif

%endfunction

%% DocFunction{Sample Time Functions}: LibBlockSampleTime ======================
%% Abstract:
%%   Returns the block's sample time. The returned value depends on the sample
%%   time classification of the block:
%%
%%      Block classification  Returned value
%%      --------------------  --------------
%%      Discrete blocks          A real number greater than zero,
%%                               the block's actual sample time
%%      Continuous blocks        0.0
%%      Triggered blocks        -1.0
%%      Constant blocks         -2.0
%%
%function LibBlockSampleTime(block) void
  %assign tid = block.TID
  %if TYPE(tid) == "Number"
    %return CAST("Real", ::CompiledModel.SampleTime[tid].PeriodAndOffset[0])
  %elseif ISEQUAL(tid, "triggered")
    %return -1.0
  %elseif ISEQUAL(tid, "constant")
    %return -2.0
  %else
    %%START_ASSERT
    %assign blockName = LibUnmangledPathName(Name)
    %setcommandswitch "-v1"
    %assign errTxt = "Cannot compute step size for TID=%<tid> in " ...
      "%<block.Type> Block: %<LibGetFormattedBlockPath(block)>"
    %exit Simulink Coder Fatal: %<errTxt>
    %%END_ASSERT
  %endif
%endfunction %% LibBlockSampleTime

%% DocFunction{Sample Time Functions}: LibSetVarNextHitTime ===================
%% Abstract:
%%   Generates code to set the next variable hit time. Blocks with
%%   variable sample time must call this function in their output functions.
%%
%function LibSetVarNextHitTime(block,tNext) void
  %assign tid = block.VarTsTID
  %if IsModelReferenceForASimstructBasedTarget()
    %assign idx = %<tid>
  %else
    %assign idx = CAST("Number", ::CompiledModel.SampleTime[tid].PeriodAndOffset[1])
  %endif
  %return RTMuSetIdxed("VarNextHitTime", "%<idx>", tNext)    
%endfunction %% LibSetVarNextHitTime

%% DocFunction{Sample Time Functions}: LibPortBasedSampleTimeBlockIsTriggered ==
%% Abstract:
%%  Determines if the port-based S-function block is triggered
%%
%function LibPortBasedSampleTimeBlockIsTriggered(block) void
    %assign tid = block.TID
    %if LibTriggeredTID(tid)
      %return 1
    %else
      %return 0
    %endif
%endfunction %% LibSetVarNextHitTime



%%
%% Special handling S-function target because we are accessing the XWork
%% as a 'flat' array (not a structure).
%%
%function FcnGetGlobalDWork(dwRec, dwIdx, width, startIdx) void
  %assign index = width == 1 ? ...
    "[%<startIdx>]" : ...
    SLibGet1DArrayIndexer(width, Ucv, Lcv, startIdx+Idx)
  %return SLibGetGlobalDWorkIdentifier(dwRec, dwIdx) + index
%endfunction


%%
%% Special handling S-function target because we are accessing the XWork
%% as a 'flat' array (not a structure).
%%
%% Returns address with ssGetDWork macro for S-function target of the form:
%%    ((real_T *) ssGetDWork(S, n))
%%
%function SLibGetGlobalDWorkIdentifier(dwRec, dwIdx) void
  %assign dtype = SLibGetRecordDataTypeName(dwRec, "")
  %% For S Function Targets, the dWIdx does not take into account DWorks 
  %% that are optimized away. Hence, using VarGroupIdx which is in sync
  %assign varGrpIdx = dwRec.VarGroupIdx[1]
  %assign macro = "ssGetDWork(%<SLibGetSimStruct()>, %<varGrpIdx>)"
  %return "((%<dtype>*) %<macro>)"
%endfunction


%function SLibGetNameOfExtModeActiveDWork() void
  %return "ExtModeActive"
%endfunction

%function SLibGetNameOfSubsysRanBCDWork() void
  %return "SubsysRanBC"
%endfunction


%function FcnNonRollingDWork(dwRec, dwIdx, width, optionalArgs) void

  %if !ISFIELD(optionalArgs,"StartIdx")
    %addtorecord optionalArgs StartIdx 0
  %endif
  %if !ISFIELD(optionalArgs,"DotName")
    %addtorecord optionalArgs DotName ""
  %endif
  %if !ISFIELD(optionalArgs,"Name")
    %addtorecord optionalArgs Name ""
  %endif

  %if CodeFormat == "S-Function" && !Accelerator
    %return FcnGetGlobalDWork(dwRec, dwIdx, width, optionalArgs.StartIdx)
  %else
    %if EXISTS("BlockIdx") && ...
      BlockIdx[0] == dwRec.SigSrc[0] && BlockIdx[2] == dwRec.SigSrc[2]
      %assign thisBlock = SLibGetCurrentBlock()
      %if "Opaque" != thisBlock.Type
        %assign thisDWorkIdx = dwRec.SigSrc[3]      
        %% tlcinterfacev2    
        %if ISEMPTY(optionalArgs.DotName)
          %assign ident = SLibInvokeTLCInterface(thisBlock, ...
            "DWork", thisDWorkIdx, 0, TLC_FALSE, Ucv, Lcv, Idx, "")
          %assign tlcIFv2Enable = !ISEMPTY(ident)
          %if tlcIFv2Enable      
            %return ident
          %endif
        %else
          %assign ident = SLibInvokeTLCInterface(thisBlock, ...
            "DWork", thisDWorkIdx, 0, TLC_FALSE, "", "", "", "")
          %assign tlcIFv2Enable = !ISEMPTY(ident)
          %if tlcIFv2Enable      
            %return ident + optionalArgs.DotName + ...
              SLibGet1DArrayIndexer(width, Ucv, Lcv, Idx)
          %endif
        %endif
      %endif
    %endif
    %assign idxVec = SLibGetSystemAndCallSideIndex(dwRec)
    %assign sysIdx = idxVec[0]
    %assign base = SLibCG_GetVarGroupElementPath(dwRec.VarGroupIdx, ...
      SLibGetHStructWithLocalScopeSystemIdx(HStructDeclSystemIdx), System[sysIdx].CrossNoArgFcnBound)    
    %return base + optionalArgs.DotName + ...
      SLibGet1DArrayIndexer(width, Ucv, Lcv, Idx)
  %endif
  
%endfunction

%function FcnSimpleGetDWork(dwRec, dwIdx, width, rollName, optionalArgs) void
    %if  Ucv != "" || Lcv == "" || (Lcv != "" && width == 1)
      %% Ucv specified, not rolling, or rolling but it's scalar
      %return FcnNonRollingDWork(dwRec, dwIdx, width, optionalArgs)
    %else
      %% rolling
      %return rollName + SLibGet1DArrayIndexer(width, Ucv, Lcv, Idx)
    %endif
%endfunction

%function FcnLoopInfo(ucv, lcv, idx) void
  %% Ucv and empty index handling
  %if ucv != "" || TYPE(idx) != "Number"
    %assign idx = 0
  %endif
  %createrecord LoopInfo { Ucv ucv; Lcv lcv; Idx idx }
  %return LoopInfo
%endfunction

%% LibBlockIsIndexZeroBased ====================================================
%% Abstract:
%%  Determines if the index mode of a block is "Zero-based"
%%
%function LibBlockIsIndexZeroBased(block) void
  %assign zeroBased = 0
  %with block
    %assign zeroBased = (EXISTS(IndexMode) && IndexMode ==  "Zero-based")
  %endwith
  %return zeroBased
%endfunction

%% LibBlockIsIndexOneBased ====================================================
%% Abstract:
%%  Determines if the index mode of a block is "One-based"
%%
%function LibBlockIsIndexOneBased(block) void
  %assign oneBased = 0
  %with block
    %assign oneBased = (EXISTS(IndexMode) && IndexMode ==  "One-based")
  %endwith
  %return oneBased
%endfunction

%% DocFunction{Output Signal Functions}: LibBlockOutputPortIndexMode ===========
%% Purpose
%%   Determines the index mode of a block's output port.
%%
%% Description
%%   If a block's output port has been set as an index port and its indexing base is
%%   marked as zero-based or one-based, this information gets written into the model.rtw
%%   file. This function queries the indexing base in order to branch to different code
%%   according to what the output port indexing base is.
%%
%% Returns
%%   "" for a non-index port, and "Zero-based" or "One-based" otherwise.
%%
%% Arguments
%%   block - block record
%%   idx - port index
%%
%% Example
%%   %if LibBlockOutputPortIndexMode(block, idx) == "Zero-based"
%%      ...
%%   %elseif LibBlockOutputPortIndexMode(block, idx) == "One-based"
%%      ...
%%   %else
%%      ...
%%   %endif
%%
%% See function in matlabroot/rtw/c/tlc/mw/blocklib.tlc.
%%
%function LibBlockOutputPortIndexMode(block, pidx) void
  %assign ret = ""
  %with block
    %assert (pidx >= 0 && pidx < NumDataOutputPorts)
    %if EXISTS(NumIndexOutputPorts)
      %foreach n = NumIndexOutputPorts
	%assign ip = IndexOutputPort[n]
	%if ip.PortIdx == pidx
	  %assign ret = ip.PortIndexMode
	%endif
      %endforeach
    %endif
  %endwith
  %return ret
%endfunction

%% DocFunction{Input Signal Functions}: LibBlockInputPortIndexMode ===========
%% Purpose
%%   Determines the index mode of a block's input port.
%%
%% Description
%%   If a block's input port has been set as an index port and its indexing base is
%%   marked as zero-based or one-based, this information gets written into the model.rtw
%%   file. This function queries the indexing base in order to branch to different code
%%   according to what the input port indexing base is.
%%
%% Returns
%%   "" for a non-index port, and "Zero-based" or "One-based" otherwise.
%%
%% Arguments
%%   block - block record
%%   idx - port index
%%
%% Example
%%   %if LibBlockInputPortIndexMode(block, idx) == "Zero-based"
%%      ...
%%   %elseif LibBlockInputPortIndexMode(block, idx) == "One-based"
%%      ...
%%   %else
%%      ...
%%   %endif
%%
%% See function in matlabroot/rtw/c/tlc/mw/blocklib.tlc.
%%
%function LibBlockInputPortIndexMode(block, pidx) void
  %assign ret = ""
  %with block
    %assert (pidx >= 0 && pidx < NumDataInputPorts)
    %if EXISTS(NumIndexInputPorts)
      %foreach n = NumIndexInputPorts
	%assign ip = IndexInputPort[n]
	%if ip.PortIdx == pidx
	  %assign ret = ip.PortIndexMode
	%endif
      %endforeach
    %endif
  %endwith
  %return ret
%endfunction

%% DocFunction{Input Signal Functions}: LibBlockNumInputPorts ===================
%% Abstract:
%%   Returns the number of data input ports of a block (excludes control
%%   ports)
%%
%% Function: LibBlockNumInputPorts(block) void
%function LibBlockNumInputPorts(block) void
  %return block.NumDataInputPorts
%endfunction

%% DocFunction{Output Signal Functions}: LibBlockNumOutputPorts =================
%% Abstract:
%%   Returns the number of data output ports of a block (excludes control
%%   and state ports)
%%
%% Function: LibBlockNumOutputPorts(block) void
%function LibBlockNumOutputPorts(block) void
  %return block.NumDataOutputPorts
%endfunction

%endif %% _BLOCKLIB_

%% LibBlockDWorkOwnerComment ===================================================
%% Abstract:
%%   Return the owner of the dwork in a form suitable for a comment
%function LibBlockDWorkOwnerComment(dwRec) void
  %% If the graphical source is synthesized but the dwork has an object
  %% report the object
  %if dwRec.GrSrc[1] == -1
    %if dwRec.HasObject 
      %if !ISEMPTY(dwRec.OrigIdentifier)
        %assign id = dwRec.OrigIdentifier
      %else
        %assign id = LibGetRecordIdentifier(dwRec)
      %endif
      %return "Simulink.Signal object '%<id>'"
    %else
      %return "synthesized block"
    %endif
  %% Else call SLibGrBlockName()
  %else
    %return "'" + SLibGrBlockCommentName(dwRec.GrSrc) + "'"
  %endif
%endfunction

%% SLibBlockFcnRateGroupingCmpl ==================================
%% Abstract:
%%   Return true if function of block is rate grouped.
%% 
%function SLibBlockFcnRateGrouping(block,locFcnType) 
  %assign fcnName = locFcnType + "ForTID"
  %with block
    %assign tid = FcnEffectiveTid(block)
    %assign numTIDs = TYPE(tid) == "Vector" ? SIZE(tid,1) : 1
    %assign retVal =  (numTIDs>1 || SLibNonInlinedModelWideEventTID(tid)) && ...
      LibBlockFunctionExists(block, fcnName)
  %endwith 
  %return retVal  

%endfunction

%% SLibBlkHasMultirateCode(block) ==============================
%% Abstract:
%%   Return true if this block is more than one rate that may
%% have code
%function SLibBlkHasMultirateCode(block)
  %with block
    %assign blkHasMultirateCode = -1
    %assign tmpBufferHasDumpedForTID0 = TLC_FALSE
    
    %if TYPE(TID) == "Vector"
      %assign tid01Eq = ISEQUAL(SolverType, "FixedStep") && FixedStepOpts.TID01EQ
      %foreach tid = SIZE(TID,1)
	%if TYPE(tid) == "Number" && tid > 0
	  %% For tid01Eq=1, no code for tid1
	  %if tid01Eq && (tid == 1)
	    %continue
	  %endif
	  %assign blkHasMultirateCode = blkHasMultirateCode + 1
	%elseif !tmpBufferHasDumpedForTID0
	  %assign blkHasMultirateCode = blkHasMultirateCode + 1
	  %assign tmpBufferHasDumpedForTID0 = TLC_TRUE
	%endif
	%if blkHasMultirateCode == 1
	  %break
	%endif
      %endforeach
    %endif
  %endwith
  
  %return blkHasMultirateCode > 0
%endfunction

%% Function: SLibGetGlobalDWorkAddr ============================================
%% Abstract:
%%   Returns the global base address for a given global DWork element.
%%
%function SLibGetGlobalDWorkAddr(dwIdx, cross) void
  %assign sigAddr = ""
  %assign dw = ::CompiledModel.DWorks.DWork[dwIdx]
  %if ISFIELD(dw, "FirstRootIdx")
    %assign dw.FirstRootIdx = dwIdx
  %else
    %addtorecord dw FirstRootIdx dwIdx
  %endif
  %assign width = LibGetRecordWidth(dw)
  %if ISFIELD(dw,"VarGroupIdx")
    %assign varGroupIdx = ::CompiledModel.DWorks.DWork[dwIdx].VarGroupIdx[0]
    %assign memberIdx = ::CompiledModel.DWorks.DWork[dwIdx].VarGroupIdx[1]
    %return SLibCGIRDWorkGlobalCGVarBaseAddr(varGroupIdx, memberIdx, cross)
  %else
    %assert dw.StorageClass != "Auto"
    %if LibGetRecordIsComplex(dw)
      %assign indexExpr = "re0"
    %else
      %assign indexExpr = "0"
    %endif
    %if dw.StorageClass == "Custom"
      %return SLibCG_CSCDWAddr(dwIdx, width, "", -1, "", indexExpr)
    %else
      %return SLibCG_VAddr(LibGetRecordIdentifier(dw), ...
        dw.StorageClass == "ImportedExternPointer" && (width == 1), width, "", -1, "", indexExpr)
    %endif
  %endif
%endfunction

%%adzc

%% Function: SLibBlockGetZCSignalIndexFromNSZCIdx ============================================
%% Abstract:
%%   Returns zcSignalIdx 
%%
%function SLibBlockGetZCSignalIndexFromNSZCIdx(recIdx, NonSampledZCIdx) Output
  %assign blkZcRecIdx     = BlkZcRec[recIdx].BlkZcRecIdx
  %assign blkZcRec        = ::CompiledModel.ZcRec.BlkZcRec[blkZcRecIdx]
  %assign numZcSignals    = blkZcRec.NumZcSignalInfos 
  %%
  %assign numContZc = 0
  %foreach i = numZcSignals   
    %assign     zcs = blkZcRec.ZcSignalInfo[i]
    %assign zcsType = zcs.ZcSignalType
    %%
    %if zcsType == "Continuous"
      %assign numContZc = numContZc + zcs.Width    
    %elseif zcsType == "Hybrid"
      %foreach j = zcs.Width
        %if zcs.IsElementDisc[j] != 1
          %assign numContZc = numContZc + 1
        %endif
      %endforeach
    %endif
    %if numContZc >= NonSampledZCIdx + 1
      %return i
    %endif
  %endforeach
%endfunction %% SLibBlockGetZCSignalIndexFromNSZCIdx

%% Function: SLibBlockGetZCSignalElIndexFromNSZCIdx ============================================
%% Abstract:
%%   Returns zcSignalElement index
%%
%function SLibBlockGetZCSignalElIndexFromNSZCIdx( recIdx, NonSampledZCIdx) Output
  %assign blkZcRecIdx     = BlkZcRec[recIdx].BlkZcRecIdx
  %assign blkZcRec        = ::CompiledModel.ZcRec.BlkZcRec[blkZcRecIdx]
  %assign numZcSignals    = blkZcRec.NumZcSignalInfos
  %%
  %assign numContZc =0
  %foreach i = numZcSignals  
    %assign     zcs = blkZcRec.ZcSignalInfo[i]
    %assign zcsType = zcs.ZcSignalType
    %%
    %foreach j = zcs.Width
      %if zcsType == "Continuous"
        %assign numContZc = numContZc + 1
      %elseif zcsType == "Hybrid"
        %if zcs.IsElementDisc[j]!= 1
          %assign numContZc = numContZc + 1
        %endif
      %endif      
      %if numContZc == NonSampledZCIdx + 1
        %return j
      %endif
    %endforeach
  %endforeach
%endfunction %% SLibBlockGetZCSignalElIndexFromNSZCIdx

%%adzc
%% Function: SLibBlockGetZCSignalIndexFromZCEIdx ============================================
%% Abstract:
%%   Returns zcSignalIdx 
%%
%function SLibBlockGetZCSignalIndexFromZCEIdx(recIdx, ZCEIdx) Output
  %assign blkZcRecIdx     = BlkZcRec[recIdx].BlkZcRecIdx
  %assign blkZcRec        = ::CompiledModel.ZcRec.BlkZcRec[blkZcRecIdx]
  %assign numZcSignals    = blkZcRec.NumZcSignalInfos 
  %%
  %assign numZCEvent = 0
  %foreach i = numZcSignals   
    %assign     zcs = blkZcRec.ZcSignalInfo[i]
    %assign isEvent = zcs.NeedsEvent
    %%
    %if isEvent == 1
      %assign numZCEvent = numZCEvent + zcs.Width
    %endif    
    %if numZCEvent >= ZCEIdx + 1
      %return i
    %endif
  %endforeach
%endfunction %% SLibBlockGetZCSignalIndexFromZCEIdx

%% Function: SLibBlockGetZCSignalElIndexFromZCEIdx ============================================
%% Abstract:
%%   Returns zcSignalElement index
%%
%function SLibBlockGetZCSignalElIndexFromZCEIdx(recIdx, ZCEIdx) Output
  %assign blkZcRecIdx     = BlkZcRec[recIdx].BlkZcRecIdx
  %assign blkZcRec        = ::CompiledModel.ZcRec.BlkZcRec[blkZcRecIdx]
  %assign numZcSignals    = blkZcRec.NumZcSignalInfos
  %%
  %assign numZCEvent = 0
  %foreach i = numZcSignals   
    %assign     zcs = blkZcRec.ZcSignalInfo[i]
    %assign isEvent = zcs.NeedsEvent
    %%
    %if isEvent == 1
      %foreach j = zcs.Width
        %assign numZCEvent = numZCEvent + 1
        %if numZCEvent == ZCEIdx + 1
          %return j
        %endif
      %endforeach        
    %endif
  %endforeach
%endfunction %% SLibBlockGetZCSignalElIndexFromZCEIdx
%%adzc

%% [EOF] blocklib.tlc
