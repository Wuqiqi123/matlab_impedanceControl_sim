%%
%% Copyright 1994-2018 The MathWorks, Inc.
%%
%% Abstract: 
%%   This TLC library file contains all the code for generating system output
%%   code.
%%

%include "sysarglib.tlc"

%if EXISTS("_SYSLIB_") == 0
%assign _SYSLIB_ = 1

%%---------------------------------------------------------------%
%% FunctionRecord - record used for defining function prototypes %
%%---------------------------------------------------------------%
%%
%% Create a record for defining function prototypes.  The identifiers of
%% FcnRec are used as follows
%%
%%   Declaration: void foo(int_T tid);
%%   Call Syntax: foo(tid);
%%
%%   Name    = "foo"
%%   Returns = "void"
%%   Params  = "int_T tid"
%%   Args    = "tid"

%assign FunctionRecord = FcnRec\
  {\
    Name       "";\
    Returns    "";\
    Params     "";\
    CommonPrms "";\
    CommonArgs ""\
  }

%% Function: FcnResetFunctionRecord ============================================
%% Abstract:
%%    A routine to reset the function record.
%%
%function FcnResetFunctionRecord() void
  %assign ::FcnRec.Name       = ""
  %assign ::FcnRec.Returns    = ""
  %assign ::FcnRec.Params     = ""
  %assign ::FcnRec.CommonPrms = ""
  %assign ::FcnRec.CommonArgs = "" 
%endfunction

%% Function: FcnAddArgument ====================================================
%% Abstract:
%%   Add an argument to the parameter and argument fields of the FcnRec
%%   record.
%%
%%   Arguments:
%%     type: the type for the argument
%%      var: the variable name for the argument
%%
%function FcnAddArgument(type, var, arg) void
  %if !WHITE_SPACE(::FcnRec.Params)
    %assign comma  = ", "
  %else
    %assign comma = ""
  %endif
  %assign dataDef = type + var
  %assign ::FcnRec.Params     = ::FcnRec.Params + comma + dataDef
  %assign ::FcnRec.CommonArgs = ::FcnRec.CommonArgs + comma + arg
%endfunction


%% Function: FcnAddArgumentWithCompilerAbstraction ==============================
%% Abstract:
%%   Add an argument to the parameter and argument fields of the FcnRec
%%   record with AUTOSAR compiler abstraction macros
%%
%%   Arguments:
%%     type: the type for the argument
%%      var: the variable name for the argument
%%
%function FcnAddArgumentWithCompilerAbstraction(isConst, datatype, isPtr, ptrIsConst, var, arg) void
  %if !WHITE_SPACE(::FcnRec.Params)
    %assign comma  = ", "
  %else
    %assign comma = ""
  %endif
  %assign dataDef = SLibAutosarCompilerAbstractionForDataDecl(isConst, datatype, isPtr, ptrIsConst, var, "DataAutomatic")
  %assign ::FcnRec.Params     = ::FcnRec.Params + comma + dataDef
  %assign ::FcnRec.CommonArgs = ::FcnRec.CommonArgs + comma + arg
%endfunction

%% Function: FcnAddParameter ===================================================
%% Abstract:
%%   Add an argument definition to the parameter field of the FcnRec record.
%%
%%   Arguments:
%%     type: the type for the argument definition
%%      var: the variable name for the argument definition
%%
%function FcnAddParameter(type, var) void
  %if !WHITE_SPACE(::FcnRec.Params)
    %assign comma = ", "
  %else
    %assign comma = ""
  %endif
  %assign dataDef = type + var
  %assign ::FcnRec.Params = ::FcnRec.Params + comma + dataDef
%endfunction

%function FcnPrependParameter(type, var) void
  %if !WHITE_SPACE(::FcnRec.Params)
    %assign comma = ", "
  %else
    %assign comma = ""
  %endif
  %assign dataDef = type + var
  %assign ::FcnRec.Params = dataDef + comma + ::FcnRec.Params
%endfunction

%% Function: FcnAddParameterWithCompilerAbstraction =============================
%% Abstract:
%%   Add an argument definition to the parameter field of the FcnRec record.
%%
%%   Arguments:
%%     type: the type for the argument definition
%%      var: the variable name for the argument definition
%%
%function FcnAddParameterWithCompilerAbstraction(isConst, datatype, isPtr, var) void
  %if !WHITE_SPACE(::FcnRec.Params)
    %assign comma = ", "
  %else
    %assign comma = ""
  %endif
  %assign dataDef = SLibAutosarCompilerAbstractionForDataDecl(isConst, datatype, isPtr, TLC_FALSE, var, "DataAutomatic")
  %assign ::FcnRec.Params = ::FcnRec.Params + comma + dataDef
%endfunction

%% Function: FcnPassCanonicalInputByPtr ========================================
%% Abstract:
%%   Return whether a canonical input should be passed by pointer
%function FcnPassCanonicalInputByPtr(ci)
  %return ci.DeclareAsPointer == "yes"
%endfunction

%% Function: FcnPassCanonicalInputAsConst ======================================
%% Abstract:
%%   Return whether a canonical input should be passed using const
%%   qualifier
%function FcnPassCanonicalInputAsConst(sysIdx, ci)
  %if !IsBaseSystem(System[System[sysIdx].ReusedParentSystemIdx]) || (!SLibFcnProtoCtrlActive() && !GenerateClassInterface)
    %return FcnPassCanonicalInputByPtr(ci) || (LibGetRecordWidth(ci) > 1)
  %else
    %if ISFIELD(ci, "IsCustomConst")
      %return ci.IsCustomConst == "yes"
    %else
      %return TLC_FALSE
    %endif
  %endif
%endfunction

%function FcnPassExternalInputAsConst(ci)
  %if ISFIELD(ci, "IsCustomConst")
    %return ci.IsCustomConst == "yes"
  %else
    %return TLC_FALSE
  %endif
%endfunction
  
%% Function: FcnPassCanonicalOutputAsReference =================================
%% Abstract:
%%   Return whether a canonical output is passed by reference
%%   qualifier
%function FcnPassCanonicalOutputAsReference(co)
  %return co.DeclareAsReference == "yes"
%endfunction

%function SLibAccessThisArgGlobally(aArgDef, aFcnName) void
  %<SLibAccessThisSysFcnArgHelper(aArgDef, aFcnName, "Global", "", TLC_TRUE)>
  %<SLibAccessThisSysFcnArgHelper(aArgDef, aFcnName, "", "", TLC_TRUE)>
%endfunction

%% Function: SLibAccessMdlRefCanParam ==========================================
%% Abstract:
%%   Markes the parameter argument for aPrmIdx as accessed in a given model
%%   reference base system function (aFcnName).
%%
%function SLibAccessMdlRefCanParam(aPrmIdx, aFcnName) void
  %if IsModelRefScalableBuild()
    %assign baseSystem = ::CompiledModel.System[GetBaseSystemIdx()]
    %with baseSystem.Interface
      %assert aPrmIdx < NumCanonicalPrmArgDefs
      %assign canParamRecord = CanonicalPrmArgDef[aPrmIdx]
      %<SLibAccessThisArgGlobally(canParamRecord, aFcnName)>
    %endwith
  %endif
%endfunction

%% Function: SLibAccessMdlRefGlobals ===========================================
%% Abstract:
%%   This function marks model reference global argument definition records as 
%%   accessed, based on the virtual argument list created in IR.
%%
%function SLibAccessMdlRefGlobals(aFcn) void
  %if !IsModelRefScalableBuild()
    %return
  %endif
  %assign baseSystem = ::CompiledModel.System[GetBaseSystemIdx()]
  %with baseSystem.Interface
    %assign fcnName = aFcn.Name
    %foreach argIdx=aFcn.NumArgs
      %if aFcn.ArgAccessed[argIdx]
        %assign idNum = SLibSafeIDNUM(aFcn.ArgSource, argIdx)
        %assign argSrc = idNum[0]
        %assign argSrcIdx = idNum[1]
        %switch argSrc
          %case "I" %% canonical input
            %assign canInputRecord = CanonicalInputArgDef[argSrcIdx]
            %<SLibAccessThisArgGlobally(canInputRecord, fcnName)>
            %break
          %case "O" %% canonical output
            %assign canOutputRecord = CanonicalOutputArgDef[argSrcIdx]
            %<SLibAccessThisArgGlobally(canOutputRecord, fcnName)>
            %break
          %case "Y" %% root outport not being canonical output, occur in FPC only
            %break
          %case "Y" %% root outport not being canonical output, occur in FPC only
            %break
          %case "D" %% canonical dwork
            %assign canDWorkRecord = CanonicalDWorkArgDef[argSrcIdx]
            %<SLibAccessThisArgGlobally(canDWorkRecord, fcnName)>
            %break
          %case "P" %% canonical parameters
            %assign canParamRecord = CanonicalPrmArgDef[argSrcIdx]
            %<SLibAccessThisArgGlobally(canParamRecord, fcnName)>
            %break
          %case "RTM"
            %<SLibAccessThisArgGlobally(RTMArgDef, fcnName)>
            %break
          %case "LB" %% block IO
            %<SLibAccessThisArgGlobally(BlockIOArgDef, fcnName)>
            %break
          %case "LC" %% constat block IO
            %<SLibAccessThisArgGlobally(ConstBlockIOArgDef, fcnName)>
            %break
          %case "LW" %% dwork
            %<SLibAccessThisArgGlobally(DWorkArgDef, fcnName)>
            %break
          %case "LP"  %% parameter
          %case "LCP" %% constant parameter
          %case "LPI" %% const parameter with init
            %<SLibAccessThisArgGlobally(ParameterArgDef, fcnName)>
            %break
          %case "LX" %% continues states
            %<SLibAccessThisArgGlobally(ContStatesArgDef, fcnName)>
            %break
          %case "LDX" %% derivatives
            %<SLibAccessThisArgGlobally(ContStatesDerivativeArgDef, fcnName)>
            %break
          %case "LXDI" %% continues state disabled
            %<SLibAccessThisArgGlobally(ContStatesDisabledArgDef, fcnName)>
            %break
          %case "LXAT" %% continues state absolute tolerance
            %<SLibAccessThisArgGlobally(ContStatesAbsoluteToleranceArgDef, fcnName)>
            %break
          %case "LZ" %% non-sampled zero crossings
            %<SLibAccessThisArgGlobally(ZCSVArgDef, fcnName)>
            %break
          %case "LZE" %% zero crossing events
            %<SLibAccessThisArgGlobally(ZCEventArgDef, fcnName)>
            %break
          %case "LCDG"
          %case "CPI"
          %case "TID"
          %case "X"
          %case "U"
          %case "Y"
            %break
          %default
            %%START_ASSERT
            %assign errTxt = "Unhandled argument type '%<argSrc>'."
            %<LibBlockReportError([],errTxt)>
            %break
            %%END_ASSERT              
        %endswitch
      %endif
    %endforeach
  %endwith
%endfunction

%% Function: SLibAccessArgGlobally =============================================
%% Abstract:
%%   This function marks a argument of the current function as accessed
%%   globally.
%%
%function SLibAccessArgGlobally(arg, fcnName, accessTid, periodicRateGrouping) void
  %if periodicRateGrouping || SLibNonInlinedModelWideEventTID(accessTid)
    %<SLibAccessThisSysFcnArgHelper(arg, fcnName, "", accessTid, TLC_TRUE)>
    %<SLibAccessThisSysFcnArgHelper(arg, fcnName, "Global", accessTid, TLC_TRUE)>
  %else
    %<SLibAccessThisSysFcnArgHelper(arg, fcnName, "", "", TLC_TRUE)>
    %<SLibAccessThisSysFcnArgHelper(arg, fcnName, "Global", "", TLC_TRUE)>
  %endif
%endfunction

%% Function: SLibAccessArg =====================================================
%% Abstract:
%%   This function marks a argument of the current function as accessed
%%
%function SLibAccessArg(arg, fcnName, accessTid, periodicRateGrouping) void
  %if periodicRateGrouping || SLibNonInlinedModelWideEventTID(accessTid)
    %<SLibAccessThisSysFcnArgHelper(arg, fcnName, "", accessTid, TLC_FALSE)>
  %else
    %<SLibAccessThisSysFcnArgHelper(arg, fcnName, "", "", TLC_FALSE)>
  %endif
%endfunction

%% Function: FcnGetGroupArgDef
%% Abstract:
%%    Given a group index, returns the token "CoderDataGroup<x>ArgDef" where "x"
%%    is the group name
%function FcnGetGroupArgDef(groupIndex) void
  %assign group = ::CompiledModel.CoderDataGroup[groupIndex]
  %assign groupToken = "CoderDataGroup" + group.Name
  %assign argDef = %<groupToken + "ArgDef">
  %return argDef
%endfunction

%% Function: FcnAddParametersAndReturn =========================================
%% Abstract:
%%   This function adds the needed parameters and return to the function 
%%   prototype, e.g. "u0, u1, localB, ..."
%%   refer to GetFunctionStr for the order of parameters.
%%
%function FcnAddParametersAndReturn(sysFcn, fcnName, sysIdx, isRGSLF) void
  %assign thisSystem = ::CompiledModel.System[sysIdx]
  %assign thisModule = ...
    ::CompiledModel.RTWCGModules.RTWCGModule[thisSystem.CGIRModuleIdx]
  %assign hasReusableInterface = thisModule.SimplifiedInterface || SLibGetUseRTMcgType()
  %assign cTID = thisSystem.CurrentTID
  %% For async rate grouping, want arg access tracked by TID, so set isRG to true
  %assign isRG = SLibSystemFcnPeriodicRateGrouping(thisSystem, sysFcn) || ...
    SLibIsExplicitTaskingExportFcnRateGrouping(sysFcn, cTID)

  %if (sysFcn == "OutputUpdate") && SLibFcnProtoCtrlActive() && ...
    IsModelReferenceBaseSys(thisSystem)
    
    %assign FPC = FcnGetFunctionPrototypeRecord()
  %else  
    %assign FPC = []
  %endif
  %assign thisFcn  = []
  %if sysFcn == "OutputUpdate" && ...
      GenerateClassInterface && ...
      !LibAsynchronousTriggeredTID(cTID) && ...
      IsModelReferenceBaseSys(thisSystem)  && ...
      !(LibAsynchronousTriggeredTID(cTID) || SLibExplicitPeriodicInExportFcnDiagram(cTID))
    
    %assign FPC = FcnGetRTWCPPStepPrototypeRecord()
    
  %endif
  %assign hasFPC = !ISEMPTY(FPC)
  
  %with thisSystem.Interface
    %%
    %% The following TLC code is used to create the agrument defintions for
    %% CGIR function arguments and transfer the CGIR argument tracking 
    %% information to the legacy TLC tracking infrastructure.
    %%
    %%
    %% FPC uses a fixed argument set which doesn't need to be extended in TLC
    %% since the IR defenition is already complete. This is also true of
    %% rate grouped Simulink functions.
    %%
    %if hasFPC || isRGSLF
      %assign skipCanInput = ...
        Vector(%<NumCanonicalInputArgDefs>) [1@%<NumCanonicalInputArgDefs>]
      %assign skipCanOutput = ...
        Vector(%<NumCanonicalOutputArgDefs>) [1@%<NumCanonicalOutputArgDefs>]
    %else
      %assign skipCanInput = ...
        Vector(%<NumCanonicalInputArgDefs>) [0@%<NumCanonicalInputArgDefs>]
      %assign skipCanOutput = ...
        Vector(%<NumCanonicalOutputArgDefs>) [0@%<NumCanonicalOutputArgDefs>]
    %endif
    %assign skipCanDWork = ...
      Vector(%<NumCanonicalDWorkArgDefs>) [0@%<NumCanonicalDWorkArgDefs>]
    %assign skipCanParam = ...
      Vector(%<NumCanonicalPrmArgDefs>) [0@%<NumCanonicalPrmArgDefs>]
    %assign skipRTM = 0
    %assign skipHStructArgs = LibSystemIsNonReusedFcn(thisSystem)
    %assign skipLocalB = skipHStructArgs || hasReusableInterface
    %assign skipLocalC = skipHStructArgs
    %assign skipLocalDW = skipHStructArgs || hasReusableInterface
    %assign skipLocalP = skipHStructArgs || hasReusableInterface
    %assign skipLocalX = skipHStructArgs
    %assign skipLocalXdot = skipHStructArgs
    %assign skipLocalXdis = skipHStructArgs
    %assign skipLocalXabstol = skipHStructArgs
    %assign skipLocalZCSV = skipHStructArgs
    %assign skipLocalZCE = skipHStructArgs || hasReusableInterface

    %assign skipLocalDataGroup = ...
      Vector(%<::CompiledModel.NumCoderDataGroups>) [%<skipHStructArgs>@%<::CompiledModel.NumCoderDataGroups>]

    %if ISFIELD(thisModule, "SystemFunctions") && ...
      ISFIELD(thisModule.SystemFunctions, fcnName)
      %assign fcnIndex = GETFIELD(thisModule.SystemFunctions, fcnName)
      %assign thisFcn  = thisModule.Function[fcnIndex]
      %%
      %% Subfunction are fully defined in IR and do not use this infrastructure
      %%
      %if fcnIndex >= thisModule.NumSubFunctions
        %assign cgirParams = FEVAL("regexprep", thisFcn.ProtoType, "^[^\(]*\(", "")
        %if !ISEMPTY(cgirParams)
          %if !WHITE_SPACE(::FcnRec.Params)
            %assign ::FcnRec.Params = ::FcnRec.Params + "," + cgirParams
          %else
            %assign ::FcnRec.Params = ::FcnRec.Params + cgirParams
          %endif
          %if hasFPC && FPC.NumArgSpecData > 0 && ...
            FPC.ArgSpecData[0].SLObjectType == "Outport" && ...
            FPC.ArgSpecData[0].Category == "Value"
            %assign portIdx = FPC.ArgSpecData[0].PortNum
            %assign eo = ExternalOutputs.ExternalOutput[portIdx]
            %assign dataType = SLibGetRecordDataTypeName(eo, "")
            %assign ::FcnRec.Returns = dataType
          %endif
          %assign hasFPC = TLC_FALSE
          %assign FPC = []
        %endif
      %endif
      %assert SIZE(thisFcn.ArgAccessed, 1) == thisFcn.NumArgs
      %assert SIZE(thisFcn.ArgSource, 1) == thisFcn.NumArgs
      %%
      %% Transfer the access flags from exported graphical functions to entry 
      %% function model arguments, based on a call graph pattern 
      %% (MdlRefChildFcnNames) that has been pre computed in IR.
      %%
      %foreach childFcnIdx=SIZE(thisFcn.MdlRefChildFcnNames, 1)
        %assign childFcnName = thisFcn.MdlRefChildFcnNames[childFcnIdx]
        %foreach canInpIdx = NumCanonicalInputArgDefs
          %assign canInputRecord = CanonicalInputArgDef[canInpIdx]
          %if SysFcnArgNeeded(childFcnName, canInputRecord, cTID, isRG)
            %<SLibAccessArgGlobally(canInputRecord, sysFcn, cTID, isRG)>
          %endif
        %endforeach
        %foreach canOutpIdx = NumCanonicalOutputArgDefs
          %assign canOutputRecord = CanonicalOutputArgDef[canOutpIdx]
          %if SysFcnArgNeeded(childFcnName, canOutputRecord, cTID, isRG)
            %<SLibAccessArgGlobally(canOutputRecord, sysFcn, cTID, isRG)>
          %endif
        %endforeach
        %foreach canDwIdx = NumCanonicalDWorkArgDefs
          %assign canDWorkRecord = CanonicalDWorkArgDef[canDwIdx]
          %if SysFcnArgNeeded(childFcnName, canDWorkRecord, cTID, isRG)
            %<SLibAccessArgGlobally(canDWorkRecord, sysFcn, cTID, isRG)>
          %endif
        %endforeach
        %foreach canPrmIdx = NumCanonicalPrmArgDefs
          %assign canPrmRecord = CanonicalPrmArgDef[canPrmIdx]
          %if SysFcnArgNeeded(childFcnName, canPrmRecord, cTID, isRG)
            %<SLibAccessArgGlobally(canPrmRecord, sysFcn, cTID, isRG)>
          %endif
        %endforeach
        %if SysFcnArgNeeded(childFcnName, RTMArgDef, cTID, isRG)
          %<SLibAccessArgGlobally(RTMArgDef, sysFcn, cTID, isRG)>
        %endif
        %%
        %if SysFcnArgNeeded(childFcnName, BlockIOArgDef, cTID, isRG)
          %<SLibAccessArgGlobally(BlockIOArgDef, sysFcn, cTID, isRG)>
        %endif
        %if SysFcnArgNeeded(childFcnName, ConstBlockIOArgDef, cTID, isRG)
          %<SLibAccessArgGlobally(ConstBlockIOArgDef, sysFcn, cTID, isRG)>
        %endif
        %if SysFcnArgNeeded(childFcnName, DWorkArgDef, cTID, isRG)
          %<SLibAccessArgGlobally(DWorkArgDef, sysFcn, cTID, isRG)>
        %endif
        %if SysFcnArgNeeded(childFcnName, ParameterArgDef, cTID, isRG)
          %<SLibAccessArgGlobally(ParameterArgDef, sysFcn, cTID, isRG)>
        %endif
        %if SysFcnArgNeeded(childFcnName, ContStatesArgDef, cTID, isRG)
          %<SLibAccessArgGlobally(ContStatesArgDef, sysFcn, cTID, isRG)>
        %endif
        %if SysFcnArgNeeded(childFcnName, ContStatesDerivativeArgDef, cTID, isRG)
          %<SLibAccessArgGlobally(ContStatesDerivativeArgDef, sysFcn, cTID, isRG)>
        %endif
        %if SysFcnArgNeeded(childFcnName, ContStatesDisabledArgDef, cTID, isRG)
          %<SLibAccessArgGlobally(ContStatesDisabledArgDef, sysFcn, cTID, isRG)>
        %endif
        %if SysFcnArgNeeded(childFcnName, ContStatesAbsoluteToleranceArgDef, cTID, isRG)
          %<SLibAccessArgGlobally(ContStatesAbsoluteToleranceArgDef, sysFcn, cTID, isRG)>
        %endif
        %if SysFcnArgNeeded(childFcnName, ZCSVArgDef, cTID, isRG)
          %<SLibAccessArgGlobally(ZCSVArgDef, sysFcn, cTID, isRG)>
        %endif
        %if SysFcnArgNeeded(childFcnName, ZCEventArgDef, cTID, isRG)
          %<SLibAccessArgGlobally(ZCEventArgDef, sysFcn, cTID, isRG)>
        %endif
        %% Handling of data groups
        %foreach gIdx = ::CompiledModel.NumCoderDataGroups
          %assign argDef = FcnGetGroupArgDef(gIdx)
          %if SysFcnArgNeeded(sysFcn, argDef, cTID, isRG)
            %<SLibAccessArgGlobally(argDef, sysFcn, cTID, isRG)>
          %endif
        %endforeach

        %%
      %endforeach
      %%
      %foreach argIdx=thisFcn.NumArgs
        %if thisFcn.ArgAccessed[argIdx]
          %assign idNum = SLibSafeIDNUM(thisFcn.ArgSource, argIdx)
          %assign argSrc = idNum[0]
          %assign argSrcIdx = idNum[1]
          %switch argSrc
            %case "I" %% canonical input
              %if 0 < NumCanonicalInputArgDefs && !isRGSLF %% CrossNoArgFcnBound
                %assign skipCanInput[argSrcIdx] = 1
                %assign canInputRecord = CanonicalInputArgDef[argSrcIdx]
                %<SLibAccessArg(canInputRecord, sysFcn, cTID, isRG)>
              %endif
              %break
            %case "O" %% canonical output
              %if 0 < NumCanonicalOutputArgDefs && !isRGSLF %% CrossNoArgFcnBound
                %assign skipCanOutput[argSrcIdx] = 1
                %assign canOutputRecord = CanonicalOutputArgDef[argSrcIdx]
                %<SLibAccessArg(canOutputRecord, sysFcn, cTID, isRG)>
              %endif
              %break
            %case "D" %% canonical dwork
              %if 0 < NumCanonicalDWorkArgDefs %% CrossNoArgFcnBound
                %assign skipCanDWork[argSrcIdx] = 1
                %assign canDWorkRecord = CanonicalDWorkArgDef[argSrcIdx]
                %<SLibAccessArg(canDWorkRecord, sysFcn, cTID, isRG)>
              %endif
              %break
            %case "P" %% canonical parameters
              %if 0 < NumCanonicalPrmArgDefs && !isRGSLF %% CrossNoArgFcnBound
                %assign skipCanParam[argSrcIdx] = 1
                %assign canParamRecord = CanonicalPrmArgDef[argSrcIdx]
                %<SLibAccessArg(canParamRecord, sysFcn, cTID, isRG)>
              %elseif thisSystem.IsService || isRGSLF
                %%
                %% cache this parameter argument in model start
                %%
                %<SLibAccessMdlRefCanParam(argSrcIdx, "Start")>
              %endif
              %break
            %case "RTM"
              %assign skipRTM = 1
              %break
            %case "LCDG"
              %% Here, argSrcIdx refers to the index of the coder data group
              %if 0 == skipLocalDataGroup[argSrcIdx] %% CrossNoArgFcnBound
                %assign skipLocalDataGroup[argSrcIdx] = 1
                %assign argDef = FcnGetGroupArgDef(argSrcIdx)
                %<SLibAccessArg(argDef, sysFcn, cTID, isRG)>
              %endif
              %break
            %case "LB" %% block IO
              %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                %assign skipLocalB = 1
                %<SLibAccessArg(BlockIOArgDef, sysFcn, cTID, isRG)>
              %endif
              %break
            %case "LC" %% constat block IO
              %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                %assign skipLocalC = 1
                %<SLibAccessArg(ConstBlockIOArgDef, sysFcn, cTID, isRG)>
              %endif
              %break
            %case "LW" %% dwork
              %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                %assign skipLocalDW = 1
                %<SLibAccessArg(DWorkArgDef, sysFcn, cTID, isRG)>
              %endif
              %break
            %case "LP"  %% parameter
            %case "LCP" %% constant parameter
            %case "LPI" %% const parameter with init
              %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                %assign skipLocalP = 1
                %<SLibAccessArg(ParameterArgDef, sysFcn, cTID, isRG)>
              %endif
              %break
            %case "LX" %% continues states
              %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                %assign skipLocalX = 1
                %<SLibAccessArg(ContStatesArgDef, sysFcn, cTID, isRG)>
              %endif
              %break
            %case "LDX" %% derivatives
              %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                %assign skipLocalXdot = 1
                %<SLibAccessArg(ContStatesDerivativeArgDef, sysFcn, cTID, isRG)>
              %endif
              %break
            %case "LXDI" %% continues state disabled
              %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                %assign skipLocalXdis = 1
                %<SLibAccessArg(ContStatesDisabledArgDef, sysFcn, cTID, isRG)>
              %endif
              %break
            %case "LXAT" %% continues state absolute tolerance
              %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                %assign skipLocalXabstol = 1
                %<SLibAccessArg(ContStatesAbsoluteToleranceArgDef, sysFcn, cTID, isRG)>
              %endif
              %break
            %case "LZ" %% non-sampled zero crossings
              %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                %assign skipLocalZCSV = 1
                %<SLibAccessArg(ZCSVArgDef, sysFcn, cTID, isRG)>
              %endif
              %break
            %case "LZE" %% zero crossing events
              %if 0 == skipHStructArgs
                %assign skipLocalZCE = 1
                %<SLibAccessArg(ZCEventArgDef, sysFcn, cTID, isRG)>
              %endif
              %break
            %case "CPI"
            %case "TID"
            %case "X"
            %case "U"
            %case "Y" %% root outport not being canonical output, occur in FPC only
              %break
            %default
              %%START_ASSERT
              %assign errTxt = "Unhandled argument type '%<argSrc>'."
              %<LibBlockReportError([],errTxt)>
              %break
              %%END_ASSERT              
          %endswitch
        %endif
      %endforeach
    %endif

    %if !(GenerateClassInterface && SLibModelWideEventTID(cTID)) && ...
      (LibSystemIsReusedFcn(thisSystem) || ...
      (LibSystemIsNonReusedFcn(thisSystem) && ...
      ISFIELD(thisSystem,"RTWSystemCodeOptIntf")) || ...
      thisSystem.IsService)
      %assign useFPC = hasFPC && ISFIELD(FPC,"FunctionName")
      %if !useFPC
        %assign numArgs = NumCanonicalInputArgDefs + NumCanonicalOutputArgDefs
      %else
        %assign numArgs = FPC.NumArgSpecData
      %endif
      %assign isISSReuseDiffNumIters = SLibGetIsForEachSSReuseWithDiffNumIters(thisSystem) 
    
      %foreach argIdx = numArgs
        %if !useFPC
          %if argIdx < NumCanonicalInputArgDefs
            %assign portIdx = argIdx
            %assign SLObjectType = "Inport"
          %else
            %assign portIdx = argIdx - NumCanonicalInputArgDefs
            %assign SLObjectType = "Outport"
          %endif
        %else
          %assign portIdx = FPC.ArgSpecData[argIdx].PortNum
          %assign SLObjectType = FPC.ArgSpecData[argIdx].SLObjectType
        %endif
        %%
        %% Canonical input argument
        %%
        %if SLObjectType == "Inport"
          %if hasFPC || ...
            (!skipCanInput[portIdx] && ...
            SysFcnArgNeeded(sysFcn, CanonicalInputArgDef[portIdx], cTID, isRG))
            %assign skipThisArg = 0
            %if !hasFPC
              %assign ci = CanonicalInputArgDef[portIdx]
              %if ISFIELD(ci,"VarGroupIdx") && SLibGetDoesSelfExist() && SLibIsSelfStructured()
                %% accessed through rtm make sure instance specific rtm is added to definition
                %<SLibAccessArg(RTMArgDef,sysFcn, cTID, isRG)>
              %endif
              %if IDNUM(ci.SignalSrc[0])[0] == "F"
                %assign skipThisArg = 1
              %endif	
              %assign dataType = SLibGetRecordDataTypeName(ci, "")
              %assign width = LibGetRecordWidth(ci)
              %assign optWidth = LibOptionalVectorWidth(width)
            %else
              %assign ei = ExternalInputs.ExternalInput[portIdx]
              %assign dataType = SLibGetRecordDataTypeName(ei, "")
              %assign width = LibGetRecordWidth(ei)
              %assign optWidth = LibOptionalVectorWidth(width)
            %endif

            %if skipThisArg==0   
              %if !hasFPC
                %assign passByPtr = FcnPassCanonicalInputByPtr(ci)
                %assign passConst = FcnPassCanonicalInputAsConst(sysIdx, ci) || ...
                  (GenerateClassInterface && IsModelReferenceBaseSys(thisSystem) && passByPtr && sysFcn == "Start")
                %assign optConst = passConst ? "const " : ""
                %assign optStar  = passByPtr ? "*" : ""
                %if SLibGetCanIOIsVarDims(ci) || isISSReuseDiffNumIters && !ISEMPTY(optWidth)
                  %% Always pass pointer for var-dims signal or Implicit Iterator
                  %% subsystem reused for different number of iterations.
                  %assign argDef = " %<LibGetRecordIdentifier(ci)>[]"
                %else
                  %assign argDef = "%<optStar>%<LibGetRecordIdentifier(ci)>%<optWidth>"
                %endif
              %else
                %assign passByPtr = FPC.ArgSpecData[argIdx].Category == "Pointer" && width == 1
                %assign isReference = (FPC.ArgSpecData[argIdx].Category == "Reference")
                %assign qualifier = FPC.ArgSpecData[argIdx].Qualifier
                %assign argDef = ""
                %switch qualifier
                  %case "none"
                    %assign optConst = ""
                    %if passByPtr
                      %assign argDef = "*"
                    %elseif isReference
                      %assign argDef = "&"
                    %endif
                    %break
                  %case "const"
                    %assign optConst = "const "
                    %assign argDef = ""
                    %break
                  %case "const *"
                    %assign optConst = "const "
                    %if LibGetRecordWidth(ei) == 1
                      %assign argDef = "*"
                    %endif
                    %break
                  %case "const * const"
                    %assign optConst = "const "
                    %if LibGetRecordWidth(ei) == 1
                      %assign argDef = "*const "
                    %endif
                    %break
                  %case "const &"
                    %assign optConst = "const "
                    %assign argDef = "&"
                    %break
                  %default
                    %assign errTxt = "Unhandled qualifier"
                    %<LibReportFatalError(errTxt)>
                    %break
                %endswitch
                
                %if !ISEMPTY(optWidth) && isReference
                  %assign argDef = ...
                    "(%<argDef>%<FPC.ArgSpecData[argIdx].ArgName>)%<optWidth>"
                %else
                  %assign argDef = ...
                    "%<argDef>%<FPC.ArgSpecData[argIdx].ArgName>%<optWidth>"
                %endif
              %endif
              %if SLibAutosarCompilerAbstractionRequired()
                %if SLibGetCanIOIsVarDims(ci) || isISSReuseDiffNumIters
                  %assign argDef = "%<LibGetRecordIdentifier(ci)>[]"
                %else
                  %assign argDef = "%<LibGetRecordIdentifier(ci)>%<optWidth>"
                %endif
                %<FcnAddParameterWithCompilerAbstraction(passConst, dataType, passByPtr, argDef)>
              %elseif dataType != "fcn_call"
                %assign dataType = "%<optConst>%<dataType> "
                %<FcnAddParameter(dataType, argDef)>
              %endif
            %endif
            %% Add vardims argument for the canonical input 
            %<FcnAddNeededCanDimSizeDWForCanInp(sysFcn, sysIdx, portIdx, ...
              skipCanDWork)>
          %endif %% SysFcnArgNeeded
          
          %%
          %% Canonical output arguments
        %else
          %if hasFPC || ...
            (!skipCanOutput[portIdx] && ...
            SysFcnArgNeeded(sysFcn, CanonicalOutputArgDef[portIdx], cTID, isRG))
            %if !hasFPC
              %assign       co = CanonicalOutputArgDef[portIdx]
              %if ISFIELD(co,"VarGroupIdx") && SLibGetDoesSelfExist() && SLibIsSelfStructured()
                %% accessed through rtm make sure instance specific rtm is added to definition
                %<SLibAccessArg(RTMArgDef,sysFcn, cTID, isRG)>
              %endif
              %assign dataType = SLibGetRecordDataTypeName(co, "")
              %assign   identi = LibGetRecordIdentifier(co)
              %assign  optStar = LibGetRecordWidth(co) == 1 ? " *" : " "
              %assign optWidth = LibOptionalVectorWidth(LibGetRecordWidth(co))
              %if SLibAutosarCompilerAbstractionRequired()
                %if SLibGetCanIOIsVarDims(co) || isISSReuseDiffNumIters
                  %% Always pass pointer for var-dims signal or Implicit Iterator
                  %% subsystem reused for different number of iterations.
                  %assign argDef = " " + identi + "[]"
                %else
                  %assign argDef = identi + optWidth
                %endif
                %<FcnAddParameterWithCompilerAbstraction(TLC_FALSE, dataType, (LibGetRecordWidth(co) == 1), argDef)>
              %else
                %if SLibGetCanIOIsVarDims(co) || isISSReuseDiffNumIters
                  %% Always pass pointer for var-dims signal or Implicit Iterator
                  %% subsystem reused for different number of iterations.
                  %assign argDef = " " + identi + "[]"
                %else
                  %assign argDef = optStar + identi + optWidth
                %endif
                %<FcnAddParameter(dataType, argDef)>
              %endif
            %else
              %assign eo = ExternalOutputs.ExternalOutput[portIdx]
              %assign dataType = SLibGetRecordDataTypeName(eo, "")
              %if FPC.ArgSpecData[argIdx].Category == "Value"
                %assign ::FcnRec.Returns = dataType
              %else
                %assign   identi = FPC.ArgSpecData[argIdx].ArgName
                %assign   isReference = (FPC.ArgSpecData[argIdx].Category == "Reference")
                %assign   optStarOrRef = isReference ? " &" : ...
                  (LibGetRecordWidth(eo) == 1 ? " *" : " ")
                %assign optWidth = LibOptionalVectorWidth(LibGetRecordWidth(eo))
                %if !ISEMPTY(optWidth) && isReference
                  %assign argDef = "(" + optStarOrRef + identi +")" + optWidth
                %else
                  %assign argDef = optStarOrRef + identi + optWidth
                %endif
                %% SLibAutosarCompilerAbstractionRequired() not supported for FPC
                %<FcnAddParameter(dataType, argDef)>
              %endif
            %endif
            %% Add vardims argument for the canonical output 
            %% Function FinalizeDims and SetDims only need canonical dim-size
            %% dwork. They don't need canonical output.
            %<FcnAddNeededCanDimSizeDWForCanOut(sysFcn, sysIdx, portIdx, ...
              skipCanDWork)>
          %endif
          
          %if !hasFPC
            %if ISFIELD(thisSystem, "RTWSystemWithReturnValue") && ...
              EXISTS(portIdx) && ...
              thisSystem.RTWSystemReturnArgIndex == portIdx && ...
              SLObjectType == "Outport" && ...
              (sysFcn == "OutputUpdate" || sysFcn == "Output")
              %assign dataType =SLibGetRecordDataTypeName(CanonicalOutputArgDef[portIdx],"")
              %assign ::FcnRec.Returns = dataType
            %endif
          %endif
          
        %endif  
      %endforeach
    
      %%
      %% Is a model reference scalable build - some args are accessed as globals
      %% Skip these args.
      %%
      %assign isScalableMRSys = ...
        IsModelReferenceBaseSys(thisSystem) && IsModelRefScalableBuild()
      
      %% Is a model reference build and in C++ encapsulation mode
      %assign isCPPEncapMdlRef = GenerateClassInterface && ...
        IsModelReferenceBaseSys(thisSystem)
      %%
      %% rtModel argument
      %%
      %if ISFIELD(thisModule,"SystemFunctions") && ISFIELD(thisModule.SystemFunctions, fcnName)
        %assign fcnIdx = thisModule.SystemFunctions.%<fcnName>
        %assign fcn = thisModule.Function[fcnIdx]
        %assign isOutlinedBlockFcn = fcn.IsOutlinedBlockFcn
      %else
        %assign isOutlinedBlockFcn = TLC_FALSE
      %endif
      %if !ISEMPTY(thisFcn) && thisFcn.IsServiceFcn && ...
        SysFcnArgNeeded(sysFcn, DWorkArgDef, cTID, isRG)
        %% Handle the casting of the "host" argument of a service function to both
        %% RTM and localDW
        %assign varGroupIdx = FcnSysVarGroupIndex(thisSystem, "DWork", 0)
        %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIdx]
        %assign varGroupLocalName = varGroup.LocalName
        %openfile localDWorkVar
        %<::tSimStructType> *%<::tSimStruct> = &((%<FcnGetSFcnDWorkType(thisSystem)>*)host)->rtm;
        %assign varGroupType = FcnSysVarGroupType(thisSystem,"DWork")
        %<varGroupType> *%<varGroupLocalName> = &((%<FcnGetSFcnDWorkType(thisSystem)>*)host)->rtdw;
        %closefile localDWorkVar
        %<FcnCacheModelRefLocalVars(thisSystem, sysFcn, cTID, localDWorkVar)>
      %endif
       %if !isCPPEncapMdlRef && !(thisSystem.IsService && thisModule.SimplifiedInterface) && (skipRTM || SysFcnArgNeeded(sysFcn, RTMArgDef, cTID, isRG))
        %if isScalableMRSys && !::CompiledModel.ModelRefSimpInterface
          %if !SLibGetDoesSelfExist() || SLibIsSelfInSimTarget()
              %openfile localRTMVar
              %assign rtmField = ".rtm"
              %<::tSimStructType> *const %<::tSimStruct> = &(%<FcnGetSFcnDWorkIdentifier(thisSystem)>%<rtmField>);
              %closefile localRTMVar
              %<FcnCacheModelRefLocalVars(thisSystem, sysFcn, cTID, localRTMVar)>
          %endif
        %elseif thisSystem.IsService && !thisModule.SimplifiedInterface && SLibIsSelfInSimTarget()
          %openfile localRTMVar
          %<::tSimStructType> *const %<::tSimStruct> = &(%<FcnGetSFcnDWorkRTM()>);
          %closefile localRTMVar
          %<LibAddToSystemField(thisSystem, "Cached%<sysFcn>%<cTID>LocalBO", localRTMVar)>
        %elseif !skipRTM && !isOutlinedBlockFcn
          %if thisModule.SimplifiedInterface
            %<FcnPrependParameter(::tSimStructType, " *const %<SLibGetSimStruct()>")>
          %else
            %<FcnAddParameter(::tSimStructType, " *const %<SLibGetSimStruct()>")>
          %endif
        %endif
      %endif %% SysFcnArgNeeded
      %%
      %% Block IO argument
      %%
      %if !skipLocalB  && !isCPPEncapMdlRef && SysFcnArgNeeded(sysFcn, BlockIOArgDef, cTID, isRG)
        %assign dataType = FcnSysVarGroupType(thisSystem,"BlockIO") + " "
        %if !isScalableMRSys
          %if SLibAutosarCompilerAbstractionRequired()
            %assign dataType = FcnSysVarGroupType(thisSystem,"BlockIO")
            %<FcnAddParameterWithCompilerAbstraction(TLC_FALSE, dataType, TLC_TRUE, "localB")>
          %else
            %<FcnAddParameter(dataType, "*localB")>
          %endif
        %endif
      %endif %% SysFcnArgNeeded
      %%
      %% DataGroup arguments - only do this for non-model reference base systems
      %%
      %if !IsModelReferenceBaseSys(thisSystem) && !thisModule.SimplifiedInterface
        %foreach gIdx = ::CompiledModel.NumCoderDataGroups
          %assign argDef = FcnGetGroupArgDef(gIdx)
          %if !(skipLocalDataGroup[gIdx]) && !isCPPEncapMdlRef && SysFcnArgNeeded(sysFcn, argDef, cTID, isRG)
            %assign group = ::CompiledModel.CoderDataGroup[gIdx]
            %assign groupToken = "CoderDataGroup" + group.Name
            %assign dataType = FcnSysVarGroupType(thisSystem, groupToken) + " "
            %assign varGroupIdx = FcnSysVarGroupIndex(thisSystem, groupToken, 0)
            %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIdx]
            %assign varName = varGroup.LocalName

            %if !isScalableMRSys
              %if SLibAutosarCompilerAbstractionRequired()
                %assign dataType = FcnSysVarGroupType(thisSystem, groupToken)
                %<FcnAddParameterWithCompilerAbstraction(TLC_FALSE, dataType, TLC_TRUE, varName)>
              %else
                %assign localString = "*" + varName
                %<FcnAddParameter(dataType, localString)>
              %endif
            %endif
          %endif 
        %endforeach
      %endif
      %%
      %% Constant block IO argument
      %%
      %if !skipLocalC && !isCPPEncapMdlRef && SysFcnArgNeeded(sysFcn, ConstBlockIOArgDef, cTID, isRG)
        %assert !isScalableMRSys
        %if SLibAutosarCompilerAbstractionRequired()
          %assign dataType = FcnSysVarGroupType(thisSystem,"ConstBlockIO") 
          %<FcnAddParameterWithCompilerAbstraction(TLC_FALSE, dataType, TLC_TRUE, "localC")>
        %else
          %assign dataType = FcnSysVarGroupType(thisSystem,"ConstBlockIO") + " " 
          %<FcnAddParameter(dataType, "*localC")>
        %endif
      %endif %% SysFcnArgNeeded
      %%
      %% DWork argument
      %%
      %if !skipLocalDW && !isCPPEncapMdlRef && SysFcnArgNeeded(sysFcn, DWorkArgDef, cTID, isRG)
        %assign varGroupType = FcnSysVarGroupType(thisSystem,"DWork")
        %if !isScalableMRSys
          %if SLibAutosarCompilerAbstractionRequired()
            %assign dataType = varGroupType
            %<FcnAddParameterWithCompilerAbstraction(TLC_FALSE, dataType, TLC_TRUE, "localDW")>
          %else
            %assign dataType = varGroupType + " "
            %<FcnAddParameter(dataType, "*localDW")>
          %endif
        %endif
      %endif %% SysFcnArgNeeded
      %%
      %% Parameter H-Struct argument
      %%
      %assign isSysFcnArgNeeded = SysFcnArgNeeded(sysFcn, ParameterArgDef, cTID, isRG)
      %if !skipLocalP && isSysFcnArgNeeded
        %%
        %% Does a passthrough parameter structure argument exists ?
        %%
        %assert( !isScalableMRSys || IsModelReferenceInlineOffTarget())
        %if (InlineParameters != 0 && ParameterArgDef.PassthroughSystemIdx > -1)
          %assign prmSysIdx = ParameterArgDef.PassthroughSystemIdx
        %else
          %assign prmSysIdx = sysIdx
        %endif
        %assign numsys = GetNumSystemsForCodeGen()
        %if prmSysIdx < numsys-1 %% not the root system
          %if SLibAutosarCompilerAbstractionRequired()
            %assign dataType = FcnSysVarGroupType(System[prmSysIdx],"Parameter")
            %<FcnAddParameterWithCompilerAbstraction(TLC_FALSE, dataType, TLC_TRUE, "localP")>
          %else
            %assign dataType = FcnSysVarGroupType(System[prmSysIdx],"Parameter") + " "
            %<FcnAddParameter(dataType, "*localP")>
          %endif
        %else
          %%
          %% The child function has the root parameter structure as
          %% a passthrough argument
          %%
          %if SLibAutosarCompilerAbstractionRequired()
            %assign dataType = ::tParametersType
            %<FcnAddParameterWithCompilerAbstraction(TLC_FALSE, dataType, TLC_TRUE, LibGetParametersStruct())>
          %elseif !(GenerateClassInterface && IsModelReferenceBaseSys(thisSystem))
            %assign dataType = ::tParametersType + " "
            %<FcnAddParameter(dataType, "*%<LibGetParametersStruct()>")>
          %endif
          
        %endif
      %endif %% SysFcnArgNeeded
      %%
      %% Continuous States argument
      %%
      %if !skipLocalX && SysFcnArgNeeded(sysFcn, ContStatesArgDef, cTID, isRG)
        %assign dataType = isScalableMRSys ? "real_T " : ...
          "%<FcnSysVarGroupType(thisSystem,"ContStates")> "
        %assign paramName= isScalableMRSys ? "*localX_" : "*localX"
        %assert !isCPPEncapMdlRef
        %<FcnAddParameter(dataType, paramName)>
        %if isScalableMRSys
          %openfile localCStateVar
          %assign varGroupType = FcnSysVarGroupType(thisSystem,"ContStates")
          %<varGroupType> *localX = (%<varGroupType> *) localX_;
          %closefile localCStateVar
          %<FcnCacheModelRefLocalVars(thisSystem, sysFcn, cTID, localCStateVar)>
        %endif
      %endif
      %%
      %% Continuous States Derivative argument
      %%
      %if !skipLocalXdot && SysFcnArgNeeded(sysFcn, ContStatesDerivativeArgDef, cTID, isRG)
        %assign dataType = isScalableMRSys ? "real_T " : "%<FcnSysVarGroupType(thisSystem,"ContStatesDerivative")> "
        %assign paramName= isScalableMRSys ? "*localXdot_" : "*localXdot"
        %assert !isCPPEncapMdlRef
        %% SLibAutosarCompilerAbstraction not needed for continuous states
        %<FcnAddParameter(dataType, paramName)>
        %if isScalableMRSys
          %openfile localCStateVar
          %assign varGroupType = FcnSysVarGroupType(thisSystem,"ContStatesDerivative")
          %<varGroupType> *localXdot = (%<varGroupType> *) localXdot_;
          %closefile localCStateVar
          %<FcnCacheModelRefLocalVars(thisSystem, sysFcn, cTID, localCStateVar)>
        %endif
      %endif
      %%
      %% Continuous States Disabled argument
      %%
      %if !skipLocalXdis && SysFcnArgNeeded(sysFcn, ContStatesDisabledArgDef, cTID, isRG)
        %assign dataType = isScalableMRSys ? "boolean_T " : "%<FcnSysVarGroupType(thisSystem,"ContStatesDisabled")> "
        %assign paramName= isScalableMRSys ? "*localXdis_" : "*localXdis"
        %assert !isCPPEncapMdlRef
        %% SLibAutosarCompilerAbstraction not needed for continuous states
        %<FcnAddParameter(dataType, paramName)>
        %if isScalableMRSys
          %openfile localCStateVar
          %assign varGroupType = FcnSysVarGroupType(thisSystem,"ContStatesDisabled")
          %<varGroupType> *localXdis = (%<varGroupType> *) localXdis_;
          %closefile localCStateVar
          %<FcnCacheModelRefLocalVars(thisSystem, sysFcn, cTID, localCStateVar)>
        %endif
      %endif
      %%
      %% Continuous States Absolute Tolerance argument
      %%
      %if !skipLocalXabstol && SysFcnArgNeeded(sysFcn, ContStatesAbsoluteToleranceArgDef, cTID, isRG)
        %assign dataType = isScalableMRSys ? "real_T " : ...
          "%<FcnSysVarGroupType(thisSystem,"ContStatesAbsoluteTolerance")> "
        %assign paramName= isScalableMRSys ? "*localXAbsTol_" : "*localXAbsTol"
        %assert !isCPPEncapMdlRef
        %% SLibAutosarCompilerAbstraction not needed for continuous states
        %<FcnAddParameter(dataType, paramName)>
        %if isScalableMRSys
          %openfile localCStateVar
          %assign varGroupType = FcnSysVarGroupType(thisSystem,"ContStatesAbsoluteTolerance")
          %<varGroupType> *localXAbsTol = (%<varGroupType> *) localXAbsTol_;
          %closefile localCStateVar
          %<FcnCacheModelRefLocalVars(thisSystem, sysFcn, cTID, localCStateVar)>
        %endif
      %endif
      %%
      %% ZcSignalValue  argument
      %%
      %if !skipLocalZCSV && SysFcnArgNeeded(sysFcn,ZCSVArgDef, cTID, isRG)
        %if SLibAutosarCompilerAbstractionRequired()
          %assign dataType = isScalableMRSys ? "real_T" : "%<FcnSysVarGroupType(thisSystem,"ZCSV")>"
          %assign paramName= isScalableMRSys ? "localZCSV_" : "localZCSV"
          %assert !isCPPEncapMdlRef
          %<FcnAddParameterWithCompilerAbstraction(TLC_FALSE, dataType, TLC_TRUE, paramName)>
        %else
          %assign dataType = isScalableMRSys ? "real_T " : "%<FcnSysVarGroupType(thisSystem,"ZCSV")> "
          %assign paramName= isScalableMRSys ? "*localZCSV_" : "*localZCSV"
          %assert !isCPPEncapMdlRef
          %<FcnAddParameter(dataType, paramName)>
        %endif
        %if isScalableMRSys
          %openfile localCStateVar
          %assign varGroupType = FcnSysVarGroupType(thisSystem,"ZCSV")
          %<varGroupType> *localZCSV = (%<varGroupType> *) localZCSV_;
          %closefile localCStateVar
          %<FcnCacheModelRefLocalVars(thisSystem, sysFcn, cTID, localCStateVar)>
        %endif
      %endif
      %%
      %% ZCEvent H-Struct argument
      %if !skipLocalZCE && !isCPPEncapMdlRef && SysFcnArgNeeded(sysFcn, ZCEventArgDef, cTID, isRG)
        %if !isScalableMRSys 
          %if SLibAutosarCompilerAbstractionRequired()
            %assign dataType = FcnSysVarGroupType(thisSystem,"ZCEvent")
            %<FcnAddParameterWithCompilerAbstraction(TLC_FALSE, dataType, TLC_TRUE, "localZCE")>
          %else
            %assign dataType = FcnSysVarGroupType(thisSystem,"ZCEvent") + " "
            %<FcnAddParameter(dataType, "*localZCE")>
          %endif
        %endif
      %endif %% SysFcnArgNeeded
      %%
      %% Coder Data Groups - add RTM to the interface
      %%
      %if IsModelReferenceBaseSys(thisSystem) && !SLibGetUseRTMcgType() && !isOutlinedBlockFcn
        %openfile coderDataGroupVar
        %foreach gIdx = ::CompiledModel.NumCoderDataGroups
          %assign group = ::CompiledModel.CoderDataGroup[gIdx]
            %if SLibAccessGroupThroughSelf(group)
              %assign groupToken = "CoderDataGroup" + group.Name
              %assign argDef = %<groupToken + "ArgDef">
              %if SysFcnArgNeeded(sysFcn, argDef, cTID, isRG)
                %assign varGroupIdx = FcnSysVarGroupIndex(System[sysIdx], groupToken, 0)
                %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIdx]
                %assign varGroupType = FcnSysVarGroupType(::CompiledModel.System[sysIdx], groupToken)
                %assign varName = varGroup.LocalName
                %<SLibTypeQualifierForGroup(group)> %<SLibCoderDataGroupType(group)> *%<varName> = %<SLibGetCoderDataGroupPointerFromRTM(group, 0)>;
              %endif
            %endif
        %endforeach
        %closefile coderDataGroupVar
        %if !ISEMPTY(coderDataGroupVar)
          %<FcnCacheModelRefLocalVars(thisSystem, sysFcn, cTID, coderDataGroupVar)>
        %endif
      %endif
      %%
      %%
      %% Canonical Parameters
      %%
      %foreach argIdx=NumCanonicalPrmArgDefs
        %assign canPrmDef = CanonicalPrmArgDef[argIdx]
        %if !skipCanParam[argIdx] && SysFcnArgNeeded(sysFcn, canPrmDef, cTID, isRG)
          %assign   identi = LibGetRecordIdentifier(canPrmDef)
          %assign dataType = SLibGetRecordDataTypeName(canPrmDef, "")
          %assign    width = LibBlockParameterWidth(canPrmDef)
          %assign optWidth = LibOptionalVectorWidth(width)
          %assign declAsPtr = canPrmDef.DeclareAsPointer == "yes"
          %if SLibAutosarCompilerAbstractionRequired()
            %assign optConst = ((width > 1) || declAsPtr)
            %assign optStar  = declAsPtr
            %assign argDef   = "%<identi>%<optWidth>"
            %<FcnAddParameterWithCompilerAbstraction(optConst, dataType, optStar, argDef)>
          %else
            %assign optConst = ((width > 1) || declAsPtr)  ? "const " : ""
            %assign dataType = "%<optConst>%<dataType> "
            %assign optStar  = declAsPtr ? "*" : ""
            %assign argDef   = "%<optStar>%<identi>%<optWidth>"
            %<FcnAddParameter(dataType, argDef)>
          %endif
        %endif %% SysFcnArgNeeded
      %endforeach %% argIdx=NumCanonicalPrmArgDefs
      %%
      %% CanonicalDWork
      %%
      %foreach argIdx = NumCanonicalDWorkArgDefs
        %% Canonical dimsize dwork has already beed added to the
        %% args following the corresponding canonical input/output
        %if !skipCanDWork[argIdx] && !SLibGetCanDWorkIsCanDimSizeDWork(argIdx)
          %assign canDWork = CanonicalDWorkArgDef[argIdx]
          %if SysFcnArgNeeded(sysFcn, canDWork, cTID, isRG)
            %assign dwIdx    = canDWork.FirstSignalSrc %% global idx
            %assign dwRec    = ::CompiledModel.DWorks.DWork[dwIdx]        
            %assign dwWidth  = SLibDWorkWidth(dwRec)
            %assign dwId     = LibGetRecordIdentifier(canDWork)
            %assign dataType = SLibGetRecordDataTypeName(dwRec, "")
            %%
            %% Example:
            %%   Scalar signal: void foo(real_T *a)
            %%   Wide signal:   void foo(real_T b[7])
            %%
            %if SLibAutosarCompilerAbstractionRequired()
              %if dwWidth == 1
                %assign   argDef = "%<dwId>"
              %else
                %assign   argDef = "%<dwId>[%<dwWidth>]"
              %endif
              %<FcnAddParameterWithCompilerAbstraction(TLC_FALSE, dataType, (dwWidth == 1), argDef)>
            %else
              %if dwWidth == 1
                %assign   argDef = " *%<dwId>"
              %else
                %assign   argDef = " %<dwId>[%<dwWidth>]"
              %endif
              %<FcnAddParameter(dataType,argDef)>
            %endif
          %endif
        %endif %% if !SLibGetCanDWorkIsCanDimSizeDWork
      %endforeach
    %elseif SLibNeedHandleParallelForEachSS(thisSystem, sysFcn)
      %% Add argument (int32_T rtSS_iter) for parallel ForEach Subsystem
      %assign dw = DWorks.DWork[IDNUM(thisSystem.IndexingSigSrc)[1]]
      %if dw.IsLocalScratchDWork == 1
        %assign argDef  = LibGetRecordIdentifier(dw)
        %assign dataType = SLibGetRecordDataTypeName(dw,"") + " "    
        %<FcnAddParameter(dataType, argDef)>
      %endif
    %endif  
  %endwith
%endfunction

%% Function: FcnGetSfcnFormDefine ==============================================
%% Abstract:
%%   Return the # define that is needed in front of root model methods in 
%%   S-function format
%% 
%function FcnGetSfcnFormDefine(sysFcn) void
  %assign retVal = ""
  %switch sysFcn
    %case "Start"
      %assign retVal = "MDL_START"
      %break
    %case "Initialize"
      %assign retVal = "MDL_INITIALIZE_CONDITIONS"
      %break
    %case "Enable"
      %assign retVal = "RTW_GENERATED_ENABLE"
      %break
    %case "Disable"
      %assign retVal = "RTW_GENERATED_DISABLE"
      %break
    %case "Update"
      %assign retVal = "MDL_UPDATE"
      %break
    %case "Derivative"
      %assign retVal = "MDL_DERIVATIVES"
      %break
    %case "ForcingFunction"
      %assign retVal = "MDL_FORCINGFUNCTION"
      %break  
    %case "MassMatrix"
      %assign retVal = "MDL_MASSMATRIX"
      %break        
    %case "Projection"
      %assign retVal = "MDL_PROJECTION"
      %break
    %case "ZeroCrossing"
      %assign retVal = "MDL_ZERO_CROSSINGS"
      %break
    %default
      %assign retVal = ""
      %break
  %endswitch
  
  %return retVal
%endfunction %% FcnGetSfcnFormDefine

%% Function: FcnUseStaticStorageSpecifier ======================================
%% Abstract: Function to determine if static keyword should be prepended to 
%%           a subsystem prototype.
%function FcnUseStaticStorageSpecifier(system)
  %assign compactFileFormat = SLibIsCompactFileFormat()
  %assign isReusedLibraryFcn = LibSystemIsReusedLibraryFcn(system)
  %assign isExportedSlFcn = SLibIsModelScopedServer(system)
  %assign useStatic = compactFileFormat && ...
  (!LibSystemIsRoot(system) || !(IsModelReferenceBaseSys(system) && IsModelReferenceTarget())) && ...
  !IsModelReferenceTarget() && !LibIsGlobalServer(system) && ...
  !SLibGenNonReusableSubsysFcnAsClassMemFcn(system) && !isReusedLibraryFcn && ...
  !::CompiledModel.ConfigSet.GenerateTestInterfaces && !isExportedSlFcn
  %return useStatic
%endfunction %% FcnUseStaticStorageSpecifier

%% Function: FcnUseExternStorageSpecifier ======================================
%% Abstract: Function to determine if extern keyword should be prepended to 
%%           a subsystem prototype.
%function FcnUseExternStorageSpecifier(system)
  %assign genNonReusableSubsys = SLibGenNonReusableSubsysFcnAsClassMemFcn(system)
  %assign useExtern = LibPreserveExternInFcnDecls() && ...
    (UsingMalloc == 0) && !genNonReusableSubsys
  %return useExtern
%endfunction %% FcnUseExternStorageSpecifier


%<LibAddToCompiledModel("SubsystemPrototypesCache", "")>
%% Function: LibCacheSubsystemPrototype ========================================
%% Abstract:
%%   Cache a function prototype (in case the file splits) 
%%
%%   Arguments:
%%     system: Refers to the system whose prototype we are caching   
%% 	  fcn: Reference to a FcnRec (see top of file for definition of Record)
%%
%%
%%   Example:
%% 	   fcn.Returns = "real_T *"
%% 	   fcn.Name    = "foo"
%% 	   fcn.Params  = "int_T i"
%%   
%% 	   caches: (in 'system.SystemFcnPrototype')
%% 		  C -
%% 		   "extern real_T * foo(int_T i);" 
%% 		   
%% 		  Ada -
%% 		    package system is
%% 		      procedure system_output
%% 		    end system
%% 
%function LibCacheSubsystemPrototype(system,fcn) void
  %% Cache extern only if the storage class is non-static
  %assign genNonReusableSubsys = SLibGenNonReusableSubsysFcnAsClassMemFcn(system)

  %assign staticOrExternSpecifier = ""
  %if(CGMODEL_ACCESS("CGModel.AddStaticKeywordToFcn"))
    %if FcnUseStaticStorageSpecifier(system)
      %assign staticOrExternSpecifier = "static "
    %elseif FcnUseExternStorageSpecifier(system)
      %assign staticOrExternSpecifier = !genNonReusableSubsys ? "extern " : ""
    %endif
  %else
    %if FcnUseExternStorageSpecifier(system)
      %assign staticOrExternSpecifier = !genNonReusableSubsys ? "extern " : ""
    %endif
  %endif

  %assign sysFcnType = fcn.SysFcn
  %if (sysFcnType == "Initialize" || sysFcnType == "SystemInitialize" || sysFcnType == "SystemReset" ||sysFcnType == "Start" || sysFcnType == "Terminate")
    %assign msFcnType = "MemSecFuncInitTerm"
  %else
    %assign msFcnType = "MemSecFuncExecute"
  %endif
  %assign ppIf = SLibVariantConditionForTID(system.CurrentTID)
  %openfile ssp
  %if !ISEMPTY(ppIf)
    %<SLibIfVariantConditionForm16b(ppIf)>
  %endif
  %<SLibIfSystemVariantCondition16b(system)>
  %<SLibIfSystemPreprocessorCondition(system)>
  %assign useIndividualMapping = TLC_FALSE
  %assign functionType = ""
  %assign functionId = "" %% Assume
  %if CGMODEL_ACCESS("CGModel.isIndividualFunctionMappingEnabled")
    %if IsModelReferenceTarget()
      %% Model Reference build
      %if (sysFcnType == "ModelInitialize") && TLC_FALSE
        %% Initialize function   
        %% NOTE: Skip this (this is re-computed in formatmodelref.tlc)
        %assign functionType = "Initialize"
        %assign useIndividualMapping = TLC_TRUE
      %elseif (sysFcnType == "Terminate") 
        %% Terminate function 
        %assign functionType = "Terminate"
        %assign useIndividualMapping = TLC_TRUE
      %elseif (sysFcnType == "OutputUpdate") || (sysFcnType == "Output") || ...
        (sysFcnType == "Update") 
        %if SLibExplicitTaskingTID(system.CurrentTID)
          %if SLibResetOrResetWithInitEventTID(system.CurrentTID)
            %% Reset function
            %assign functionType = "Reset"
            %assign functionId = SampleTime[system.CurrentTID].EventSourceName    
            %assign useIndividualMapping = TLC_TRUE
          %elseif SLibIsRateGroupedSLFcn(system, sysFcnType, system.CurrentTID)
            %% Global or Public Simulink Function in export function model
            %assign functionType = "SimulinkFunction"
            %assign functionId = SLibGetRateGroupedSimulinkFunctionName(system, sysFcnType, system.CurrentTID)
            %assign useIndividualMapping = TLC_TRUE
          %elseif !LibIsServer(system) && ...
            SLibIsExplicitTaskingExportFcnRateGrouping(sysFcnType, system.CurrentTID)                    
            %% Export or Async function
            %% NOTE: SampleTime[tid].TaskName returns block name for export function,
            %%  and full block path for async function
            %assign functionType = "FcnCallInport"
            %assign functionId = FEVAL("regexprep", ...
              SampleTime[system.CurrentTID].TaskName, ".*\/", "")
            %assign useIndividualMapping = TLC_TRUE
          %endif
        %else
          %if !SLibIsExportFcnDiagram()
            %if (LibIsGlobalServer(system) || SLibIsModelScopedServer(system))
              %% Global or Exported Global Scoped Function in a rate-based model
              %assign functionType = "SimulinkFunction"
              %assign functionId = SLibGetSimulinkFunctionNameInNonExportFcnModel(system)    
              %assign useIndividualMapping = TLC_TRUE
            %else
              %% Implicit periodic functions
              %if (sysFcnType == "OutputUpdate")
                %assign functionType = "Step"                            
              %elseif (sysFcnType == "Output")
                %assign functionType = "Output"
              %elseif (sysFcnType == "Update") 
                %assign functionType = "Update"
              %endif
              %assign functionId = system.CurrentTID
              %assign useIndividualMapping = TLC_TRUE
            %endif
          %endif
        %endif
      %endif
    %else
      %% Top Model build
      %if (LibIsGlobalServer(system) || SLibIsModelScopedServer(system))
        %% Global or Exported Global Scoped Function in a rate-based model
        %assign functionType = "SimulinkFunction"
        %assign functionId = SLibGetSimulinkFunctionNameInNonExportFcnModel(system)    
        %assign useIndividualMapping = TLC_TRUE
      %endif
    %endif
  %endif
  %if !GenerateClassInterface
    %if useIndividualMapping
      %<SLibGetFcnMemSecPragmaForFunction(fcn.Name, functionType, functionId,  "Pre")>\
    %else
      %<SLibGetFcnMemSecPragmaForSystemOnDecl(fcn.Name, msFcnType, "Pre", system)>\
    %endif
  %endif
  %<staticOrExternSpecifier>%<fcn.FcnPrototype>;
  %if !GenerateClassInterface
    %if useIndividualMapping
      %<SLibGetFcnMemSecPragmaForFunction(fcn.Name, functionType, functionId,  "Post")>\
    %else
      %<SLibGetFcnMemSecPragmaForSystemOnDecl(fcn.Name, msFcnType, "Post", system)>\
    %endif
  %endif
  %<SLibEndIfSystemPreprocessorCondition(system)>
  %<SLibEndIfSystemVariantCondition16b(system)>
  %if !ISEMPTY(ppIf)
    %<SLibEndIfVariantConditionForm16b(ppIf)>
  %endif

  %closefile ssp
  %% To avoid warnings, use a different name for the
  %% rtModel in the function declaration than in the
  %% function body.
  %if GenRTModel
    %assign rtm = " *%<::tSimStruct>"
    %assign lowerrtm = " *%<SLibGetSimStruct()>"
    %assign ssp = FEVAL("strrep",ssp, rtm, lowerrtm)
  %endif
  %assign fileOwnerSystem = ::CompiledModel.System[system.FileNameOwnerIdx]
  %if IsModelRefScalableBuild() && IsModelReferenceBaseSys(system)
    %assert (system.FileNameOwnerIdx == system.SystemIdx)
    %if !GenerateClassInterface
      %if !LibIsSystemField(system, "MRSystemFcnPrototype")
        %<LibAddToSystem(fileOwnerSystem, "MRSystemFcnPrototype", ssp)>
      %else
        %<LibAddToSystemField(fileOwnerSystem, "MRSystemFcnPrototype", ssp)>
      %endif
    %endif
  %else
    %if !SLibGenNonReusableSubsysFcnAsClassMemFcn(system)
      %if LibIsServer(system) 
        %if (!LibIsGlobalServer(system)) || sysFcnType != "OutputUpdate"
          %% If it is a SL function but not a global SLFcn, or a global SLFcn, but fcnType != "OutputUpdate". Declarations need to
          %% be in model.h (if model scoped) or model_private.h (if subsystem scoped). We cannot put them into fileOwnerSystem, as
          %% it would mean the base system, and we cannot make SLFcn specific decisions. 
          %<LibAddToSystemField(system, "SystemFcnPrototype", ssp)>
        %endif
      %else
         %<LibAddToSystemField(fileOwnerSystem, "SystemFcnPrototype", ssp)>
      %endif
    %else
      %% When in generating non-reusable subsystem funcitons as C++ member function mode,
      %% system function prototoype cannot be put in the file owner subsystem, as they will
      %% need to be put into root_model.h
      %if (!LibIsServer(system)) || ...
        (FcnIsServerPublicAccess(system) && sysFcnType == "OutputUpdate" && ...
        SLibIsExportFcnDiagram() && ...
        !SLibModelWideEventTID(system.CurrentTID))
        %<LibAddToSystemField(system, "EncapSystemFcnPrototype", ssp)>
      %else
        %% SlFcn prototypes placed in System Member Prototypes will become private access methods
        %<LibAddToSystemField(system, "SystemMemberPrototype", ssp)>
      %endif
    %endif
  %endif

%endfunction %% LibCacheSubsystemPrototype

%% Function: LibDumpSystemPrototype ============================================
%% Abstract:
%%   Place the system function prototypes in the output stream.
%%
%function LibDumpSystemPrototype(system) Output
  %assign systemFcnPrototype = LibGetSystemField(system,"SystemFcnPrototype")
  %if !WHITE_SPACE(systemFcnPrototype)
    %<systemFcnPrototype>\
  %endif
%endfunction %% LibDumpSystemPrototype

%% Function: SLibGetNeedLocalTIDFieldName ====================================
%% Abstract:
%%
%function SLibGetNeedLocalTIDFieldName(system, fcnType) void
  %return "NeedLocalTIDIn" + ...
    ((fcnType == "Outputs" || fcnType == "OutputUpdate") ? "Output" : fcnType) 
%endfunction

%% Function: SLibSetNeedLocalTIDInSystem =====================================
%% Abstract:
%%
%function SLibSetNeedLocalTIDInSystem(system, fcnType) void
  %assign fieldName = SLibGetNeedLocalTIDFieldName(system, fcnType)
  %if ISFIELD(system, fieldName)
    %<SETFIELD(system, fieldName, TLC_TRUE)>
  %else
    %addtorecord system %<fieldName> TLC_TRUE
  %endif
%endfunction

%% Function: SLibGetNeedLocalTIDInSystem =======================================
%% Abstract:
%%
%function SLibGetNeedLocalTIDInSystem(system, fcnType)
  %assign fieldName = SLibGetNeedLocalTIDFieldName(system, fcnType)
  %if ISFIELD(system, fieldName)
    %return GETFIELD(system, fieldName)
  %else
    %return TLC_FALSE
  %endif
%endfunction

%% DocFunction{Other Useful Functions}: LibTIDInSystem =========================
%% Abstract:
%%    This function returns a tid if it is in the scope of a subsystem function
%%    and can be called before or during TLC generating code. 
%%    It returns the tid argument name, if a tid is passed as argument in the 
%%    system function scope.
%%
%%    If tid is not passed as argument in the scope, this function returns: 
%%       1. '0' if model is single tasking,
%%       2. the tid value of the subsystem if the subsystem is single rate,
%%       3. returns a local tid variable name, if the subsystem is multirate. 
%%          A local tid variable will be added to the subsystem code.
%%   
%% Note:
%%    This function issue an error message, if it is called for a reusable
%%    subsystem whose instance run at different rate.  
%%
%% Example:
%%    LibTIDInSystem(system, fcnType)
%%     
%%    system  - is a record within the global ::CompiledModel record. 
%%    fcnType - can be any of the following: 'Output','Update','Outputupdate'
%%
%function LibTIDInSystem(system, fcnType) void
  %assert (fcnType == "Output" || ...
    fcnType == "Update" || fcnType == "OutputUpdate")
  %if ::CompiledModel.NumSampleTimes == 1 || ...
    SLibSingleTasking()
    %return "0"
  %elseif LibIsSingleRateSystem(system)
    %assign tmpTid = FcnGetSubsystemTID(system, TLC_TRUE)
    %if tmpTid == -1
      %<SLibReportErrorWithIdAndArgs("RTW:tlc:ReuseOfDifferentRate", "%<system.Name>")>
    %else 
      %return FcnGetSubsystemTID(system, TLC_TRUE)
    %endif
  %else
    %if IsModelReferenceBaseSys(system)
      %<SLibReportErrorWithIdAndArgs("RTW:tlc:IncorrectLibTIDCall", "%<system.Name>")>
    %else
      %<SLibSetNeedLocalTIDInSystem(system, fcnType)>
      %return ::tTID
    %endif
  %endif
%endfunction %% LibTIDInSystem

%% Function: SLibDumpLocalTidInSystem ==========================================
%% Abstract:
%%
%function SLibDumpLocalTidInSystem(system, fcn)
  %% Do need dump local tid is a subsystem for an async rate 
  %% if the subsystem is not async the async rate. In this case, 
  %% async code for this subsystem is going to be grouped in 
  %% the async task entry functions. The code doesn't belong to
  %% this subsystem eventually. 
  %if LibAsynchronousTriggeredTID(system.CurrentTID) && ...
    !SLibModelWideEventTID(system.CurrentTID) && ...
    system.CurrentTID != LibGetSubsystemTID(system,TLC_TRUE)
    %return ""
  %endif
  %assign needLocalTid = SLibGetNeedLocalTIDInSystem(system,fcn)
  %if fcn == "OutputUpdate"
    %assign needLocalTid = needLocalTid || ...
      SLibGetNeedLocalTIDInSystem(system,"Output") || ...
      SLibGetNeedLocalTIDInSystem(system,"Update")
  %endif
  %openfile tmpBuf
  %if needLocalTid && !LibSystemFcnNeedsTID(system, fcn)     
    %% System need local tid value, but does not pass in tid arg
    %if SLibSingleTasking()
      %assign tidValue = 0
    %else
      %% CurrentTID is set only if the system generate rate grouping 
      %% code. Otherwise, we need get tid value from system record directly. 
      %assign tidValue =  !SLibSystemFcnPeriodicRateGrouping(system, fcn) ? ...
        FcnGetSubsystemTID(system,!LibIsSingleRateSystem(system)) : ...
        system.CurrentTID
    %endif
    %if ISEMPTY(tidValue)
      %<LibReportFatalError("TID value is empty")>
    %endif
    int_T %<::tTID> = %<tidValue>; 
  %endif
  %closefile tmpBuf
  
  %return tmpBuf
%endfunction

%% Function: LibDumpFcnOpen ====================================================
%% Abstract:
%%   Dump the opening (start) of the specified function (e.g. Output).
%%
%function LibDumpFcnOpen(system,function) Output
  %assign fcnInfo = LibGetFcnInfo(system, function, system.CurrentTID)
  %if fcnInfo.SfcnFormDefine != ""
    #define %<fcnInfo.SfcnFormDefine>
  %endif
  %<fcnInfo.Open>\
  %<SLibDumpLocalTidInSystem(system, function)>
%endfunction %% LibDumpFcnOpen

%% Function: LibDumpFcnBegin ===================================================
%% Abstract:
%%   Dump the beginning of the function (e.g. Output) code.
%%
%function LibDumpFcnBegin(system,function) Output
  %assign fcnInfo = LibGetFcnInfo(system, function, system.CurrentTID)
  %<fcnInfo.Begin>\
%endfunction %%LibDumpFcnBegin

%% Function: LibDumpFcnClose ===================================================
%% Abstract:
%%   Dump the closing of the specified function (e.g. Output).
%%
%function LibDumpFcnClose(system,function) Output
  %assign fcnInfo = LibGetFcnInfo(system, function, system.CurrentTID)
  %<fcnInfo.Close>\
%endfunction %% LibDumpFcnClose

%% Function: FcnSysFcnHasRTM ===================================================
%% Abstract:
%%   Returns whether a system fcn needs the real time model as an arg
%%
%function FcnSysFcnHasRTM(system, sysFcn) void
  %assign cTID = system.CurrentTID
  %assign isRG = SLibSystemFcnPeriodicRateGrouping(system, sysFcn)
  %with system.Interface
    %assign hasRTM = SysFcnArgNeeded(sysFcn, RTMArgDef, cTID, isRG) && ...
      LibSystemIsReusedFcn(system) && !LibSystemIsRoot(system)
  %endwith
  %return hasRTM
%endfunction

%% Function: FcnSysNeedAddRTMArg ===========================
%% Abstract: 
%%     This function return true when the subsystem
%%     doesn't have rtm arg, but it must be added to arg list due to: 
%%     1. S-Function target
%%     2. Malloc target (grt malloc) or ERT Multi-Instance,
%%        and system cross flag is true 
%%        (Noreusable system in reusable system). 
%%
%function FcnSysNeedAddRTMArg(system, sysFcn) void
  %if FcnSysFcnHasRTM(system, sysFcn) 
    %return TLC_FALSE
  %else
    %return (CodeFormat == "S-Function") || ...
     (system.CrossNoArgFcnBound && (UsingMalloc || (MultiInstanceERTCode && !GenerateClassInterface))) ...
      && system.IsService == 0
  %endif
%endfunction

%% Function: SLibIsFcnSubFunction(system, sysFcn) void
%% Abstract:
%%     This function returns true when sysFcn is a sub-function in system
%%
%function SLibIsFcnSubFunction(system, sysFcn)
  %assign module = ::CompiledModel.RTWCGModules.RTWCGModule[system.CGIRModuleIdx]
  %assign isSubFunction = TLC_FALSE
  %if ISFIELD(module, "SystemFunctions") && ISFIELD(module.SystemFunctions, sysFcn)
    %assign fcnIdx = GETFIELD(module.SystemFunctions, sysFcn)
    %if fcnIdx < module.NumSubFunctions
      %assign isSubFunction = TLC_TRUE
    %endif
  %endif
  %return isSubFunction
%endfunction

%% Function: SLibSystemHasExportedFunction ====================================
%% Abstract:
%%    This function determines if
%%    1) The system is a function call system
%%    2) The system function is exported
%%
%function SLibSystemHasExportedFunction(system) void
  %assign retVal = TLC_FALSE
  %if  ExportFunctionsMode == 1
    %assign retVal = (system.Type == "function-call" && system.Exported == "yes" )
  %elseif ExportFunctionsMode == 2 && system.Type == "function-call" && ...
      system.DescSysNonTrigTID[0] >= NumRuntimeExportedRates 
    %assign retVal = TLC_TRUE
  %endif
  %return retVal
%endfunction


%% Function: SLibSystemFcnInfoRecord ===========================================
%% Abstract:
%%   Returns the function info record for LibDefineSystemFcn. 
%%   See LibDefineSystemFcn
%%
%function SLibSystemFcnInfoRecord(system, sysFcn) void
  %<FcnResetFunctionRecord()>
  %assign fcnname = sysFcn + "Fcn"
  %assign sysIdx  = system.SystemIdx
  %assign isRoot  = (system.Type == "root")
  
  %% In the exporting functions model 1 (exporting functions), we want to
  %% use the user specified function name to the wrapper.  Thus the real
  %% function is rename to fcnname_core
  %assign functionExported = TLC_FALSE
  %if ExportFunctionsMode == 1 && system.Type == "function-call" && ...
    sysFcn == "OutputUpdate"
    %%
    %assign rootSystem = System[NumSystems-1]
    %foreach id = rootSystem.NumChildSystems
      %assign systemId = rootSystem.ChildSystems[id][0]
      %if systemId == sysIdx
        %assign functionExported = TLC_TRUE
        %break
      %endif
    %endforeach
  %endif

  %assign getFcnNameFromFPC = TLC_FALSE
  %% Try to get function name from FPC
  %if  IsModelReferenceBaseSys(system)
    %if (sysFcn == "OutputUpdate") && ...
      SLibFcnProtoCtrlActive()
      %assign FPC = FcnGetFunctionPrototypeRecord()
      %assign ::FcnRec.Name = FPC.FunctionName
      %assign getFcnNameFromFPC = TLC_TRUE
    %elseif (sysFcn == "Initialize") && ...
      SLibFcnProtoCtrlActive() 
      %assign FPC = FcnGetFunctionPrototypeRecord()
      %assign ::FcnRec.Name = FPC.InitFunctionName
      %assign getFcnNameFromFPC = TLC_TRUE
    %elseif GenerateClassInterface 
      %assign getFcnNameFromFPC = TLC_TRUE
      %assign FPC = FcnGetRTWCPPStepPrototypeRecord()
      %if sysFcn == "OutputUpdate"
        %if ISFIELD(FPC,"FunctionName")
          %if (!ISEMPTY(system.CurrentTID) && ISFIELD(SampleTime[system.CurrentTID],"EventSourceName"))
            %if ISFIELD(SampleTime[system.CurrentTID],"EntryFcnName")
              %assign ::FcnRec.Name = FPC.ModelClassName + "::" + SampleTime[system.CurrentTID].EntryFcnName
            %endif
          %else
            %assign ::FcnRec.Name = FPC.ModelClassName + "::" + FPC.FunctionName
          %endif
        %elseif SLibIsExplicitTaskingExportFcnRateGrouping(sysFcn,system.CurrentTID) || ...
          (!ISEMPTY(system.CurrentTID) && ISFIELD(SampleTime[system.CurrentTID],"EventSourceName"))
          %if ISFIELD(SampleTime[system.CurrentTID],"EntryFcnName")
            %assign ::FcnRec.Name = FPC.ModelClassName + "::" + SampleTime[system.CurrentTID].EntryFcnName
          %endif
        %endif
      %elseif SLibIsExplicitTaskingExportFcnRateGrouping(sysFcn,system.CurrentTID)
        %assign ::FcnRec.Name = FPC.ModelClassName + "::" + SampleTime[system.CurrentTID].EntryFcnName
      %elseif sysFcn == "SystemInitialize"
        %assign ::FcnRec.Name = FPC.ModelClassName + "::" + "init"
      %elseif sysFcn == "SystemReset"
        %assign ::FcnRec.Name = FPC.ModelClassName + "::" + "reset"
      %elseif sysFcn == "Start"
        %assign ::FcnRec.Name = FPC.ModelClassName + "::" + "start"
      %elseif sysFcn == "Terminate"
        %assign ::FcnRec.Name = FPC.ModelClassName + "::" + "terminate"
      %elseif sysFcn == "Enable"
        %assign ::FcnRec.Name = FPC.ModelClassName + "::" + "enable"
      %elseif sysFcn == "Disable"
        %assign ::FcnRec.Name = FPC.ModelClassName + "::" + "disable"
      %elseif sysFcn == "SetupRuntimeResources"
        %assign ::FcnRec.Name = FPC.ModelClassName + "::" + "setupruntimeresources"
      %elseif sysFcn == "CleanupRuntimeResources"
        %assign ::FcnRec.Name = FPC.ModelClassName + "::" + "cleanupruntimeresources"
      %endif
    %endif
  %endif
  %% get fcn name from system record.
  %assert(ISFIELD(system,fcnname))
  %assign fcnName = GETFIELD(system, fcnname)
  %assign modIdx = system.CGIRModuleIdx
  %assign ownerModule = ::CompiledModel.RTWCGModules.RTWCGModule[modIdx]
  %if ISFIELD(ownerModule ,"SystemFunctions")  && ISFIELD(ownerModule.SystemFunctions, fcnName)
    %assign fcnIdx = ownerModule.SystemFunctions.%<fcnName>
    %assign fcn = ownerModule.Function[fcnIdx]
    %assign isOutlinedBlockFcn = fcn.IsOutlinedBlockFcn
  %else
    %assign isOutlinedBlockFcn = TLC_FALSE
  %endif
  %assign updateFcnRecName = TLC_TRUE
  %assign isRootOrMdlRefBaseSystem = isRoot || IsModelReferenceBaseSys(system)
  %assign exportFcnMode = TLC_FALSE
  %assign isAsyncTriggered = TLC_FALSE
  %if ((sysFcn == "OutputUpdate") ||  (sysFcn == "Output")) && ...
    TYPE(system.CurrentTID) == "Number" && system.CurrentTID > 0 && ...
    ISFIELD(SampleTime[system.CurrentTID],"EntryFcnName") && ...
    !ISEMPTY(SampleTime[system.CurrentTID].EntryFcnName) && ...
    !SLibNonInlinedIRTEventTID(system.CurrentTID) && ...
    isRootOrMdlRefBaseSystem
    %if LibAsynchronousTriggeredTID(system.CurrentTID) && isRootOrMdlRefBaseSystem
      %assign isAsyncTriggered = TLC_TRUE
    %endif
    %if !getFcnNameFromFPC
      %assign ::FcnRec.Name = SampleTime[system.CurrentTID].EntryFcnName
    %endif
    %if SLibIsExplicitTaskingExportFcnRateGrouping(sysFcn,system.CurrentTID) && GenerateClassInterface
      %assign FPC = FcnGetRTWCPPStepPrototypeRecord()
      %assign ::FcnRec.Name = FPC.ModelClassName + "::" + SampleTime[system.CurrentTID].EntryFcnName
    %endif
    %% Added below check for test/toolbox/simulink/sampletimes/tSTO_ExportFcn -lvlTwo_Export_Periodic_FcnCall
    %if !SLibIsExportFcnDiagram() || !LibAsynchronousTriggeredTID(system.CurrentTID) || IsModelReferenceBaseSys(system)
      %assign fcnName = SampleTime[system.CurrentTID].EntryFcnName
    %endif
    %assign updateFcnRecName = TLC_FALSE
    %assign appendTIDToFcnName = TLC_FALSE
    %assign exportFcnMode = TLC_TRUE
  %elseif SLibExplicitTaskingTID(system.CurrentTID)
    %if SLibNonInlinedIRTEventTID(system.CurrentTID) && ((sysFcn == "OutputUpdate") || (sysFcn == "Output"))
      %assign appendTIDToFcnName = TLC_FALSE      
      
      %% If the subsystem is a single rate simulink function with only IRT
      %% rate, don't include reset id in the function name. 
      %assign isSingleRateServer = LibIsServer(system) && LibIsSingleRateSystem(system)
      %if !isSingleRateServer                       
        %if isRootOrMdlRefBaseSystem
          %assign fcnName = "%<::CompiledModel.SampleTime[system.CurrentTID].EntryFcnName>"
        %else
          %assign fieldName = "ModelWideEventFcn" + "%<::CompiledModel.SampleTime[system.CurrentTID].EventSourceName>"
          %if ISFIELD(system, "%<fieldName>") && !ISEMPTY(GETFIELD(system, "%<fieldName>"))
            %assign fcnName = GETFIELD(system, "%<fieldName>")
          %endif
        %endif
        %if IsModelReferenceBaseSys(system) && SLibFcnProtoCtrlActive()
          %% For non-inlined irt (reset) don't use fpc, use the reset id instead.
          %assign ::FcnRec.Name = fcnName          
        %endif        
      %endif      
      
    %elseif SLibNonInlinedModelWideEventTID(system.CurrentTID)
      %assign appendTIDToFcnName = FcnSysModuleIsRateGrouping(system, sysFcn)
    %elseif LibAsynchronousTriggeredTID(system.CurrentTID)
      %% Async fcn-call system is single rate,
      %% Never append tid to fcn name
      %% However, for accelerator simulation, an empty update function
      %% will be generated. The Update function must have a TID appended
      %% to avaoid name clashes with the other update fucntions

      %% the async is the only runtime rates, and the other are all IRTs, never
      %% append tid to fcn name       
      %assign isSingleAsync = TLC_TRUE      
      %assign ssTaskToFirstTid = FcnGetSubsystemTaskToFirstTID(system)
      %foreach idx = SIZE(ssTaskToFirstTid, 1)
        %if ssTaskToFirstTid[idx] != system.CurrentTID && ...
          !SLibInitResetTermEventTID(ssTaskToFirstTid[idx])
          isSingleAsync = TLC_FALSE
          %break
        %endif
      %endforeach
      %assign isSingleAsyncUpdateInAccelOrRAccel = (sysFcn == "Update") && ...
                                                   (Accelerator || isRAccel) && ...
                                                   isSingleAsync
      
      %if ((sysFcn == "OutputUpdate") || (sysFcn == "Output") || !Accelerator) || ...
        isSingleAsyncUpdateInAccelOrRAccel
        %assign appendTIDToFcnName = TLC_FALSE
      %else
        %assign appendTIDToFcnName = FcnSysModuleIsRateGrouping(system, sysFcn)
      %endif
    %else 
      %% Append tid to fcn name if rate grouping
      %%
      %assign appendTIDToFcnName = SLibSystemFcnPeriodicRateGrouping(system, sysFcn)
    %endif
  %elseif SLibIsPeriodicRateGrouping()
    %% Append tid to fcn name if rate grouping
    %assign appendTIDToFcnName = SLibSystemFcnPeriodicRateGrouping(system, sysFcn)
    
    %if appendTIDToFcnName && ...
      ISEQUAL(SolverType, "FixedStep") && FixedStepOpts.TID01EQ
      %assign ssTid = LibGetSubsystemTID(system, TLC_FALSE)
      %if SIZE(ssTid, 1) == 1 && ssTid[0] == 0
        %assign appendTIDToFcnName = TLC_FALSE
      %endif
    %endif
    
    %% Continuous rate related fcn does not need tid in fcn name
    %if SLibContFcnPartitionGrouping(sysFcn) && ...
      SLibIsMappedInDeploymentDiagram(system)
      %assign appendTIDToFcnName = TLC_FALSE
    %endif
    
    %% For export function models, tid 0 functions should not be appended with TID
    %if appendTIDToFcnName && system.CurrentTID == 0 && SLibIsExportFcnDiagram()
        %assign appendTIDToFcnName = TLC_FALSE
    %endif
  %else
    %assign appendTIDToFcnName = TLC_FALSE
  %endif
  %if appendTIDToFcnName
    %assert !WHITE_SPACE(system.CurrentTID)
    
    %if SLibIsExplicitPartitioningTID(system.CurrentTID)
      %% For explicit tasking models (other than export fcn) we want to adjust
      %% the function names to incorporate the task names. Eventually this should
      %% not include the TID, but more codegen support is needed before that can
      %% be enabled.
      %assign fcnName = SLibExplicitPartitioningSystemFcnName(fcnName, system.CurrentTID)
      %assign exportFcnMode = TLC_TRUE
    %else
      %% The TIDn is always concatentated, even for tasked functions.
      %assign fcnName = "%<fcnName>TID%<system.CurrentTID>"
    %endif
  %endif  
  
  %if !getFcnNameFromFPC && updateFcnRecName
    %assign ::FcnRec.Name = fcnName
  %endif

  %% Append TID to output function for CPP class generation
  %if GenerateClassInterface && appendTIDToFcnName
    %assign ::FcnRec.Name = ::FcnRec.Name + "%<system.CurrentTID>"
  %endif

  %assign thisModule = ...
    ::CompiledModel.RTWCGModules.RTWCGModule[system.CGIRModuleIdx]
  
  %assign hasTIDArg = 0
  %assign hasCPIArg = 0
  %assign hasRTMArg = 0
  %assign isSysFcn = TLC_FALSE
  %if ISFIELD(thisModule, "SystemFunctions") && ...
    ISFIELD(thisModule.SystemFunctions, fcnName)
    %assign fcnIndex = GETFIELD(thisModule.SystemFunctions, fcnName)
    %assign thisFcn  = thisModule.Function[fcnIndex]
    %assign hasTIDArg = thisFcn.TIDArgIndex > -1
    %assign hasCPIArg = thisFcn.CPIArgIndex > -1
    %assign hasRTMArg = thisFcn.SimStructArgIndex > -1
    %assign isSysFcn = TLC_TRUE
  %endif
  
  %% If the system is reusable and it already has rtModel as an
  %% argument, don't add it again.
  %assign ResetInRootAccelRAccel = SLibResetOrResetWithInitEventTID(system.CurrentTID) && ...
    LibSystemIsRoot(system) && (Accelerator || isRAccel)
  
  %if (!hasRTMArg || exportFcnMode || ResetInRootAccelRAccel) && ...
    FcnSysNeedAddRTMArg(system, sysFcn)
    %if !FcnSysFcnHasRTM(system, sysFcn)
      %assign locSS = RTMGetModelSS()    
      %if LibSystemIsRoot(system) && (CodeFormat == "S-Function")
        %<FcnAddArgument(::tSimStructType + " *", locSS, locSS)>
      %else
        %<FcnAddArgument(::tSimStructType + " *const ", locSS, locSS)>
      %endif
    %endif
  %endif

  %if !hasCPIArg && LibSystemFcnNeedsCPI(system,sysFcn)
    %if SLibAutosarCompilerAbstractionRequired()
      %<FcnAddArgumentWithCompilerAbstraction(TLC_FALSE, "int_T", TLC_FALSE, TLC_FALSE, ::tControlPortIdx, ...
        ::tControlPortIdx)>
    %else
      %<FcnAddArgument("int_T ", ::tControlPortIdx, ...
        ::tControlPortIdx)>
    %endif
  %endif

  %if !hasTIDArg && !isAsyncTriggered && LibSystemFcnNeedsTID(system,sysFcn)
    %<SLibSetTIDAddedInTLC(system)>
    %if SLibAutosarCompilerAbstractionRequired()
      %<FcnAddArgumentWithCompilerAbstraction(TLC_FALSE, "int_T", TLC_FALSE, TLC_FALSE, ::tTID, tTID)>
    %else
      %<FcnAddArgument("int_T ",::tTID, tTID)>
    %endif
  %endif

  %assign ::FcnRec.CommonPrms = ::FcnRec.Params

  %assign fcnPrototype = ""
  %assign fcnReturns = ""
  %assign isRateGroupedSLF = SLibIsRateGroupedSLFcn(system, sysFcn, system.CurrentTID)
  %assign isServiceFcn = SLibIsServiceFcn(system, sysFcn, system.CurrentTID)
  %if exportFcnMode && (isRateGroupedSLF || isServiceFcn)
    %% A rate grouped Simulink function's prototype is fully defined
    %% in IR (with the exception of the C++ class name). So, use the
    %% IR defined prototype rather than discarding and recomputing it.
    %assign aFcnPrototype = SLibGetRateGroupedFcnPrototype(thisModule, system.CurrentTID)
    %assign fcnName = aFcnPrototype.Name
    %assign fcnPrototype = aFcnPrototype.Prototype
    %assign cgirParams = aFcnPrototype.Params
    %assign fcnReturns = aFcnPrototype.Return
    %if !ISEMPTY(fcnName) && SLibAutosarCompilerAbstractionRequired()
      %% return type will be added later in this function
      %assign fcnPrototype = fcnName + "(" + cgirParams
      %assign ::FcnRec.Returns = fcnReturns
    %else
      %assign ::FcnRec.Returns = ""
    %endif
    %if !ISEMPTY(fcnName) && GenerateClassInterface
      %assign fcnPrototype = fcnReturns + " " + ::FcnRec.Name + "(" + cgirParams 
    %endif
    %assign ::FcnRec.Params = cgirParams
  %endif

  %% The rate grouped Simulink function's prototype is
  %% fully defined in IR. However, blockI/O and parameters are still
  %% using classic arg tracking. We still need to call FcnAddParametersAndReturn
  %% to handle those args. We can skip calling FcnAddParametersAndReturn 
  %% if C++ is being generated since these are class members.
  %if !LibSystemIsInlined(system) && !isRoot && (!isRateGroupedSLF || !GenerateClassInterface)
    %<FcnAddParametersAndReturn(sysFcn, fcnName, sysIdx, isRateGroupedSLF)>
  %endif
  
  %if ISEMPTY(::FcnRec.Returns) && !isRateGroupedSLF && !isServiceFcn
    %assign ::FcnRec.Returns = "void"
  %endif
  
  %% non-reusable non-inlined subsystem functions can also be part of the
  %% model class; its prototype may or may not have a classname:: prefix
  %% depending on it is in the declaration position (in class) or definition
  %% position (in .cpp).
  %assign nonReuseFcnAsMemFcn = SLibGenNonReusableSubsysFcnAsClassMemFcn(system)
  %assign optClassNamePrefix = ""
  %if nonReuseFcnAsMemFcn
    %assign FPC = FcnGetRTWCPPStepPrototypeRecord()
    %assign optClassNamePrefix = FPC.ModelClassName + "::"
  %endif
  %assign isSubFunction = SLibIsFcnSubFunction(system, sysFcn)
  %if (SLibIsMultiInstanceServer(system) || ...
    (thisModule.SimplifiedInterface && IsModelReferenceBaseSys(system) && !nonReuseFcnAsMemFcn)) ...
    && ISEMPTY(::FcnRec.Params) && !GenerateClassInterface && !isOutlinedBlockFcn && !isSubFunction
    %assign ::FcnRec.Params = "%<tSimStructType> * const %<tSimStruct>"
  %endif  
 
  %assign statQual = ""
  %if isRoot && RootBodyMthsStatic && !nonReuseFcnAsMemFcn & !exportFcnMode
      %assign statQual = "static "
  %endif
  
   %if(CGMODEL_ACCESS("CGModel.AddStaticKeywordToFcn"))
    %if FcnUseStaticStorageSpecifier(system) && !SLibSystemHasExportedFunction(system)
      %assign statQual = "static "
    %endif
  %endif
  
  %% If generating C++ and the function isn't static (thus limiting visibility
  %% to a single file) then extern "C" it because it will be called from the
  %% static <target>_main.c file.
  %assign cppStorageClass = ""
  %if GenCPP && isRoot && (statQual == "") && !nonReuseFcnAsMemFcn
      %assign cppStorageClass = ExternCPrefix + " "
  %endif

  %if (sysFcn == "Initialize" || sysFcn == "SystemInitialize" || sysFcn == "SystemReset" || sysFcn == "Start" || sysFcn == "Terminate")
    %assign msFcnType = "MemSecFuncInitTerm"
  %else
    %assign msFcnType = "MemSecFuncExecute"
  %endif
  
  %% Create function opening:
  %% pre-pragma + qualifiers + function prototype
  %% We need to add pre-processor conditionals into the record so that the callee knows
  %% about the pre-processor condition in prototype. Note that this record will go into 
  %% "OutputUpdateFcnInfo"in system scope. The existsing 'SLibIfVariantConditionForm16b'
  %% doesn't return the pre-processor conditionals for export functions, so we have to 
  %% use the root inport CGVCE (propagated variant condition) set for a particular TID.
  %% This information lives in CodeVariants and populated from root input function-call 
  %% generator block.
  %assign ppIf = ""
  %if exportFcnMode == 1
    %assign ppIf = SLibVariantConditionForTID(system.CurrentTID)
  %endif
  %openfile open
  %if !ISEMPTY(ppIf)
    %<SLibIfVariantConditionForm16b(ppIf)>
  %endif
  %<SLibIfSystemVariantCondition16b(system)>
  %<SLibIfSystemPreprocessorCondition(system)>
  %assign useIndividualMapping = TLC_FALSE
  %assign functionType = ""
  %assign functionId = "" %% Assume
  %assign isImplicitStepOutputOrUpdateFcn = TLC_FALSE
  %if CGMODEL_ACCESS("CGModel.isIndividualFunctionMappingEnabled")
    %if IsModelReferenceTarget()
      %% Model Reference build
      %if (sysFcn == "ModelInitialize") && TLC_FALSE
        %% Initialize function    
        %% NOTE: Skip this (this is re-computed in ertreg.tlc)
        %assign functionType = "Initialize"
        %assign useIndividualMapping = TLC_TRUE
      %elseif (sysFcn == "Terminate") 
        %% Terminate function 
        %assign functionType = "Terminate"
        %assign useIndividualMapping = TLC_TRUE
      %elseif (sysFcn == "OutputUpdate") || (sysFcn == "Output") || ...
        (sysFcn == "Update") 
        %if SLibExplicitTaskingTID(system.CurrentTID)
          %if SLibResetOrResetWithInitEventTID(system.CurrentTID)
            %% Reset function
            %assign functionType = "Reset"
            %assign functionId = SampleTime[system.CurrentTID].EventSourceName    
            %assign useIndividualMapping = TLC_TRUE
          %elseif SLibIsRateGroupedSLFcn(system, sysFcn, system.CurrentTID)
            %% Global or Public Simulink Function in export function model
            %assign functionType = "SimulinkFunction"
            %assign functionId = SLibGetRateGroupedSimulinkFunctionName(system, sysFcn, system.CurrentTID)
            %assign useIndividualMapping = TLC_TRUE
          %elseif !LibIsServer(system) && ...
            SLibIsExplicitTaskingExportFcnRateGrouping(sysFcn, system.CurrentTID)                    
            %% Export or Async function
            %% NOTE: SampleTime[tid].TaskName returns block name for export function,
            %%  and full block path for async function
            %assign functionType = "FcnCallInport"
            %assign functionId = FEVAL("regexprep", ...
              SampleTime[system.CurrentTID].TaskName, ".*\/", "")
            %assign useIndividualMapping = TLC_TRUE
          %endif
        %else
          %if !SLibIsExportFcnDiagram()
            %if (LibIsGlobalServer(system) || SLibIsModelScopedServer(system))
              %% Global or Exported Global Scoped Function in a rate-based model
              %assign functionType = "SimulinkFunction"
              %assign functionId = SLibGetSimulinkFunctionNameInNonExportFcnModel(system)    
              %assign useIndividualMapping = TLC_TRUE
            %elseif !LibIsServer(system)
              %% Implicit periodic functions
              %if (sysFcn == "OutputUpdate")
                %assign functionType = "Step"                            
              %elseif (sysFcn == "Output")
                %assign functionType = "Output"
              %elseif (sysFcn == "Update") 
                %assign functionType = "Update"
              %endif
              %assign functionId = system.CurrentTID
              %assign useIndividualMapping = TLC_TRUE
              %assign isImplicitStepOutputOrUpdateFcn = TLC_TRUE
            %endif
          %endif
        %endif
      %endif
    %else
      %% Top Model build
      %if (LibIsGlobalServer(system) || SLibIsModelScopedServer(system))
        %% Global or Exported Global Scoped Function in a rate-based model
        %assign functionType = "SimulinkFunction"
        %assign functionId = SLibGetSimulinkFunctionNameInNonExportFcnModel(system)    
        %assign useIndividualMapping = TLC_TRUE
      %endif
    %endif
  %endif
  
  %assign memSecUUID = ""
  %if useIndividualMapping
    %assign memSecUUID = SLibGetFcnMemSecUUIDForFunction(functionType, functionId)
    %if isImplicitStepOutputOrUpdateFcn && !SLibFcnProtoCtrlActive() && ...
      IsModelReferenceRTWTarget() && IsModelReferenceBaseSys(system)
      %% Update function name using name stored in the mapping.
      %% Only needed for model reference output/update functions. Handling is 
      %% done else where for other functions.
      %assign ::FcnRec.Name =  CGMODEL_ACCESS("CGModel.getModelEntryFunctionName", "%<functionType>", "%<functionId>")
    %endif
    %<SLibGetFcnMemSecPragmaForFunction(::FcnRec.Name, functionType, functionId,  "Pre")>\
  %else
    %<SLibGetFcnMemSecPragmaForSystem(::FcnRec.Name, msFcnType, "Pre", system)>\
  %endif
  
  %if ISEMPTY(fcnPrototype)
    %if ISEMPTY(::FcnRec.Params)
      %if !nonReuseFcnAsMemFcn
        %assign fcnPrototype = fcnPrototype + ::FcnRec.Name + "(void)"
      %else
        %% C++ conventions is not to use 'void' for empty param function prototype
        %assign fcnPrototype = fcnPrototype + ::FcnRec.Name + "()"
      %endif %% !nonReuseFcnAsMemFcn
    %else
      %assign fcnPrototype = ::FcnRec.Name + "(" + ::FcnRec.Params + ")"
    %endif %% ISEMPTY(::FcnRec.Params)
  %endif  
  
  %if SLibAutosarCompilerAbstractionRequired()
    %if SLibAutosarIsMultiRunnableFcn(::FcnRec.Name)
      %assign memclass = "FuncCalledByRTE"
    %else
      %assign memclass = "FuncInternal"
    %endif

    %<cppStorageClass> %<statQual> %<SLibAutosarCompilerAbstractionForFcnDeclRtnType(::FcnRec.Returns, memclass, memSecUUID)> %<optClassNamePrefix>%<fcnPrototype>
  %else
    %<cppStorageClass> %<statQual> %<::FcnRec.Returns> %<optClassNamePrefix>%<fcnPrototype>
  %endif
  {
  %closefile open

  %% Create function closing
  %openfile close
  }
  %if useIndividualMapping
    %<SLibGetFcnMemSecPragmaForFunction(::FcnRec.Name, functionType, functionId,  "Post")>\
  %else
    %<SLibGetFcnMemSecPragmaForSystem(::FcnRec.Name, msFcnType, "Post", system)>\
  %endif
  %<SLibEndIfSystemPreprocessorCondition(system)>
  %<SLibEndIfSystemVariantCondition16b(system)>
  %if !ISEMPTY(ppIf)
    %<SLibEndIfVariantConditionForm16b(ppIf)>
  %endif

  %closefile close
  
  %assign begin = ""
  
  %%
  %% For root methods in S-function format, we may need a 
  %% # define before the method. We cache that here
  %%
  %assign sfcnFormDefine = ""
  %if isRoot && (CodeFormat == "S-Function")
    %%
    %% For S-Function target (right click build), add
    %% '#define MDL_INITIALIZE_CONDITIONS' before root systemInitialize
    %% since S-Function block should have block initialize method
    %% instead of systemInitialize and systemReset.
    %%
    %if sysFcn == "SystemInitialize" && !Accelerator
      %assign sfcnFormDefine = FcnGetSfcnFormDefine("Initialize")
    %else
      %assign sfcnFormDefine = FcnGetSfcnFormDefine(sysFcn)
    %endif
  %endif
  
  %assign name = sysFcn + "FcnInfo"
  %if SLibAutosarCompilerAbstractionRequired()
    %if SLibAutosarIsMultiRunnableFcn(::FcnRec.Name)
      %assign memclass = "FuncCalledByRTE"
    %else
      %assign memclass = "FuncInternal"
    %endif
    
    %assign fcnPrototype = SLibAutosarCompilerAbstractionForFcnDeclRtnType(::FcnRec.Returns, memclass, memSecUUID) + " " + fcnPrototype
  %else
    %assign fcnPrototype = ::FcnRec.Returns + " " + fcnPrototype
  %endif
  
  %if ISEMPTY(::FcnRec.Returns)
    %if !ISEMPTY(fcnReturns)
      %assign ::FcnRec.Returns = fcnReturns
    %else
      %assign ::FcnRec.Returns = "void"
    %endif
  %endif
  
  %createrecord %<name> \
  { \
    SysFcn         sysFcn; \
    Name           ::FcnRec.Name; \
    CGIRName       fcnName; \
    Returns        ::FcnRec.Returns;\
    Params         ::FcnRec.Params; \
    CommonPrms     ::FcnRec.CommonPrms; \
    CommonArgs     ::FcnRec.CommonArgs; \
    FcnPrototype   fcnPrototype; \
    SfcnFormDefine sfcnFormDefine; \
    Open           open; \
    Begin          begin; \
    Close          close \
  }
  %return %<name>
%endfunction 

%function SLibSystemFcnIsExtern(system, tid, fcn) void
  %return SLibSystemIsModelEntryPoint(system, tid) && ...
    (fcn == "Output" || fcn == "OutputUpdate" || fcn == "UpdateContStates" || ...
    fcn == "Enable" || fcn == "Disable")
%endfunction

%% Function: SLibSystemFcnIsModelEntryPoint
%%  
%function SLibSystemIsModelEntryPoint(system, tid) void
  %assign retVal = TLC_FALSE
  %if  ExportFunctionsMode == 1
    %assign retVal = (system.Type == "function-call" && system.Exported == "yes" )
  %else
    %if ExportFunctionsMode == 2 && system.Type == "function-call" && ...
      system.DescSysNonTrigTID[0] >= NumRuntimeExportedRates 
      %assign retVal = TLC_TRUE
    %endif
    %if LibSystemIsRoot(system) %%|| IsModelReferenceBaseSys(system)
      %if  SLibFcnProtoCtrlActive() || SLibAutosarActive() || ...
        LibIsDeploymentDiagram() || SLibIsAsyncTaskOnlyModel()
         %assign retVal = TLC_FALSE
      %else
        %if SLibIsPeriodicRateGrouping() && SLibNeedExternRootSysRateGroupingFcn()
          %if TYPE(tid) == "Number" && !((tid == 1)&&Tid01Eq) && ...
            (!LibAsynchronousTriggeredTID(tid) || SLibNonInlinedModelWideEventTID(tid))
            %assign retVal = TLC_TRUE
          %endif
        %else
          %% solver always call rate grouped function if rate grouping is on
          %assign retVal = ISEQUAL(tid,"") || ...
            (SLibIsPeriodicRateGrouping() && ISEQUAL(tid,0) && NumContStates > 0)
        %endif
      %endif
    %endif
  %endif
  %return retVal
%endfunction

%% Function: SLibGetFcnInfoForFcnName ==========================================
%% Abstract:
%%    Return fcnInfo record of the system and a given function name.
%%
%function SLibGetFcnInfoForFcnName(aSystem, aFcnName) void
  %assign fieldName = "CGIR_" + aFcnName + "_FcnInfo"
  %if LibIsSystemField(aSystem, fieldName)
    %return  LibGetSystemField(aSystem, fieldName)
  %endif
  %return ""
%endfunction

%% Function: LibDefineSystemFcnForTID ==========================================
%% Abstract:
%%   Cache a record in the system scope so that the subsystem block
%%   (who calls the function) knows the prototyped.          
%%
%%   Arguments:
%%      system: Simulink system
%%      sysFcn: The system function to define
%%                  o Initialize
%%                  o Output
%%                  o Update
%%                  o OutputUpdate
%%                  o Derivative
%%                  o Enable
%%                  o Disable
%%      fcnRec: Reference to fcnRec (see top of file for definition of record)
%%
%%
%%   Example:
%%      %assign fcnRec.Name    = "foo"
%%      %assign fcnRec.Returns = "void"
%%      %assign fcnRec.Params  = "int_T tid"
%%      %assign fcnRec.Args    = "tid"
%%
%%      %<LibDefineSystemFcnForTID(system, "OutputUpdate", tid)>
%%
%%      Creates a function information record in the system scope:
%%
%%      System {
%%        :
%%        OutputUpdateFcnInfo {
%%          Name         "foo"
%%          Returns      "void"
%%          Params       "int_T tid"
%%          Args         "tid"
%%          fcnCall      "foo(tid)"
%%          fcnPrototype "void foo(int_T tid)"
%%       }
%%
%function LibDefineSystemFcnForTID(system, sysFcn,tid) void
  %assign system.CurrentTID = tid
  %assign isRateGrouping = SLibSystemFcnPeriodicRateGrouping(system, sysFcn) || ...
    (LibAsynchronousTriggeredTID(system.CurrentTID) && ...
    (sysFcn == "Output" || sysFcn == "Update" || sysFcn == "OutputUpdate"))
  %assign fcnRecord = SLibSystemFcnInfoRecord(system, sysFcn)
  
  %assign fieldName = "CGIR_" + fcnRecord.CGIRName + "_FcnInfo"
  %if !LibIsSystemField(system, fieldName)
    %<LibAddToSystem(system, fieldName, fcnRecord)>
  %elseif (TYPE(tid) == "Number" && tid < NumRuntimeExportedRates)
    %% Call it, just to get error message
    %<LibAddToSystem(system, fieldName, fcnRecord)>
  %else
    %assign needToStop = IsModelReferenceBaseSys(system) && ISEMPTY(tid) && ...
      (sysFcn == "Output" || sysFcn == "Update" || sysFcn == "OutputUpdate")
    %if needToStop
      %return
    %endif
  %endif
  
  %if isRateGrouping && TYPE(system.CurrentTID) == "Number"
    %% Set up the global vars for this system and function, this
    %% is needed for nonreusable functions that live in reusable functions
    %assign globalVars = LibInitializeGlobalVars(system, sysFcn)
    %if SLibIsPartitionGrouping()
      %assign pidVec =  SLibGetPidFromTid(system.CurrentTID)
      %foreach i = SIZE(pidVec, 1)
        %<LibSetSystemField(system, ...
          "Cached%<sysFcn>%<system.CurrentTID>%<pidVec[i]>GlobalVars",  globalVars)>
        %<LibAddToSystem(system,...
          "%<sysFcn>TID%<system.CurrentTID>PID%<pidVec[i]>FcnInfo", fcnRecord)>
      %endforeach
    %else
      %<LibSetSystemField(system, ...
        "Cached%<sysFcn>%<system.CurrentTID>GlobalVars",  globalVars)>
      %<LibAddToSystem(system,...
        "%<sysFcn>TID%<system.CurrentTID>FcnInfo", fcnRecord)>
    %endif
  %else
    %% Set up the global vars for this system and function, this
    %% is needed for nonreusable functions that live in reusable functions
    %assign globalVars = LibInitializeGlobalVars(system, sysFcn)
    %if !ISEMPTY(globalVars) && !WHITE_SPACE(globalVars)
      %<LibSetSystemField(system, "Cached"+sysFcn+"GlobalVars",  globalVars)>
    %endif
    %<LibAddToSystem(system, sysFcn + "FcnInfo", fcnRecord)>
  %endif
  
  %if LibSystemIsInlined(system)
    %% If inlining reassign Open and FcnCall
    %openfile declarebuf
    %<LibDumpSystemSSVars(system,sysFcn)>\
    %if isRateGrouping
      %<LibGetSystemLocalVars(system, sysFcn, system.CurrentTID)>
      %if sysFcn == "OutputUpdate"
        %<SLibGetFcnLocalVars(system, "Output", system.CurrentTID)>
        %assert ISEMPTY(SLibGetFcnLocalVars(system, "Update", system.CurrentTID))
      %else
        %<SLibGetFcnLocalVars(system, sysFcn, system.CurrentTID)>      
      %endif
    %else
      %<LibGetSystemLocalVars(system, sysFcn, "")>
      %if sysFcn == "OutputUpdate"
        %<SLibGetFcnLocalVars(system, "Output", "")>
        %assert ISEMPTY(SLibGetFcnLocalVars(system, "Update", ""))
      %else
        %<SLibGetFcnLocalVars(system, sysFcn, "")>      
      %endif
    %endif
    %closefile declarebuf
    %if LibSystemUserCodeIsEmpty(system,sysFcn,"Header") && ...
      WHITE_SPACE(declarebuf)
      %assign needOutputsBrace = 0
    %else
      %assign needOutputsBrace = 1
    %endif
    %if needOutputsBrace
      %assign fcnRecord.Open = "{\n"
      %assign fcnRecord.Begin = "\n"
      %assign fcnRecord.Close = "}\n"
    %else
      %assign fcnRecord.Open  = ""
      %assign fcnRecord.Begin = ""
      %assign fcnRecord.Close = ""
    %endif    
  %else
    %if (!LibSystemFcnIsEmptyHelper(system,sysFcn,tid)) || ...
      (system.Type == "function-call" && sysFcn == "OutputUpdate" && ...
      (ISEQUAL(tid,FcnGetSubsystemTID(system,TLC_TRUE))  || (GenerateClassInterface && !LibIsServer(system) && !SLibModelWideEventTID(tid) )))
      %% Only dump the prototype if the caller does not live
      %% in the same file or it is a Async sfcn.
      %assign isMdlRefBaseAndIsAsyncTID = ...
        IsModelReferenceBaseSys(system) && LibAsynchronousTriggeredTID(tid) && !SLibNonInlinedModelWideEventTID(tid)
      %% Need to delay the caching of the start fcn prototype until after output fcn
      %% has been processed. Output fcn can indicate the need for model params to be initialize
      %% in the start fcn. The prototype of the start fcn is formed by the need of those
      %% params. The prototype is later cached in commonbodlib.tlc
      %assign isMdlRefStart = IsModelReferenceBaseSys(system) && SLibIsExportFcnDiagram() && sysFcn == "Start"
      %assign simulinkFunctionPrototypeInModelHeader = SLibIsRateGroupedSLFcn(system, sysFcn, tid) && ...
        !SLibRateGroupedSimulinkFunctionNeedsDeclaration(system, sysFcn, tid)

      %if (system.Type != "root") && ...
        (!isMdlRefBaseAndIsAsyncTID || ...
          SLibIsExplicitTaskingExportFcnRateGrouping(sysFcn,tid) || ...
          simulinkFunctionPrototypeInModelHeader) && ...
        !SLibSystemFcnIsExtern(system, tid, sysFcn) && ...
        !isMdlRefStart
        %<LibCacheSubsystemPrototype(system,fcnRecord)>\
      %endif
    %endif
  %endif
  %assign system.CurrentTID = -1
%endfunction %% LibDefineSystemFcnForTID

%% Model reference base system has separate entry points for 
%% tid 0 and 1, even if tid01eq.
%function FcnAddMdlRefTid1Interface(system, tid)
  %return ISEQUAL(tid,0) && ...
    ISEQUAL(::CompiledModel.SolverType, "FixedStep") && ...
    (LibGetTID01EQ() == 1) && ...
    IsModelReferenceBaseSys(system)
%endfunction
  
%% Function: LibDefineSystemFcn ================================================
%% Description:
%%   Call LibDefineSystemFcn to Cache record(s) in the system scope 
%%   so that the subsystem block (who calls the function) knows 
%%   the prototyped. When SLibSystemFcnPeriodicRateGrouping( is true, records are
%%   cached very each tid function call. If partition grouping is on,
%%   records are cached for each pair <tid, pid> function call.
%%
%function LibDefineSystemFcn(system, sysFcn) void
  %if sysFcn == "Output" || sysFcn == "Update" || ...
    sysFcn == "OutputUpdate" || ...
    (SLibContFcnPartitionGrouping(sysFcn) && ...
    SLibDeploymentDiagramIsMapped(system.SystemIdx))
    %assign ssTaskToFirstTid = FcnGetSubsystemTaskToFirstTID(system)
    %% Currently, we need to make sure that base system for mdlref gets 
    %% tid 0 for argument tracking otherwise 
    %% t/t/simulink/sltools/raccel/mg544769_raccell fails
    %if IsModelReferenceBaseSys(system) && ...
      (ISEMPTY(ssTaskToFirstTid) || ssTaskToFirstTid[0] != 0)
      %assign tid = FcnGetCodeCacheTid(system, sysFcn, 0)
      %<LibDefineSystemFcnForTID(system, sysFcn, tid)>
    %endif
    %foreach idx = SIZE(ssTaskToFirstTid, 1)
      %assign tid = FcnGetCodeCacheTid(system, sysFcn, ssTaskToFirstTid[idx])
      %% Reset, Terminate (in mdlrefsim), and reset with init event have no update functions.
      %% Do not cached continuous rate related fcn records if tid is not 0,
      %% we hit this because of the way we treat tid01eq in partition grouping.
      %if (SLibNonInlinedIRTEventTID(tid) && sysFcn == "Update") || ...
        (SLibContFcnPartitionGrouping(sysFcn) && tid != 0)
        %continue
      %endif
      %<LibDefineSystemFcnForTID(system, sysFcn,tid)>
      %if FcnAddMdlRefTid1Interface(system, tid)
        %<LibDefineSystemFcnForTID(system, sysFcn,1)>
      %endif
    %endforeach
  %else
    %<LibDefineSystemFcnForTID(system, sysFcn, "" )>
  %endif
%endfunction %% LibDefineSystemFcn

%% Function: LibGenSubsystemFcnCall ============================================
%% Abstract:
%%   Generates a function call to a system.
%%
%% Arguments:
%%  outAndRuleIdx - a two-elements vector of string for actual arguments of output idx
%%                  and rule idx. use [] if the fcn is not SetDims fcn.
%%          canIO - a vector of strings for actual arguments of canonical I/O,
%%                  use [] normally works.
%%        fcnInfo - contains the function name and the type of the call
%%                  (e.g. "Start, Output, Update, ...")
%%   parentSysIdx - location of the system call
%%                  (Where the function is called)
%%         sysIdx - system to be called
%%    callSiteIdx - system instance to be used   
%%
%function LibGenSubsystemFcnCall(canIO, fcnInfo, parentSysIdx, sysIdx, callSiteIdx) void
  %if ISEMPTY(fcnInfo)
    %return ""
  %endif
  %assign accessSysIdx = System[parentSysIdx].HStructDeclSystemIdx
  %assign genModelRef = ...
    IsModelReferenceTarget() && accessSysIdx == ::CompiledModel.NumSystems-1
  
  %assign addArgs = FcnGetAdditionalArgs(fcnInfo.CGIRName, canIO, ...
    fcnInfo.SysFcn, sysIdx, accessSysIdx, callSiteIdx, genModelRef, TLC_FALSE)
  %assign comArgs = fcnInfo.CommonArgs
  %assign cs = System[sysIdx].CallSites[callSiteIdx]
  %assign ssBlk = System[cs[2]].Block[cs[3]]
  %%
  %assign comma = (WHITE_SPACE(addArgs) || WHITE_SPACE(comArgs)) ? "" : ", "
  %%
  %% If one or more of arguments of a function that is passed by address
  %% is a expression, than the result of this expression has to be stored
  %% in a temporrary variable. The address of the temporary variable will
  %% than be passed as the argument of the function call.
  %%
  %if (fcnInfo.SysFcn == "OutputUpdate") && ...
    IsModelReferenceBaseSys(System[sysIdx]) && ...
    SLibFcnProtoCtrlActive() 
    %assign FPC = FcnGetFunctionPrototypeRecord()
    %assign fcnName = FPC.FunctionName
  %else
    %assign fcnName = fcnInfo.Name 
  %endif
  %if ISFIELD(ssBlk, "%<fcnInfo.SysFcn>FcnCallCode")
    %assign fcnCallCode = GETFIELD(ssBlk, "%<fcnInfo.SysFcn>FcnCallCode")
    %assign fcnCall = ""
    %openfile fcnCall
    {
      %<fcnCallCode.localPrmDecl>
      %<fcnCallCode.localExpr>
      %<fcnName>(%<comArgs>%<comma>%<addArgs>);
    }
    %closefile fcnCall
    %return fcnCall
  %else
    %if (fcnInfo.Returns == "void")
      %return "%<fcnName>(%<comArgs>%<comma>%<addArgs>);"
    %else 
      %return "%<fcnName>(%<comArgs>%<comma>%<addArgs>)"
    %endif
  %endif
%endfunction

%% Function: FcnGetCanDWorkArg ==================================================
%% Abstract:
%%   Returns a canonical dwork argument for a give argument index, callsite,
%%   access system index and callsite index.
%%
%function FcnGetCanDWorkArg(sysFcn, cs, argIdx, sysIdx, accessSysIdx, callSiteIdx) void
  %%
  %assign parent = System[sysIdx]
  %%
  %% Get the reused function or root
  %%
  %assign callerHStSystem = SLibCallerHStuctDeclSystem(parent, callSiteIdx)
  %assign dwArg = ""
  %assign ssBlk = System[cs[2]].Block[cs[3]]
  
  %with parent 
    %assign cTID = FcnGetCurrentAccessTid()
  %endwith  
  
  %assign accessSystem = ::CompiledModel.System[accessSysIdx]
  
  %if sysIdx == accessSysIdx
    %% For code reuse of multi-mode enable/trigger subsystems,
    %% function FinalizeDims is not called by its parent
    %% subsystem. It is called by its output function.
    %% In the output function, local reference of the canonical
    %% dwork for current dimensions should be used to call the
    %% function FinalizeDims
    %%
    %% Also, output function may also call its enable function 
    %% for the same type subsystems
    %%
    %assert (sysFcn == "FinalizeDims" || sysFcn == "Enable")
    %assert (parent.HStructDeclSystemIdx == sysIdx)
    %assert (callSiteIdx == 0)
    %%
    %% idNum[0] == "dp"
    %%
    %% we want to access a formal argument at the callsite
    %% of sysIdx being called by itself, dp0 tells that it
    %% is the 1st dwork argument of the parent reusable
    %% subsystem, and it is passed in as the argIdx'th
    %% argument of sysIdx.
    %%
    %% the same is true for "D" and "d".
    %%
    %assign canDWorkArgDef = ...
      parent.Interface.CanonicalDWorkArgDef[argIdx]
    %assign dwArg = LibGetRecordIdentifier(canDWorkArgDef)
    %<SLibAccessArgHelper(canDWorkArgDef, "",cTID)>
    %if parent.CrossNoArgFcnBound
      %<SLibAccessArgHelper(canDWorkArgDef, "Global",cTID)>
      %assign dwArg = canDWorkArgDef.GlobalIdentifier
    %endif
  %else
    %assign arg    = ssBlk.CallSiteInfo.CanonicalDWorkArg[argIdx]
    %assign argSrc = arg.SignalSrc %% Di, di or dpi
    %assign idNum  = IDNUM(argSrc)
    %%
    %assert (idNum[0] == "D" || idNum[0] == "d" || idNum[0] == "dp" || idNum[0] == "db")
    %%
    %%
    %assign callerSysIdx = cs[0]
    %assign cross        = System[callerSysIdx].CrossNoArgFcnBound
    %if idNum[0] == "dp" %% uses relative idx
      %assert (callerHStSystem.Type != "Root")
      %%
      %if callerHStSystem.SystemIdx < accessSysIdx
        %assign parentNonReuseSysIdx = System[parent.CallSites[callSiteIdx][0]].ReusedParentSystemIdx
        %assign nonreuseCallerSysIdx = System[parentNonReuseSysIdx].CallSites[cs[1]]
        %assign dwArg = FcnGetCanDWorkArg(sysFcn, nonreuseCallerSysIdx,  idNum[1], ...
          parentNonReuseSysIdx, accessSysIdx, cs[1])
      %else
        %%
        %% If the callerHStSystem is a hidden system for 
        %% Implicit Iterator Subsystem, it might not have 
        %% Interface.CanonicalDWorkArgDef field because it might be
        %% inlined.
        %%
        %assign localSystem = SLibCallerReusedParentSystem(parent, callSiteIdx)
        %assign callerDWork = ...
          localSystem.Interface.CanonicalDWorkArgDef[idNum[1]]
        %assign dwArg   = LibGetRecordIdentifier(callerDWork)
        %<SLibAccessArgHelper(callerDWork, "",cTID)>
        %if cross
          %<SLibAccessArgHelper(callerDWork, "Global",cTID)>
          %assign dwArg = callerDWork.GlobalIdentifier
        %endif
      %endif
    %elseif idNum[0] == "db" %% access buried DWork
      %if callerHStSystem.SystemIdx != accessSysIdx
        %% For dwork in hidden system for Implicit Iterator Subsystem,
        %% callerHStSystem is not accessSys. 
        %assign localSystem = SLibCallerReusedParentSystem(parent, callSiteIdx)
        %assert(localSystem.SystemIdx == accessSysIdx)
      %endif
      %assign dworkAndRec = FcnGetDworkAndRec(argSrc)
      %assign dwRec = dworkAndRec.DWorkRec
      %assign dwArg = ...
        "&" + ...
        FcnCGIRCGVarHelper(dwRec.VarGroupIdx[0], dwRec.VarGroupIdx[1], ...
        cross, accessSysIdx, SLibDWorkWidth(dwRec), "", -1, ...
        "", 0, TLC_FALSE)
    %elseif idNum[0] == "D" || idNum[0] == "d" %% global or local access
      %assign dworkAndRec = FcnGetDworkAndRec(argSrc)
      %assign dwRec       = dworkAndRec.DWorkRec
      %% temporary work around for g494342

      %if idNum[0] == "D" || dwRec.StorageClass != "Auto"
        %% Example,
        %%   Scalar: foo(&DWork.a)
        %%   Wide:   foo(&DWork.b[0])
        %%
        %% if dwork belongs to ExternalInputSize
        %% vargroup, it is actually not a DWork.
        %% this only happens for "D" case, not for
        %% "d", "dp" and "db".       
        %assign dwRec = ::CompiledModel.DWorks.DWork[idNum[1]]
            
        %if !ISFIELD(dwRec, "VarGroupIdx")
          %assign isPointer = dwRec.StorageClass == "ImportedExternPointer" && LibGetRecordWidth(dwRec) == 1
          %assign dwArg = FcnCGIRSimpleCGVarHelper(dwRec.Identifier, ...
              isPointer, %<LibGetRecordWidth(dwRec)>, "", -1, "", 0, TLC_TRUE)
        %elseif LibGetVarGroupCategory(dwRec.VarGroupIdx[0]) == "ExternalInputSize"
          %if CodeFormat == "S-Function" && !Accelerator
            %assign memberIdx = dwRec.VarGroupIdx[1]
            %assign cgTypeIdx = SLibCGVarGroupMemberCGTypeIdx(...
              dwRec.VarGroupIdx[0], ...
              memberIdx)
            %assign dwArg = "&" + FcnCGIRSFcnSizeVarHelper("ssGetCurrentInputPortDimensions", ...
              TLC_FALSE, "const", ...
              cgTypeIdx, memberIdx, %<LibGetRecordWidth(dwRec)>, "", "", 0)
          %else
            %assign varGroup = ...
              ::CompiledModel.VarGroups.VarGroup[dwRec.VarGroupIdx[0]]
            %assign memberIdx = dwRec.VarGroupIdx[1]
            %assign portVarName = FcnSLibCGIRGetVarGroupMemberName(dwRec.VarGroupIdx[0], memberIdx)
            %assign identifier = varGroup.Name + "." + portVarName
            %assign dwArg = FcnCGIRSimpleCGVarHelper(identifier, ...
              TLC_FALSE, %<LibGetRecordWidth(dwRec)>, "", -1, "", 0, TLC_TRUE)
          %endif
        %else
          %assign dwArg = SLibGetGlobalDWorkAddr(idNum[1], cross)
        %endif
      %else %% "d", Auto storage class
        %assert idNum[0] == "d"
        %% Example,
        %%   Scalar: foo(&localDW->a)
        %%   Wide:   foo(localDW->b)
        %%
        %%  If the caller is crossing a function boundary, use
        %%  the global variable instead of localDW.
        %assign dwRec = ::CompiledModel.DWorks.DWork[idNum[1]]
        %assign dwId  = LibGetRecordIdentifier(dwRec)
        %assign dwWidth = SLibDWorkWidth(dwRec)
        %%
        %if cross || callerHStSystem.StandaloneSubsystem
          %if cross
            %assert !callerHStSystem.StandaloneSubsystem
            %<SLibAccessArgHelper(accessSystem.Interface.DWorkArgDef, "Global",...
              cTID)>
            %assign acc = "->"
          %else
            %assign acc = "."
          %endif
          %assign dWIdent = FcnSysVarGroupNonreusedName(accessSystem,"DWork")
          %if dwWidth == 1
            %assign dwArg = "&" + dWIdent + acc + dwId
          %else
            %assign dwArg = dWIdent + acc + dwId
          %endif
        %else
          %if !(GenerateClassInterface && IsModelReferenceBaseSys(callerHStSystem))
            %if dwWidth == 1
              %assign dwArg  = "&localDW->" + dwId
            %else
              %assign dwArg  = "localDW->" + dwId
            %endif
          %else
            %%%% must be C++ encap. MdlRef and calling the subsys fcn
            %%%% from the model reference hidden base subsystem
            %assert IsModelReferenceRTWTarget()
            %if dwWidth == 1
              %assign dwArg  = "&(%<::tDWork>." + dwId + ")"
            %else
              %assign dwArg  = "%<::tDWork>." + dwId
            %endif
          %endif %% !(GenerateClassInterface && IsModelReferenceBaseSys(parent))
        %endif
        %<SLibAccessArgHelper(callerHStSystem.Interface.DWorkArgDef,"",...
          cTID)>
      %endif
    %endif
  %endif
  %return dwArg
%endfunction

%% Function: FcnGetCanDWorkArgs ================================================
%% Abstract: 
%%   
%% Arguments:
%%         sysIdx   - system function to call
%%    callSiteIdx   - system instance to call
%%     accessSysIdx - location of the system call. This can be a function
%%                    or reusable function.
%% Note: If the subsystem is using one of its CanonicalDWork,
%%       and the subsystem is in a reusable function, it must mark 
%%       the corresponding reusable function arg as Accessed. 
%%
%function FcnGetCanDWorkArgs(sysFcn, sysIdx, accessSysIdx, callSiteIdx, ...
  currentTID, isPeriodicRateGrouping, skipCanDWork) void
  %assign thisSystem = ::CompiledModel.System[sysIdx]
  %assign cs    = thisSystem.CallSites[callSiteIdx]
  %assign args  = ""
  %assign comma = ""
  %assign errTxt = "Invalid SignalSrc for CanonicalDWork."
  %assign isTestInterface = ...
    ::CompiledModel.ConfigSet.GenerateTestInterfaces && ...
    ISFIELD(thisSystem, "GenerateReusableWrapper") && ...
    GETFIELD(thisSystem, "GenerateReusableWrapper")
  
  %with thisSystem.Interface
    %foreach argIdx = NumCanonicalDWorkArgDefs
      %%
      %% Canonical DWorks has already been added in IR
      %%
      %if skipCanDWork[argIdx]
        %continue
      %endif
      %%
      %% Canonical dimsize dwork has already been added to args when 
      %% canonical input(s) and output(s) are processed
      %%
      %if SLibGetCanDWorkIsCanDimSizeDWork(argIdx)
        %continue
      %endif
      
      %assign canDWork = CanonicalDWorkArgDef[argIdx]
      %if SysFcnArgNeeded(sysFcn, canDWork, currentTID, isPeriodicRateGrouping)
	%if isTestInterface && ISFIELD(canDWork, "SSGraphicalAPIReference")
            %assign grDS = canDWork.SSGraphicalAPIReference
            %assign args = args + comma + grDS.Name
            %assign comma = ", "
	%else
          %assign args = args + comma + ...
            FcnGetCanDWorkArg(sysFcn, cs, argIdx, sysIdx, accessSysIdx, callSiteIdx)
          %assign comma = ", "
        %endif %% if ConfigSet.GenerateTestInterfaces
      %endif %% if SysFcnArgNeeded
    %endforeach %% argIdx
    %%
  %endwith %% thisSystem.Interface
  %return args
%endfunction %% FcnGetCanDWorkArgs

%% Function: SLibGetCallSitePrmArg =============================================
%% Abstract:
%%   Returns the parameter argument for a given callsite and parmeter index.
%%
%function SLibGetCallSitePrmArg(cs, childPrmIdx) void
  %if System[cs[0]].NumChildPrmArgs == 0
    %return SLibGetCallSitePrmArg(System[cs[0]].CallSites[cs[1]], childPrmIdx)
  %else
    %return System[cs[0]].ChildPrmArg[childPrmIdx]
  %endif
%endfunction %% SLibGetCallSitePrmArg

%% FunctionGetChildPrmArgFromParent  ===========================================
%% Abstract:
%%   This function, for a system's canonical parameter, returns the 
%%   corresponding ChildPrmArg of the parent system. If the parent system 
%%   itself is a reusable function and has the parameter as a canonical param
%%   then the function seeks the true parent of the system. The true parent 
%%   system defines the actual address or value (in case of inlined) of a 
%%   canonical parameter. The true parent's ChildPrmArg contains the actual
%%   address/value of the parameter
%%   For generating test interfaces, we need the actual value/address of a 
%%   canonical parameter instead of its canonical argument string. 
%%
%%  cs: CallSite of the system
%%  childPrmIdx: Index of the ChildPrmArg in the system
%%
%function FunctionGetChildPrmArgFromParent(cs, childPrmIdx) void
  %assign prm = SLibGetCallSitePrmArg(cs, childPrmIdx)
  %if prm.ASTNode.Op == "M_CANPRM_ID"
    %% Canonical param - Top-level Parent defines the memory/value
    %assign sysCS  = System[cs[0]].CallSites[cs[1]]
    %assign ssBlk  = System[sysCS[2]].Block[sysCS[3]]
    %assign argIdx = prm.ASTNode.CanonicalPrmArgDefIdx
    %if ssBlk.CallSiteInfo.NumCanonicalPrmArgs > 0
    %assign childPrmIdx = ...
	  ssBlk.CallSiteInfo.CanonicalPrmArg[argIdx].ChildPrmArgIdx
    %endif
    %% Recurse to get to the top level parent (true parent)
    %assign prm   = FunctionGetChildPrmArgFromParent(sysCS, childPrmIdx)
  %endif
  %return prm
%endfunction

%% Function: SLibGetHStructWithLocalScopeSystemIdx =============================
%% Abstract:
%%   Return the reusable parent system index for a given system index.
%%
%function SLibGetHStructWithLocalScopeSystemIdx(sysIdx)
  %return ::CompiledModel.System[sysIdx].ReusedParentSystemIdx
%endfunction

%% Function: FcnGetCanonicalOutput =============================================
%% Abstract:
%%   Returns the canonical output argument (string) for a given canonical
%%   output index.
%%
%function FcnGetCanonicalOutput(accessSysIdx, aCallSite, coIdx) void
  %assign   systemIdx = aCallSite[0]
  %assign callsiteIdx = aCallSite[1]
  %assign returnVal = ""
  %with ::CompiledModel
    %assign ssBlk = System[aCallSite[2]].Block[aCallSite[3]]
    %assign system = System[systemIdx]
    %assign sysCurrentTid = system.CurrentTID
    %assign system.CurrentTID = CurrentTID %% set system current tid to context current tid
    %with system
      %assign     cross = CrossNoArgFcnBound
      %assign hStrucIdx = SLibGetHStructWithLocalScopeSystemIdx(systemIdx)
      %with ssBlk %% subsystem block
        %assign co = CallSiteInfo.CanonicalOutputArg[coIdx]
        %assign idnum = IDNUM(co.SignalSrc[0])
        %assign oldBlockIdx1 = ssBlk.BlockIdx[1]
        %assign ssBlk.BlockIdx[1] = accessSysIdx
        %if hStrucIdx < accessSysIdx && idnum[0] == "y"
          %assign cs = System[systemIdx].CallSites[callsiteIdx]
          %assign returnVal = FcnGetCanonicalOutput(accessSysIdx, cs, idnum[1])
        %else
          %% canonical output, if is scalar, must pass by addr.
          %assign returnVal = FcnGetCanonicalArg(co, 0, cross, TLC_TRUE)
        %endif
        %assign ssBlk.BlockIdx[1] = oldBlockIdx1          
      %endwith
    %endwith %% System[sysIdx]
    %assign system.CurrentTID = sysCurrentTid
  %endwith
  %return returnVal
%endfunction

%% Function: FcnGetCanonicalInput ============================================
%% Abstract:
%%   Returns the canonical input argument (string) for a given canonical
%%   input index.
%%
%function FcnGetCanonicalInput(accessSysIdx, aCallSite, ciIdx) void
  %assign   systemIdx = aCallSite[0]
  %assign callsiteIdx = aCallSite[1]
  %assign returnVal = ""
  %with ::CompiledModel
    %assign ssBlk = System[aCallSite[2]].Block[aCallSite[3]]
    %assign system = System[systemIdx]
    %assign sysCurrentTid = system.CurrentTID
    %assign system.CurrentTID = CurrentTID %% set system current tid to context current tid
    %with system
      %assign     cross = CrossNoArgFcnBound
      %assign hStrucIdx = SLibGetHStructWithLocalScopeSystemIdx(systemIdx)
      %with ssBlk %% subsystem block
        %assign ci = CallSiteInfo.CanonicalInputArg[ciIdx]
        %assign idnum = IDNUM(ci.SignalSrc[0])
        %assert idnum[0] != "F"
        %assign oldBlockIdx1 = ssBlk.BlockIdx[1]
        %assign ssBlk.BlockIdx[1] = accessSysIdx
        %if hStrucIdx < accessSysIdx && (idnum[0] == "u" || idnum[0] == "y")
          %assign cs = System[systemIdx].CallSites[callsiteIdx]
          %if idnum[0] == "u"
            %assign returnVal = ...
              FcnGetCanonicalInput(accessSysIdx, cs, idnum[1])
          %else
            %assign returnVal = ...
              FcnGetCanonicalOutput(accessSysIdx, cs, idnum[1])
          %endif          
        %else
          %assign ssBlkSysIdx = LibBlockParamSetting("Subsystem", "SystemIdx")
          %if LibGetRecordWidth(ci) == 1 && SLibGetISSCanInputIter(ssBlkSysIdx, ciIdx)
            %% If the canonical input is for an Implicit Iterator subsystem and it is 
            %% a scalar, the scalar signal needs to be returned as reference.
            %assign returnVal = FcnGetCanonicalArg(ci, 0, cross, TLC_TRUE)
          %else
            %assign useAddr =  (ci.DeclareAsPointer == "yes")                        
            %assign returnVal = FcnGetCanonicalArg(ci, 0, cross, useAddr)             
          %endif
        %endif
        %assign ssBlk.BlockIdx[1] = oldBlockIdx1
      %endwith
      %assign system.CurrentTID = sysCurrentTid
    %endwith %% System[sysIdx]
  %endwith
  %return returnVal
%endfunction


%% Function: FcnGetArgForType ============================================
%% Abstract: 
%%   This function generates the argument needed in for a system function 
%%   call based on argument type, e.g. DWork or BlockIO. This is used by
%%   function FcnGetAdditionalArgs
%%   
%% Arguments:
%%  argType      - The type of the argument, e.g. "DWork", "BlockIO"
%%  mdlrefArg    - The string used for model reference, e.g. "&(dw->rtb)"
%%  localArg     - The string for argument passed through parent system
%%                 e.g. "localB"
%%  sysIdx       - system function to call
%%  callSiteIdx  - system instance to call
%%  accessSysIdx - location of the system call
%%  cTID         - current tid
%%
%function FcnGetArgForType(argType, mdlrefArg, localArg, sysIdx, callSiteIdx, accessSysIdx)
  %%
  %% If a system function (e.g. "Start") calls a function of the 
  %% same system (e.g. "Enable"), it has to pass the structured arguments
  %% without adding a substructure element
  %%
  
  %assign thisSystem = ::CompiledModel.System[sysIdx]
  %with thisSystem
    %assign cTID = FcnGetCurrentAccessTid()
  %endwith
  
  %assign genModelRef = IsModelReferenceTarget() && accessSysIdx == NumSystems-1

  %if genModelRef
    %assign arg =  mdlrefArg
  %elseif LibIsPassThroughSubsystemCall(sysIdx, accessSysIdx)
    %assign arg = localArg
    %assign retAccessHelper = SLibAccessArgHelper(%<argType>ArgDef,"",cTID)
    %<retAccessHelper>
  %else
    %assign cs = thisSystem.CallSites[callSiteIdx]
    %assign cross = ::CompiledModel.System[cs[0]].CrossNoArgFcnBound
    %assign varGroupIdx = FcnSysVarGroupIndex(thisSystem, argType, callSiteIdx)
    %assign parentVarGroupIdx = SLibVarGroupParentIndex(varGroupIdx)
    %assign identiPath = SLibCGIRVarGroupPath(parentVarGroupIdx, accessSysIdx, cross)
    %assign indenti = SLibVarGroupName(varGroupIdx)

    %if SLibGetSubsystemIsForEachSS(System[cs[0]])
      %% Callsite is For Each Subsystem
      %assign arg = SLibGetIndexedArgForForEachSS(parentVarGroupIdx, identiPath, indenti, cs, accessSysIdx, sysIdx)
    %elseif SLibIsMatrixVarGroupForIIS(sysIdx, argType)
      %% This subsystem is code reuse For Each subsystem
      %assert SLibGetSubsystemIsForEachSS(thisSystem)
      %assign arg = "%<identiPath>%<indenti>"
    %else    
      %assign arg = "&%<identiPath>%<indenti>"
    %endif
  %endif
  
  %return arg
  
%endfunction

%% Function: FcnGetModelRefInput ==============================================
%% Abstract:
%%   Returns the model reference s-function input argument.
%%
%function FcnGetModelRefInput(thisSystem, argIdx) void
  %assign ci = thisSystem.Interface.CanonicalInputArgDef[argIdx]
  %assign passByRef = LibGetRecordWidth(ci) > 1 || ci.DeclareAsPointer == "yes"
  %assign ptr = passByRef ? "" : "*"
  %return ptr + "InPort_%<argIdx>"
%endfunction %% FcnGetModelRefInput

%% Function: FcnGetModelRefOutput ==============================================
%% Abstract:
%%   Returns the model reference s-function output argument.
%%
%function FcnGetModelRefOutput(argIdx) void
  %return "OutPort_%<argIdx>"
%endfunction %% FcnGetModelRefOutput

%% Function: FcnGetModelRefParameter ===========================================
%% Abstract:
%%   Generate parameter argument as "ParamArg_#" for model reference s-function.
%% 
%function FcnGetModelRefParameter(thisSystem, argIdx) void
  %assign expr = "ParamArg_%<argIdx>"
  %assign canPrmArgDef = thisSystem.Interface.CanonicalPrmArgDef[argIdx]
  %assign isStruct = SLibDeclareStructAsPointer(canPrmArgDef.OriginalDataTypeIdx)
  %if (1 == LibGetRecordWidth(canPrmArgDef)) && (isStruct==TLC_FALSE)
    %return expr + "[0]"
  %endif
  %return expr
%endfunction %% FcnGetModelRefParameter

%function FcnGetModelRefRtm(thisSystem) void
  %return "&(dw->rtm)"
%endfunction

%% Function: FcnGetModelRefBlockIOArg ==========================================
%% Abstract:
%%   Returns the model reference s-function block IO argument.
%%
%function FcnGetModelRefBlockIOArg() void
  %if !SLibGetUseRTMcgType()
    %return "&(dw->rtb)"
  %else
    %return "&(dw->rtm.blockIO)"
  %endif
%endfunction %% FcnGetModelRefBlockIOArg

%% Function: FcnGetModelRefConstBlockIOArg =====================================
%% Abstract:
%%   Returns the model reference s-function constant block IO argument.
%%
%function FcnGetModelRefConstBlockIOArg() void
  %return "rtc_" + ::CompiledModel.Name
%endfunction %% FcnGetModelRefConstBlockIOArg

%% Function: FcnGetModelRefDWorkArg ============================================
%% Abstract:
%%   Returns the model reference s-function dwork argument.
%%
%function FcnGetModelRefDWorkArg() void
  %if !SLibGetUseRTMcgType()
    %return "&(dw->rtdw)"
  %else
    %return "&(dw->rtm.dwork)"
  %endif
%endfunction %% FcnGetModelRefDWorkArg


%% Function: FcnGetModelRefContStatesArg =======================================
%% Abstract:
%%   Returns the model reference s-function continues states argument.
%%
%function FcnGetModelRefContStatesArg() void
  %return "rtx"
%endfunction %% FcnGetModelRefContStatesArg

%% Function: FcnGetModelRefDerivativesArg ======================================
%% Abstract:
%%   Returns the model reference s-function derivatives argument.
%%
%function FcnGetModelRefDerivativesArg() void
  %return "rtxdot"
%endfunction %% FcnGetModelRefDerivativesArg

%% Function: FcnGetModelRefContStatesDisabledArg ===============================
%% Abstract:
%%   Returns the model reference s-function continues states disabled argument.
%%
%function FcnGetModelRefContStatesDisabledArg() void
  %return "rtxdis"
%endfunction %% FcnGetModelRefContStatesDisabledArg

%% Function: FcnGetModelRefContStatesAbsTolArg =================================
%% Abstract:
%%   Returns the model reference s-function continues states absolute tolerance
%%   argument.
%%
%function FcnGetModelRefContStatesAbsTolArg() void
  %return "rtxAbsTol"
%endfunction %% FcnGetModelRefContStatesAbsTolArg

%% Function: FcnGetModelRefNSZCArg =============================================
%% Abstract:
%%   Returns the model reference s-function non-sampled zero crossings argument.
%%
%function FcnGetModelRefNSZCArg() void
  %return "rtzcsv"
%endfunction %% FcnGetModelRefNSZCdArg

%% Function: FcnGetModelRefZCEArg ==============================================
%% Abstract:
%%   Returns the model reference s-functionzero crossing events argument.
%%
%function FcnGetModelRefZCEArg() void
  %return "&(dw->rtzce)"
%endfunction %% FcnGetModelRefZCEdArg
  

%% Function: FcnGetAdditionalArgs ==============================================
%% Abstract: 
%%   This function generates the arguments needed in for a system function 
%%   call. Refer to GetFunctionStr for the order of parameters.
%%   
%% Arguments:
%%  outAndRuleIdx - a two-elements vector of string for actual arguments
%%                  of output idx and rule idx. use [] if the fcn is not
%%                  SetDims fcn.
%%         argVec - a vector of strings for actual arguments (default is [])
%%         sysIdx - system function to call
%%    callSiteIdx - system instance to call
%%     accessSysIdx - location of the system call
%%
%function FcnGetAdditionalArgs(fcnName, argVec, sysFcn, sysIdx, accessSysIdx, callSiteIdx, genModelRef, rtmNeeded) void
  %%
  %% CallSite is misleading in this context. The callsite vector is
  %% defines the memory instances of the function and is
  %% equal to the number of reused instances of a system.
  %%
  %assign thisSystem = ::CompiledModel.System[sysIdx]
  %assign modIdx = thisSystem.CGIRModuleIdx
  %assign thisModule = ::CompiledModel.RTWCGModules.RTWCGModule[modIdx]
  %assign hasSimplifiedInterface = thisModule.SimplifiedInterface
  %assign isRateGroupedSLF = thisSystem.IsRateGroupedSLFcn
  %assign cs = thisSystem.CallSites[callSiteIdx]
  %assign args = ""
  
  %with thisSystem
    %assign cTID = FcnGetCurrentAccessTid()
  %endwith
  
  %assign isRG = SLibSystemFcnPeriodicRateGrouping(thisSystem, sysFcn)
  %with thisSystem.Interface
    %assign comma = ""
    %assign ssBlk = System[cs[2]].Block[cs[3]]
    
    %% We need to reset this so we will use the correct
    %% Interface when accessing canonical inputs and outputs.
    %% See the function SLibGetSourceRecordAndMapInfo in blkiolib.tlc
    %% NOTE: we reset this back after canonical inputs/outputs below.
    %assign saveMe = ssBlk.BlockIdx[1]
    %assign ssBlk.BlockIdx[1] = accessSysIdx
   
    %%
    %% The following TLC code is used to prune the CGIR function call
    %% arguments and transfer the CGIR argument tracking 
    %% information to the legacy TLC tracking infrastructure.
    %%
    %assign skipCanInput = ...
      Vector(%<NumCanonicalInputArgDefs>) [0@%<NumCanonicalInputArgDefs>]
    %assign skipCanOutput = ...
      Vector(%<NumCanonicalOutputArgDefs>) [0@%<NumCanonicalOutputArgDefs>]
    %assign skipCanDWork = ...
      Vector(%<NumCanonicalDWorkArgDefs>) [0@%<NumCanonicalDWorkArgDefs>]
    %assign skipCanParam = ...
      Vector(%<NumCanonicalPrmArgDefs>) [0@%<NumCanonicalPrmArgDefs>]
    
    %assign skipRTM = 0
    %assign skipHStructArgs = LibSystemIsNonReusedFcn(thisSystem)
    %assign skipLocalB = skipHStructArgs || hasSimplifiedInterface
    %assign skipLocalC = skipHStructArgs
    %assign skipLocalDW = skipHStructArgs || hasSimplifiedInterface
    %assign skipLocalP = skipHStructArgs || hasSimplifiedInterface
    %assign skipLocalX = skipHStructArgs
    %assign skipLocalXdot = skipHStructArgs
    %assign skipLocalXdis = skipHStructArgs
    %assign skipLocalXabstol = skipHStructArgs
    %assign skipLocalZCSV = skipHStructArgs
    %assign skipLocalZCE = skipHStructArgs || hasSimplifiedInterface

    %assign skipLocalDataGroup = ...
      Vector(%<::CompiledModel.NumCoderDataGroups>) [%<skipHStructArgs>@%<::CompiledModel.NumCoderDataGroups>]

    %if isRateGroupedSLF && Accelerator
      %% Rate grouped Simulink functions are defined in the root module. Need to get
      %% the Function record from root. FcnGetAdditionalArgs is only
      %% invoked during Accel code gen to create a call to the smiulink function.
      %% (A call to the SLF is not emitted for RTW code gen.)
      %assign rootSystem = ::CompiledModel.System[NumSystems-1]
      %assign rootModIdx = rootSystem.CGIRModuleIdx
      %assign rootModule = ::CompiledModel.RTWCGModules.RTWCGModule[rootModIdx]
      %assign fncExistsInSystem = ISFIELD(rootModule, "SystemFunctions") && ...
        ISFIELD(rootModule.SystemFunctions, fcnName)
      %if fncExistsInSystem
        %assign fcnIndex = GETFIELD(rootModule.SystemFunctions, fcnName)
        %assign thisFcn  = rootModule.Function[fcnIndex]
      %endif
      %% Canonical I/O and RTM are handled in IR. Setting needArgs to false and
      %% skipRTM to true will prevent adding these args twice. The only args
      %% that do not get handled in IR are canonical parameters so we
      %% still need to execute the following loop through args.
      %assign needArgs = TLC_FALSE
      %assign skipRTM = 1
    %else
      %assign fncExistsInSystem = ISFIELD(thisModule, "SystemFunctions") && ...
        ISFIELD(thisModule.SystemFunctions, fcnName)
      %assign fcnIndex = GETFIELD(thisModule.SystemFunctions, fcnName)
      %assign thisFcn  = thisModule.Function[fcnIndex]
      %if thisModule.AccessesArgsGlobally && !thisModule.NeedsSimStruct
        %assign skipRTM = 1
      %endif
      %assign needArgs = LibSystemIsReusedFcn(thisSystem) || ...
        (LibSystemIsNonReusedFcn(thisSystem) && ...
        ISFIELD(thisSystem,"RTWSystemCodeOptIntf")) || ...
        thisSystem.IsService
    %endif      
    
    %if fncExistsInSystem
      %if genModelRef
        %foreach argIdx = SIZE(argVec, 1)
          %assign args = args + comma + argVec[argIdx]
          %assign comma = ", "
        %endforeach
      %endif
      %assert genModelRef || SIZE(argVec, 1) == thisFcn.NumArgs
      %assert SIZE(thisFcn.ArgAccessed, 1) == thisFcn.NumArgs
      %assert SIZE(thisFcn.ArgSource, 1) == thisFcn.NumArgs
      %foreach argIdx=thisFcn.NumArgs
        %assign idNum = SLibSafeIDNUM(thisFcn.ArgSource, argIdx)
        %assign argSrc = idNum[0]
        %assign argSrcIdx = idNum[1]
        %if thisFcn.ArgAccessed[argIdx] || (GenerateClassInterface && argSrc == "LCDG")
          %switch argSrc
            %case "I" %% canonical input
              %if 0 < NumCanonicalInputArgDefs %% CrossNoArgFcnBound
                %if needArgs
                  %if genModelRef
                    %assign args = args + comma + ...
                      FcnGetModelRefInput(thisSystem, argSrcIdx)
                  %else
                    %assign args = args + comma + argVec[argIdx]
                  %endif
                  %assign comma = ", "
                %endif
                %assign skipCanInput[argSrcIdx] = 1
              %endif
              %break
            %case "O" %% canonical output
              %if 0 < NumCanonicalOutputArgDefs %% CrossNoArgFcnBound
                %if needArgs
                  %if genModelRef
                    %assign args = args + comma + ...
                      FcnGetModelRefOutput(argSrcIdx)
                  %else
                    %assign args = args + comma + argVec[argIdx]
                  %endif
                  %assign comma = ", "
                %endif
                %assign skipCanOutput[argSrcIdx] = 1
              %endif
              %break
            %case "D" %% canonical dwork
              %if 0 < NumCanonicalDWorkArgDefs %% CrossNoArgFcnBound
                %if genModelRef
                  %assert ISFIELD(thisFcn, "Association")
                  %assert SIZE(thisFcn.Association, 1) == thisFcn.NumArgs
                  %assign dimsIdNum = SLibSafeIDNUM(thisFcn.Association, argIdx)
                  %assign dimsSrc = dimsIdNum[0]
                  %assign dimsSrcIdx = dimsIdNum[1]
                  %assert "I" == dimsSrc || "O" == dimsSrc
                  %assign prefix = (("I" == dimsSrc) ? "In" : "Out")
                  %assign args = args + comma + ...
                    FcnGetModelRefDWork(prefix, dimsSrcIdx, argSrcIdx)
                %else
                  %assign args = args + comma + argVec[argIdx]
                %endif
                %assign comma = ", "
                %assign skipCanDWork[argSrcIdx] = 1
              %endif
              %break
            %case "P" %% canonical parameter
              %if 0 < NumCanonicalPrmArgDefs %% CrossNoArgFcnBound
                %if genModelRef
                  %assign args = args + comma + ...
                    FcnGetModelRefParameter(thisSystem, argSrcIdx)
                %else
                  %assign args = args + comma + argVec[argIdx]
                %endif
                %assign comma = ", "
                %assign skipCanParam[argSrcIdx] = 1
              %endif
              %break
            %case "RTM"
              %if 0 == skipRTM
                %if GenerateClassInterface
                  %if argVec[argIdx] != "getRTM()"
                    %assign args = args + comma + RTMGetModelSS()
                  %else
                    %assign args = args + comma + argVec[argIdx]
                  %endif
                %elseif genModelRef && !IsModelRefScalableBuild()
                  %assign args = args + comma + ...
                    FcnGetModelRefRtm(thisSystem)
                %else
                  %assign args = args + comma + argVec[argIdx]
                %endif
                %assign comma = ", "
                %assign skipRTM = 1
              %endif
              %break
            %case "LCDG" 
              %% Here, argSrcIdx refers to the index of the coder data group
              %if 0 == skipLocalDataGroup[argSrcIdx] %% CrossNoArgFcnBound
                %if genModelRef
                  %assign args = args + comma + FcnGetModelRefBlockIOArg()
                %else
                  %assign args = args + comma + argVec[argIdx]
                %endif
                %assign comma = ", "
                %assign skipLocalDataGroup[argSrcIdx] = 1
              %endif
              %break
            %case "LB" %% block IO
              %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                %if genModelRef
                  %assign args = args + comma + FcnGetModelRefBlockIOArg()
                %else
                  %assign args = args + comma + argVec[argIdx]
                %endif
                %assign comma = ", "
                %assign skipLocalB = 1
              %endif
              %break
            %case "LC" %% constat block IO
              %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                %if genModelRef
                  %assign args = args + comma + FcnGetModelRefConstBlockIOArg()
                %else
                  %assign args = args + comma + argVec[argIdx]
                %endif
                %assign comma = ", "
                %assign skipLocalC = 1
              %endif
              %break
            %case "LW" %% dwork
              %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                %if genModelRef
                  %assign args = args + comma + FcnGetModelRefDWorkArg()
                %else
                  %assign args = args + comma + argVec[argIdx]
                %endif
                %assign comma = ", "
                %assign skipLocalDW = 1
              %endif
              %break
            %case "LP"  %% parameter
            %case "LCP" %% constant parameter
            %case "LPI" %% const parameter with init
              %assert !genModelRef
              %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                %assign args = args + comma + argVec[argIdx]
                %assign comma = ", "
                %assign skipLocalP = 1
              %endif
              %break
            %case "LX" %% continues states
              %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                %if genModelRef
                  %assign args = args + comma + FcnGetModelRefContStatesArg()
                %else
                  %assign args = args + comma + argVec[argIdx]
                %endif
                %assign comma = ", "
                %assign skipLocalX = 1
              %endif
              %break
            %case "LDX" %% derivatives
              %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                %if genModelRef
                  %assign args = args + comma + FcnGetModelRefDerivativesArg()
                %else
                  %assign args = args + comma + argVec[argIdx]
                %endif
                %assign comma = ", "
                %assign skipLocalXdot = 1
              %endif
              %break
            %case "LXDI" %% continues state disabled
              %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                %if genModelRef
                  %assign args = ...
                    args + comma + FcnGetModelRefContStatesDisabledArg()
                %else
                  %assign args = args + comma + argVec[argIdx]
                %endif
                %assign comma = ", "
                %assign skipLocalXdis = 1
              %endif  
              %break
            %case "LXAT" %% continues state absolute tolerance
              %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                %if genModelRef
                  %assign args = ...
                    args + comma + FcnGetModelRefContStatesAbsTolArg()
                %else
                  %assign args = args + comma + argVec[argIdx]
                %endif
                %assign comma = ", "
                %assign skipLocalXabstol = 1
              %endif
              %break
            %case "LZ" %% non-sampled zero crossings
              %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                %if genModelRef
                  %assign args = args + comma + FcnGetModelRefNSZCArg()
                %else
                  %assign args = args + comma + argVec[argIdx]
                %endif
                %assign comma = ", "
                %assign skipLocalZCSV = 1
              %endif
              %break
            %case "LZE" %% zero crossing events
              %if 0 == skipHStructArgs %% CrossNoArgFcnBound
                %if genModelRef
                  %assign args = args + comma + FcnGetModelRefZCEArg()
                %else
                  %assign args = args + comma + argVec[argIdx]
                %endif
                %assign comma = ", "
                %assign skipLocalZCE = 1
              %endif
              %break
            %case "CPI"
            %case "TID"
              %if !genModelRef
                %assign args = args + comma + argVec[argIdx]
                %assign comma = ", "
              %endif
              %break
            %case "X"
              %if !genModelRef
                %assign args = args + comma + argVec[argIdx]
                %assign comma = ", "
              %endif
              %break
            %case "U"
            %case "Y"
              %if !thisSystem.CrossNoArgFcnBound
                %assign args = args + comma + argVec[argIdx]
                %assign comma = ", "
              %endif
              %break
            %default
              %%START_ASSERT
              %assign errTxt = "Unhandled argument type '%<argSrc>'."
              %break
              %%END_ASSERT              
          %endswitch
        %endif
      %endforeach
    %endif
        
    %%
    %% Only reused systems get arguments (except for elapased time)
    %%
    %if needArgs      
      %assign isTestInterface = ...
        ::CompiledModel.ConfigSet.GenerateTestInterfaces && ...
        ISFIELD(thisSystem, "GenerateReusableWrapper") && ...
        GETFIELD(thisSystem, "GenerateReusableWrapper")
      
      %%
      %% Canonical input argument
      %%
      %foreach argIdx=thisSystem.Interface.NumCanonicalInputArgDefs
        %assign canIn = thisSystem.Interface.CanonicalInputArgDef[argIdx]
        %if !skipCanInput[argIdx] && ...
          SysFcnArgNeeded(sysFcn, canIn, cTID, isRG)
          %%
          %if isTestInterface && ISFIELD(canIn, "SSGraphicalAPIReference")
            %assign grIn = canIn.SSGraphicalAPIReference
            %assign args = "%<args>%<comma>%<grIn.SLName>"
            %assign comma = ", "
          %elseif LibIsPassThroughSubsystemCall(sysIdx, accessSysIdx)
            %assign args = "%<args>%<comma>%<LibGetRecordIdentifier(canIn)>"
            %assign comma = ", "
            %<SLibAccessArgHelper(canIn,"",cTID)>
          %else
            %with System[cs[0]]
              %assign cross = CrossNoArgFcnBound
              %with ssBlk %% subsystem block
                %assign skipThisArg = 0
                %if IDNUM(canIn.SignalSrc[0])[0] == "F"
                  %assign skipThisArg = 1
                %endif	
                %if skipThisArg == 0
                  %if genModelRef
                    %assign args = args + comma + ...
                      FcnGetModelRefInput(thisSystem, argIdx)
                  %else
                    %assign args = args + comma + ...
                      FcnGetCanonicalInput(accessSysIdx, cs, argIdx)
                  %endif
                  %assign comma = ", "
                %endif
              %endwith %% subsystem block
            %endwith %% thisSystem
          %endif %%LibIsPassThroughSubsystemCall(sysIdx, accessSysIdx)

          %% Add vardims argument for the canonical input 
          %assign res = FcnGetAdditionalCanDimSizeDWForCanInp(sysFcn, sysIdx, ...
            accessSysIdx, callSiteIdx, argIdx, comma, args, skipCanDWork)
          %assign comma = res[0]
          %assign args  = res[1]
        %endif %% SysFcnArgNeeded

      %endforeach %% argIdx=NumCanonicalInputArgDefs
      %%
      %% Canonical output argument
      %%
      %foreach argIdx=thisSystem.Interface.NumCanonicalOutputArgDefs
        %assign canOut = thisSystem.Interface.CanonicalOutputArgDef[argIdx]
        %if !skipCanOutput[argIdx] && SysFcnArgNeeded(sysFcn, canOut, cTID, isRG)
          %%
          %if isTestInterface && ISFIELD(canOut, "SSGraphicalAPIReference")
            %assign grOut = canOut.SSGraphicalAPIReference
            %assign args = "%<args>%<comma>%<grOut.SLName>"
          %else
            %if LibIsPassThroughSubsystemCall(sysIdx, accessSysIdx)
              %assign isReference = FcnPassCanonicalOutputAsReference(canOut)
              %if IsModelReferenceBaseSys(thisSystem) && ...
                (SLibFcnProtoCtrlActive() || GenerateClassInterface) && ...
                canOut.DeclareAsPointer == "no" && ... 
                (canOut.PassByReturn == "yes" || isReference) && ...
                  sysFcn != "Output" && sysFcn != "OutputUpdate"
                %%root output is return-by-value, needs to get its address
                %assign args = "%<args>%<comma>&%<LibGetRecordIdentifier(canOut)>" 
              %else
                %assign args = "%<args>%<comma>%<LibGetRecordIdentifier(canOut)>"
              %endif
              %<SLibAccessArgHelper(canOut,"",cTID)>
            %elseif genModelRef
              %assign args = args + comma + FcnGetModelRefOutput(argIdx)
            %else
              %assign args = args + comma + ...
                FcnGetCanonicalOutput(accessSysIdx, cs, argIdx)
            %endif %%LibIsPassThroughSubsystemCall(sysIdx, accessSysIdx)
          %endif %% ConfigSet.GenerateTestInterfaces
          %assign   comma = ", "
          
          %%
          %% Add vardims argument for the canonical output
          %assign res = FcnGetAdditionalCanDimSizeDWForCanOut(sysFcn, sysIdx, ...
            accessSysIdx, callSiteIdx, argIdx, comma, args, skipCanDWork)
          %assign comma = res[0]
          %assign args  = res[1]
        %endif %% SysFcnArgNeeded
        %%
      %endforeach %% argIdx=NumCanonicalOutputArgDefs
      %%
      %% Reset the BlockIdx, see comment above.
      %assign ssBlk.BlockIdx[1] = saveMe
      %assign isScalableMRSys = IsModelReferenceBaseSys(thisSystem) && IsModelRefScalableBuild()
      %%
      %% rtModel argument
      %%
      %if !skipRTM && (SysFcnArgNeeded(sysFcn, RTMArgDef, cTID, isRG) || rtmNeeded) && !isScalableMRSys
        %if genModelRef
          %assign args = "%<args>%<comma>&(dw->rtm)"
        %else
          %assign accessSystem = ::CompiledModel.System[accessSysIdx]
          %assign rtmArg = FcnUpdateRTModelInterfaceArg(accessSystem, GetSimStructExpr(accessSystem, SLibGetSimStruct()))
          %assign args = "%<args>%<comma>%<rtmArg>"
        %endif
        %assign comma = ", "
        %assign callerHStSystem = ...
          SLibCallerHStuctDeclSystem(thisSystem, callSiteIdx)
        %<SLibAccessArgHelper(callerHStSystem.Interface.RTMArgDef,"",cTID)>
      %endif
      %%
      %% Block IO argument
      %%
      %if !skipLocalB && !isScalableMRSys && SysFcnArgNeeded(sysFcn, BlockIOArgDef, cTID, isRG)
        %assign arg = FcnGetArgForType("BlockIO", ...
          FcnGetModelRefBlockIOArg(), "localB", sysIdx, callSiteIdx, accessSysIdx)
        %assign args = "%<args>%<comma>%<arg>"
        %assign comma = ", "
      %endif
      %%
      %% DataGroup arguments. For model reference, we're using localGroup<Name>
      %% to hold the pointer from RTM and pass that down into subfunctions. For 
      %% access by the model reference root system, access will be through RTM.
      %foreach gIdx = ::CompiledModel.NumCoderDataGroups
        %assign argDef = FcnGetGroupArgDef(gIdx)
        %assign group = ::CompiledModel.CoderDataGroup[gIdx]
        %assign groupAccessedThroughRTM = ...
          IsModelReferenceBaseSys(System[accessSysIdx]) && ...         
          SLibAccessGroupThroughSelf(group)
        %if !(skipLocalDataGroup[gIdx]) && ...
            !isScalableMRSys && ...
            !groupAccessedThroughRTM && ...
            SysFcnArgNeeded(sysFcn, argDef, cTID, isRG) && ...
            !hasSimplifiedInterface
          %assign groupToken = "CoderDataGroup" + group.Name
          %assign varGroupIdx = FcnSysVarGroupIndex(thisSystem, groupToken, callSiteIdx)
          %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIdx]
          %assign varName = varGroup.LocalName
          %assign arg = FcnGetArgForType(groupToken, ...
            varName, varName, sysIdx, callSiteIdx, accessSysIdx)
          %assign args = "%<args>%<comma>%<arg>"
          %assign comma = ", "
        %endif 
      %endforeach
      %%
      %% Constant block IO argument
      %%
      %if !skipLocalC && SysFcnArgNeeded(sysFcn, ConstBlockIOArgDef, cTID, isRG)
        %%
        %% If a system function (e.g. "Start") calls a function of the 
        %% same system (e.g. "Enable"), it has to pass the structured arguments
        %% without adding a substructure element
        %%
        %assert !isScalableMRSys
        %if genModelRef
          %assign args = args + comma + FcnGetModelRefConstBlockIOArg()
        %elseif LibIsPassThroughSubsystemCall(sysIdx, accessSysIdx)
          %assign args = "%<args>%<comma>localC"
          %<SLibAccessArgHelper(ConstBlockIOArgDef,"",cTID)>
        %else
          %assign cross = ::CompiledModel.System[cs[0]].CrossNoArgFcnBound
          %assign varGroupIdx = ...
            FcnSysVarGroupIndex(thisSystem, "ConstBlockIO", callSiteIdx)
          %assign parentVarGroupIdx = SLibVarGroupParentIndex(varGroupIdx)
          %assign identiPath = SLibCGIRVarGroupPath(parentVarGroupIdx, ...
            accessSysIdx, cross)
          %assign indenti = SLibVarGroupName(varGroupIdx)
          %assign dataType = FcnSysVarGroupType(thisSystem,"ConstBlockIO")
          %assign cast = "(" + dataType + "*)"
          %assign args = "%<args>%<comma>%<cast>&%<identiPath>%<indenti>"
        %endif
        %assign comma = ", "
      %endif
      %%
      %% DWork IO argument
      %%
      %assign isCPPEncapMdlRef = GenerateClassInterface && IsModelReferenceBaseSys(thisSystem)    
      %if !skipLocalDW && SysFcnArgNeeded(sysFcn, DWorkArgDef, cTID, isRG) && !isScalableMRSys && !isCPPEncapMdlRef
        %assign arg = FcnGetArgForType("DWork", FcnGetModelRefDWorkArg(), ...
          "localDW", sysIdx, callSiteIdx, accessSysIdx)
        %assign args = "%<args>%<comma>%<arg>"
        %assign comma = ", "
      %endif
      %%
      %% Parameter H-Struct argument
      %%
      %assign isSysFcnArgNeeded = SysFcnArgNeeded(sysFcn, ParameterArgDef, cTID, isRG)
      %if !skipLocalP && isSysFcnArgNeeded
        %assert !isScalableMRSys
        %if !genModelRef
          %%
          %% Does a passthrough parameter structure argument exists ?
          %%
          %if InlineParameters != 0 && ParameterArgDef.PassthroughSystemIdx > -1
            %%
            %% Get the parent callsite vector (pcs)
            %%
            %assign pcs = thisSystem.CallSites[0]
            %%
            %% Mark the parents parameter structure argument as accessed
            %%
            %assign csPrmArgDef = System[pcs[0]].Interface.ParameterArgDef
            %assign prmAccessSysIdx = ParameterArgDef.PassthroughSystemIdx
            %<SLibAccessArgHelper(System[pcs[0]].Interface.ParameterArgDef,"",cTID)>
            %<SLibAccessArgHelper(System[prmAccessSysIdx].Interface.ParameterArgDef,"",cTID)>
            %%
            %if prmAccessSysIdx == NumSystems-1
              %if !GenerateClassInterface
                %assign args = "%<args>%<comma>%<LibGetParametersStruct()>"
              %else
                %if accessSysIdx == NumSystems-1
                  %assign args = "%<args>%<comma>&%<LibGetParametersStruct()>"
                %else
                  %assign args = "%<args>%<comma> %<LibGetParametersStruct()>"
                %endif
              %endif
            %elseif LibIsPassThroughSubsystemCall(sysIdx, accessSysIdx) || ...
              csPrmArgDef.PassthroughSystemIdx == prmAccessSysIdx
              %%
              %% - not called by a parent system (e.g. enable in start)
              %% - parent has the same pass through system index
              %%
              %assign args = "%<args>%<comma>localP"
              %<SLibAccessArgHelper(ParameterArgDef,"",cTID)>
            %else
              %assign cast = "(" + FcnSysVarGroupType(thisSystem,"Parameter") + " *)"
              %assign varGroupIdx = ...
                FcnSysVarGroupIndex(thisSystem, "Parameter", callSiteIdx)
              %assign parentVarGroupIdx = SLibVarGroupParentIndex(varGroupIdx)
              %assign cross = ::CompiledModel.System[cs[0]].CrossNoArgFcnBound
              %assign identiPath = SLibCGIRVarGroupPath(parentVarGroupIdx, ...
                csPrmArgDef.PassthroughSystemIdx, cross)
              %assign indenti = SLibVarGroupName(varGroupIdx)
              %assign args = "%<args>%<comma>%<cast> &%<identiPath>%<indenti>"
            %endif
          %elseif LibIsPassThroughSubsystemCall(sysIdx, accessSysIdx)
            %assign args = "%<args>%<comma>localP"
            %<SLibAccessArgHelper(ParameterArgDef,"",cTID)>
          %else %% normal parameter structure argument
            %assign cast = "(" + FcnSysVarGroupType(thisSystem,"Parameter") + " *)"
            %assign varGroupIdx = ...
              FcnSysVarGroupIndex(thisSystem, "Parameter", callSiteIdx)
            %assign parentVarGroupIdx = SLibVarGroupParentIndex(varGroupIdx)
            %assign cross = ::CompiledModel.System[cs[0]].CrossNoArgFcnBound
            %assign identiPath = SLibCGIRVarGroupPath(parentVarGroupIdx, ...
              accessSysIdx, cross)
            %assign indenti = SLibVarGroupName(varGroupIdx)
            %assign args = "%<args>%<comma>%<cast> &%<identiPath>%<indenti>"
          %endif
        %endif
        %assign comma = ", "
      %endif
      %%
      %% CState argument
      %%
      %if !skipLocalX && SysFcnArgNeeded(sysFcn, ContStatesArgDef, cTID, isRG)
        %assign arg = FcnGetArgForType("ContStates", ...
          FcnGetModelRefContStatesArg(), "localX", sysIdx, ...
          callSiteIdx, accessSysIdx)
        %assign args = "%<args>%<comma>%<arg>"
        %assign comma = ", "
      %endif
      %%
      %% CState Derivative argument
      %%
      %if !skipLocalXdot && SysFcnArgNeeded(sysFcn, ContStatesDerivativeArgDef, cTID, isRG)
        %assign arg = FcnGetArgForType("ContStatesDerivative", ...
          FcnGetModelRefDerivativesArg(), "localXdot", sysIdx, ...
          callSiteIdx, accessSysIdx)
        %assign args = "%<args>%<comma>%<arg>"
        %assign comma = ", "
      %endif
      %%
      %% CState Disabled argument
      %%
      %if !skipLocalXdis && SysFcnArgNeeded(sysFcn, ContStatesDisabledArgDef, cTID, isRG)
        %assign arg = FcnGetArgForType("ContStatesDisabled", ...
          FcnGetModelRefContStatesDisabledArg(), "localXdis", sysIdx, ...
          callSiteIdx, accessSysIdx)
        %assign args = "%<args>%<comma>%<arg>"
        %assign comma = ", "
      %endif
      %%
      %% CState Absolute Tolerance argument
      %%
      %if !skipLocalXabstol && SysFcnArgNeeded(sysFcn, ContStatesAbsoluteToleranceArgDef, cTID, isRG)
        %assign arg = FcnGetArgForType("ContStatesAbsoluteTolerance", ...
          FcnGetModelRefContStatesAbsTolArg(), "localXAbsTol", sysIdx, ...
          callSiteIdx, accessSysIdx)
        %assign args = "%<args>%<comma>%<arg>"
        %assign comma = ", "
      %endif
      %%
      %% Non Sampled Zero Crossing argument
      %%
      %if !skipLocalZCSV && SysFcnArgNeeded(sysFcn, ZCSVArgDef, cTID, isRG)
        %assign arg = FcnGetArgForType("ZCSV", FcnGetModelRefNSZCArg(), ...
          "localZCSV", sysIdx, callSiteIdx, accessSysIdx)
        %assign args = "%<args>%<comma>%<arg>"
        %assign comma = ", "
      %endif 
      %%
      %% ZCEvent argument
      %%
      %if !skipLocalZCE && SysFcnArgNeeded(sysFcn, ZCEventArgDef, cTID, isRG) && !isScalableMRSys
        %assign arg = FcnGetArgForType("ZCEvent", FcnGetModelRefZCEArg(), ...
          "localZCE", sysIdx, callSiteIdx, accessSysIdx)
        %assign args = "%<args>%<comma>%<arg>"
        %assign comma = ", "
      %endif
      %%
      %% Canonical parameters
      %%
      %foreach argIdx=NumCanonicalPrmArgDefs
        %assign argDef = CanonicalPrmArgDef[argIdx] 
        %if !skipCanParam[argIdx] && SysFcnArgNeeded(sysFcn, argDef, cTID, isRG)
          %assign prmWidth = LibGetRecordWidth(argDef)

          %if !genModelRef
            %assign childPrmIdx = ...
              ssBlk.CallSiteInfo.CanonicalPrmArg[argIdx].ChildPrmArgIdx
            %%
            %if isTestInterface
              %% Called by Test interface. Get information about parent Child Prm
              %assign prm = FunctionGetChildPrmArgFromParent(cs, childPrmIdx)
            %else
              %assign prm = SLibGetCallSitePrmArg(cs, childPrmIdx)
            %endif
            %%
          %endif
          
          %%
          %% If one or more of arguments of a function that is passed by address
          %% is a expression, than the result of this expression has to be stored
          %% in a temporrary variable. The address of the temporary variable will
          %% than be passed as the argument of the function call.
          %%
          %assign ref = ""
          %if genModelRef
            %% Generating S-Function for model-reference.
            %% Always generate parameter argument as "ParamArg_#"
            %assign expr = FcnGetModelRefParameter(thisSystem, argIdx)
          %elseif LibIsPassThroughSubsystemCall(sysIdx, accessSysIdx)
            %assign expr = LibGetRecordIdentifier(argDef)
            %<SLibAccessArgHelper(argDef,"",cTID)>
          %elseif prmWidth > 1
            %if LibBlockParameterIsExpression(prm)
              %assign ref = "&"
              %if !ISFIELD(ssBlk, "%<sysFcn>FcnCallCode")
                %addtorecord ssBlk %<sysFcn>FcnCallCode ...
                  { localPrmDecl ""; localExpr ""}
              %endif
              %assign dataType = SLibGetRecordDataTypeName(argDef, "")
              %assign  fcnCode = ssBlk.%<sysFcn>FcnCallCode
              %assign     iden = LibGetRecordIdentifier(argDef)
              %if !isTestInterface
                %% Add parameter declaration if not called by test interface
                %% The canonical parameter identifier is dangerous to reuse so massage it. See g612025.   
                %assign iden_tmp = "%<iden>"
                %assign iden_tmp[2] = "e"
                %assign iden = iden_tmp
                %assign fcnCode.localPrmDecl = fcnCode.localPrmDecl + ...
                  "%<dataType> %<iden>[%<prmWidth>];\n"
              %endif  %% ! isTestInterface
              %assign expr = "%<iden>[0]"
              %assign rolledExpr = ""
              %openfile rolledExpr
              %roll idx=[0:%<prmWidth-1>],lcv=RollThreshold,ssBlk,"Roller",""
                %<iden>[%<lcv == "" ? idx : lcv>] = ...
                  %<FcnGenParamExprWithCast("", accessSysIdx, cs[0], cs, prm, lcv, "", idx)>;
              %endroll
              
              %closefile rolledExpr
              %if !isTestInterface
                %% Add localExpr if not called by interface
                %assign fcnCode.localExpr = fcnCode.localExpr + rolledExpr
              %endif
            %elseif prm.ASTNode.IsNonTerminal == 0 && ...
              prm.ASTNode.Op == "M_CANPRM_ID"
              %assign ref = "&"
              %assign expr = FcnGenParamExprWithCast("", accessSysIdx, cs[0], cs, prm, "", "", "")
            %else
              %assign prmSize = SLibGetSizeOfValueFromParamRec(prm)
              %assign nRows   = prmSize[0]
              %if nRows == 1
                %assign expr = FcnBlockParameterAddr(prm, "", "", 0, 0, TLC_FALSE)
              %else
                %assign expr = ...
                  FcnBlockMatrixParameterAddr(prm, "", "", 0, "", "", 0, TLC_FALSE)
              %endif
            %endif
          %else
            %assign expr = FcnGenParamExprWithCast("", accessSysIdx, cs[0], cs, prm, "", "", "")
            %if argDef.DeclareAsPointer == "yes"
              %assign expr = "(%<expr>)"
              %assign ref  = "&"
            %endif
          %endif
          %assign args = "%<args>%<comma>%<ref>%<expr>"
          %assign comma = ", "
        %endif %% SysFcnArgNeeded
      %endforeach %% argIdx=NumCanonicalPrmArgDefs
      %%
      %% Canonical DWork argument
      %% 
      %assign canDWork = FcnGetCanDWorkArgs(sysFcn, sysIdx, ...
        accessSysIdx, callSiteIdx, cTID, isRG, skipCanDWork)
      %if canDWork != ""
        %assign args = "%<args>%<comma>%<canDWork>"
        %assign comma = ", "
      %endif
    %endif %% LibSystemIsReusedFcn(thisSystem)
  %endwith %% thisSystem.Interface
    
  %return args
%endfunction %% FcnGetAdditionalArgs

%% Function: LibIsPassThroughSubsystemCall =====================================
%% Abstract:
%%    The parent has the same pass through system index as the caller.
%%
%function LibIsPassThroughSubsystemCall(sysIdx, accessSysIdx)
  %return ::CompiledModel.System[sysIdx].HStructDeclSystemIdx == accessSysIdx
%endfunction

%% Function: LibGetFcnCallISR ==================================================
%% Abstract:
%%    For use by inlined S-Functions with function call outputs. Returns a
%%    function call string with a ISR (interupt service routine) compatible
%%    interface.
%%    This library function should be used to a attach the generated code
%%    of a Simulink function call subsystem to a ISR.
%%
%function LibGetFcnCallISR(ssBlock, portEl, tidVal) void
  %return SLibGetFcnEventType(ssBlock, portEl, tidVal, "ISR", "OutputUpdate")
%endfunction

%% Function: LibGetFcnCallFNI ==================================================
%% Abstract:
%%    For use by inlined S-Functions with function call outputs. Returns a
%%    function call string with a FNI (forced non-inlined) compatible
%%    interface.
%%    
%function LibGetFcnCallFNI(ssBlock, portEl, tidVal) void
  %return SLibGetFcnEventType(ssBlock, portEl, tidVal, "FNI", "OutputUpdate")
%endfunction

%% Function: LibGetFcnInitializeFNI ============================================
%% Abstract:
%%    For use by inlined S-Functions with function call outputs. Returns a
%%    function call string with a FNI (forced non-inlined) compatible
%%    interface.
%%    
%function LibGetFcnInitializeFNI(ssBlock, portEl, tidVal) void
  %return SLibGetFcnEventType(ssBlock, portEl, tidVal, "FNI", "Initialize")
%endfunction

%% Function: LibGetFcnSystemResetFNI ============================================
%% Abstract:
%%    For use by inlined S-Functions with function call outputs. Returns a
%%    function call string with a FNI (forced non-inlined) compatible
%%    interface.
%%    
%function LibGetFcnSystemResetFNI(ssBlock, portEl, tidVal) void
  %return SLibGetFcnEventType(ssBlock, portEl, tidVal, "FNI", "SystemReset")
%endfunction

%% Function: LibGetFcnEnableFNI ================================================
%% Abstract:
%%    For use by inlined S-Functions with function call outputs. Returns a
%%    function call string with a FNI (forced non-inlined) compatible
%%    interface.
%%    
%function LibGetFcnEnableFNI(ssBlock, portEl, tidVal) void
  %return SLibGetFcnEventType(ssBlock, portEl, tidVal, "FNI", "Enable")
%endfunction

%% Function: LibGetFcnDisableFNI ===============================================
%% Abstract:
%%    For use by inlined S-Functions with function call outputs. Returns a
%%    function call string with a FNI (forced non-inlined) compatible
%%    interface.
%%    
%function LibGetFcnDisableFNI(ssBlock, portEl, tidVal) void
  %return SLibGetFcnEventType(ssBlock, portEl, tidVal, "FNI", "Disable")
%endfunction

%% Function: SLibGenerateISRStubs ==============================================
%% Abstract:
%%    This function is called by SLibGetBodyOutputUpdateFcnCache in
%%    commonbodlib.tlc in order to generate the function call stubs with a
%%    ISR (interupt service routine) compatible interface.
%%
%function SLibGenerateISRStubs(fcnCallSys) void
  %assign tmpBuffer = ""
  %assign sysFcnPrototype = ""
  
  %if LibIsSystemField(fcnCallSys, "NumISROutputUpdateCallSites")
    %assign NumISRCallSites = ...
      LibGetSystemField(fcnCallSys, "NumISROutputUpdateCallSites")
    %assign     ISRCallSite = ...
      LibGetSystemField(fcnCallSys, "ISROutputUpdateCallSite")
    %openfile tmpBuffer
    %foreach idx=NumISRCallSites  
      %assign  fcnName = ISRCallSite[idx][0]
      %assign   sysIdx = ISRCallSite[idx][1]
      %assign    csIdx = ISRCallSite[idx][2]
      %assign   portEl = ISRCallSite[idx][3]
      %assign   tidVal = ISRCallSite[idx][4]
      %assign callSite = ::CompiledModel.System[sysIdx].CallSites[csIdx]
      %assign  ssBlock = ::CompiledModel.System[callSite[2]].Block[callSite[3]]
      
      /* 
       * Interrupt service routine (ISR) function call stub 
       * for '%<ssBlock.Name>' 
       */
      void %<fcnName>(void) {
        %if FcnSubsystemIsAsycnTopSS(fcnCallSys)
          %<SLibDumpOutputUpdateCodeForAsyncTid(fcnCallSys.CurrentTID)>
        %elseif LibIsSystemField(fcnCallSys,"CallerBlkIdx")
          %assign callerBlkIdx = LibGetSystemField(fcnCallSys,"CallerBlkIdx")
          %if callerBlkIdx[0] > 0
            %assign sfcnBlk = System[callerBlkIdx[0]].Block[callerBlkIdx[2]]
            %<LibBlockExecuteFcnCall(sfcnBlock, portEl)>
          %else
            %<SLibCallFCSS(sysIdx,csIdx,NumSystems-1,SLibGetSimStruct(),portEl,tidVal,0,"OutputUpdate")>
          %endif
        %else
          %<SLibCallFCSS(sysIdx,csIdx,NumSystems-1,SLibGetSimStruct(),portEl,tidVal,0,"OutputUpdate")>
        %endif
      }
      %assign sysFcnPrototype = sysFcnPrototype + ...
	"%<LibExternInFcnDecls()>void %<fcnName>(void);\n"
    %endforeach
    %closefile tmpBuffer
    %if !SLibGenNonReusableSubsysFcnAsClassMemFcn(::CompiledModel.System[sysIdx])
      %assign fileSysIdx = ::CompiledModel.System[sysIdx].FileNameOwnerIdx
      %assign fileOwner  = ::CompiledModel.System[fileSysIdx]
      %<LibAddToSystemField(fileOwner, "SystemFcnPrototype", sysFcnPrototype)>
    %else
      %% When in generating non-reusable subsystem funcitons as C++ member function mode,
      %% system function prototoype cannot be put in the file owner subsystem, as they will
      %% need to be put into root_model.h
      %<LibAddToSystemField(::CompiledModel.System[sysIdx], "EncapSystemFcnPrototype", sysFcnPrototype)>
    %endif
  %endif
  
  %return tmpBuffer
%endfunction %% SLibGenerateISRStubs

%% Function: FcnGenerateFNIStubsForFcn =========================================
%% Abstract:
%%    This function is called by SLibGetBodyOutputUpdateFcnCache in
%%    commonbodlib.tlc in order to generate the function call stubs with a
%%    FNI (forced non-inlined) compatible interface.
%%
%function FcnGenerateFNIStubsForFcn(fcnCallSys, fcnType) void
  %assign tmpBuffer = ""
  %assign sysFcnPrototype = ""
  
  %if LibIsSystemField(fcnCallSys, "NumFNI%<fcnType>CallSites")
    %assign NumFNICallSites = ...
      LibGetSystemField(fcnCallSys, "NumFNI%<fcnType>CallSites")
    %assign     FNICallSite = ...
      LibGetSystemField(fcnCallSys, "FNI%<fcnType>CallSite")
    %openfile tmpBuffer
    %foreach idx=NumFNICallSites
      %assign   fcnName = FNICallSite[idx][0]
      %assign    sysIdx = FNICallSite[idx][1]
      %assign     csIdx = FNICallSite[idx][2]
      %assign    portEl = FNICallSite[idx][3]
      %assign    tidVal = FNICallSite[idx][4]
      %assign blkSysIdx = FNICallSite[idx][5]
      %assign    blkIdx = FNICallSite[idx][6]
      %assign   emitted = FNICallSite[idx][7]
      %assign isRateGroupedSLFInAccel = Accelerator ...
        && fcnCallSys.IsRateGroupedSLFcn == TLC_TRUE && fcnType == "OutputUpdate"
      %if isRateGroupedSLFInAccel
        %% Rate grouped Simulink functions exist in the root module. So need to
        %% get the FcnInfo from root.
        %assign rateGroupedSLFSystem = System[NumSystems-1]
        %assign  fcnInfo = LibGetFcnInfo(rateGroupedSLFSystem, "Output", fcnCallSys.CurrentTID)
      %else
        %assign  fcnInfo = ...
          LibGetFcnInfo(fcnCallSys, fcnType, fcnCallSys.CurrentTID)
      %endif
      %assign cgirName = fcnInfo.CGIRName
      %assign calleeSystem = ::CompiledModel.System[sysIdx]
      %assign callSite = calleeSystem.CallSites[csIdx]
      %assign  ssBlock = ::CompiledModel.System[callSite[2]].Block[callSite[3]]
      %assign sfcnBlock = ::CompiledModel.System[blkSysIdx].Block[blkIdx]
      %assign modIdx = ::CompiledModel.RTWCGModules.NumRTWCGModules-1
      %assign fcnIdx = ::CompiledModel.RTWCGModules.TestInterfaceFcnIdx
      %assign argVec = []
      
      %if emitted == 1
        %continue
      %else
        %assign FNICallSite[idx][7] = 1
        %<LibSetSystemField(fcnCallSys, "FNI%<fcnType>CallSite", FNICallSite)>
      %endif
      
      %with sfcnBlock
        %if SLibTLCSystemFcnCallExists(fcnType, sysIdx, csIdx, modIdx, fcnIdx)
          %assign callInfo = ...
            SLibTLCSystemFcnCallInfo(fcnType, sysIdx, csIdx, modIdx, fcnIdx)
          %assign argVec = callInfo.Args
          %assign cgirName = callInfo.Name
        %endif
      %endwith
      
      %assign    locSS = RTMGetModelSS()
      %assign  argDefs = ::tSimStructType + " *const " + locSS
      %assign  rtmUnused = 1
      %assign  cpiUnused = 0
      %assign  tidUnused = 0
      %if SLibAutosarCompilerAbstractionRequired()
        %assign dataDef = SLibAutosarCompilerAbstractionForDataDecl(...
          TLC_FALSE, "int_T", TLC_FALSE, TLC_FALSE, ::tControlPortIdx, ...
          "DataAutomatic")
        %assign argDefs = argDefs + ", " + dataDef
      %else
        %assign argDefs = argDefs + ", int_T " + ::tControlPortIdx
      %endif
      %if !LibSystemFcnNeedsCPI(fcnCallSys, fcnType)
        %assign  cpiUnused = 1
      %endif

      %% If the system function doesn't have TID, then add it to the 
      %% stub since the stub has an expected interface including the TID
      %if SLibAutosarCompilerAbstractionRequired()
        %assign dataDef = SLibAutosarCompilerAbstractionForDataDecl(...
          TLC_FALSE, "int_T", TLC_FALSE, TLC_FALSE, ::tTID, "DataAutomatic")
        %assign argDefs = argDefs + ", " + dataDef
      %else
        %assign argDefs = argDefs + ", int_T " + ::tTID
      %endif
      %if !LibSystemFcnNeedsTID(fcnCallSys, fcnType)
        %assign  tidUnused = 1
      %endif
            
      %%
      %% To avoid warnings, use a different name for the
      %% rtModel in the function declaration than in the
      %% function body.
      %%
      %if GenRTModel
        %assign          rtm = " *%<locSS>"
        %assign     lowerrtm = " *rtm"
        %assign lowerArgDefs = FEVAL("strrep", argDefs, rtm, lowerrtm)
      %else
        %assign lowerArgDefs = argDefs
      %endif
      
      /* 
       * Forced non-inlined (FNI) function call stub 
       * for '%<ssBlock.Name>' 
       */
      %% Model Reference must supply boolean return argument to satisfy
      %% fcnCallSys macro
      %assign retArg = "boolean_T"
      %<SLibIfSystemVariantCondition16b(fcnCallSys)>
      %<retArg> %<fcnName>(%<argDefs>) {
	%% Make the smarts for whether or not to call the initialize
	%% function based on state reset here, so the caller (e.g. Stateflow
	%% or rt_EnableSys can be blissfully and generically unaware of it
	%% (at runtime)
       
	%assign fcnCode = ""
	%openfile fcnCode
        %assign callerSfcnBlk = ""
        %if LibIsSystemField(fcnCallSys,"CallerBlkIdx")
          %assign callerBlkIdx = LibGetSystemField(fcnCallSys,"CallerBlkIdx")
          %if callerBlkIdx[0] > 0
            %assign callerSfcnBlk = System[callerBlkIdx[0]].Block[callerBlkIdx[2]]
            %assign callerSfcnBlkEl = LibGetSystemField(fcnCallSys,"CallerBlkPortEl")
          %endif
        %endif
        
        %if  !ISEMPTY(callerSfcnBlk) && ...
          callerSfcnBlk.NumSFcnSysOutputCallDsts > 1
          %% If this callerSfcnBlk has multiple destination, checking the emptyness of 
          %% this one destination system is not sufficient. In this case, be conservative, 
          %% assume at least one destination subsystems is not empty.
          %assign systemFcnIsEmpty = TLC_FALSE
        %else
          %if fcnType == "OutputUpdate" || ...
            fcnType == "Output" || fcnType == "Update"
            %if isRateGroupedSLFInAccel
              %% Sometimes the CurrentTID for root is not set. We should
              %% set it to the passed in TID (tidVal) in order to ensure
              %% we are looking at the right Output function in root when
              %% we call LibSystemFcnIsEmptyForTID.
              %assign oldTidVal = rateGroupedSLFSystem.CurrentTID
              %assign rateGroupedSLFSystem.CurrentTID = tidVal
              %assign systemFcnIsEmpty = ...
              LibSystemFcnIsEmptyForTID(rateGroupedSLFSystem, fcnType)
              %assign rateGroupedSLFSystem.CurrentTID = oldTidVal
            %else
              %assign systemFcnIsEmpty = ...
                LibSystemFcnIsEmptyForTID(fcnCallSys, fcnType)
            %endif
          %else
            %assign systemFcnIsEmpty = ...
              LibSystemFcnIsEmpty(fcnCallSys, fcnType) 
          %endif
        %endif
	%%
        
        %if IsModelReferenceSimTarget() && (fcnType == "Enable")
          %% The Enable Function must call the Initialize function because
          %% simulation doesn't cache away the Initialize function pointer
          %if !LibSystemFcnIsEmpty(fcnCallSys, "SystemReset")
            %if !ISEMPTY(callerSfcnBlk)
              %foreach fcIdx = callerSfcnBlk.NumSFcnSysOutputCallDsts
                %assign blockToCall = ...
                  sfcnBlock.SFcnSystemOutputCall[fcIdx].BlockToCall
                %assign calledBlock = ...
                  ::CompiledModel.System[blockToCall[0]].Block[blockToCall]
                %with sfcnBlock
                  %assign initFNI = LibGetFcnSystemResetFNI(calledBlock,0,tidVal)
                %endwith
                %assign rtmUnused = 0
                %<initFNI>(%<locSS>, %<::tTID>, %<::tControlPortIdx>);
              %endforeach
            %else
              %with sfcnBlock
                %assign initFNI = LibGetFcnSystemResetFNI(ssBlock,portEl,tidVal)
              %endwith
              %assign rtmUnused = 0
              %<initFNI>(%<locSS>, %<::tTID>, %<::tControlPortIdx>);
            %endif
          %endif
        %endif
        %assign initiateFcnCall = !systemFcnIsEmpty && ...
          (fcnType != "SystemReset" || fcnCallSys.TriggerBlkReset)
        %if initiateFcnCall
          %if isRateGroupedSLFInAccel
            %assign calleeModIdx = rateGroupedSLFSystem.CGIRModuleIdx
          %else
            %assign calleeModIdx = calleeSystem.CGIRModuleIdx
          %endif
          %assign calleeModule = ...
            ::CompiledModel.RTWCGModules.RTWCGModule[calleeModIdx]
          %if ISFIELD(calleeModule, "SystemFunctions") && ...
            ISFIELD(calleeModule.SystemFunctions, cgirName)
            %assign fcnIndex  = GETFIELD(calleeModule.SystemFunctions, cgirName)
            %assign calleeFcn = calleeModule.Function[fcnIndex]
            
            %foreach argIdx=calleeFcn.NumArgs
              %if calleeFcn.ArgAccessed[argIdx]
                %assign idNum = SLibSafeIDNUM(calleeFcn.ArgSource, argIdx)
                %assign argSrc = idNum[0]
                %switch argSrc
                  %case "RTM"
                    %%if GenRTModel
                    %%assign argVec[argIdx] = "rtm"
                    %%else
                    %assign argVec[argIdx] = locSS
                    %%endif
                    %if calleeSystem.CrossNoArgFcnBound == 0
                      %assign rtmUnused = 0
                    %endif
                    %break
                  %case "CPI"
                    %assign argVec[argIdx] = ::tControlPortIdx
                    %if calleeSystem.CrossNoArgFcnBound  == 0
                      %assign cpiUnused = 0
                    %endif
                    %break
                  %case "TID"
                    %assign argVec[argIdx] = ::tTID
                    %if calleeSystem.CrossNoArgFcnBound  == 0
                      %assign tidUnused = 0
                    %endif
                    %break
                  %default
                    %break
                %endswitch
              %endif %% !calleeFcn.ArgAccessed[argIdx]
            %endforeach %%  argIdx=calleeFcn.NumArgs
          %endif %% ISFIELD(calleeModule, "SystemFunctions")
        
          %if FcnSubsystemIsAsycnTopSS(fcnCallSys) && fcnType == "OutputUpdate"
            %<SLibDumpOutputUpdateCodeForAsyncTid(fcnCallSys.CurrentTID)>
          %elseif !ISEMPTY(callerSfcnBlk)
            %<SLibBlockExecuteSysFcn(callerSfcnBlk, callerSfcnBlkEl, fcnType)>
          %else
            %assign addArgs = FcnGetAdditionalArgs(cgirName, argVec, ...
              fcnType, sysIdx, ::CompiledModel.NumSystems-1, csIdx, TLC_FALSE, TLC_FALSE)
            %if !WHITE_SPACE(fcnInfo.CommonArgs) && !WHITE_SPACE(addArgs)
              %assign addArgs = ", " + addArgs
            %endif
            %if !EXISTS(callInfo.OpeningTraceComment)
            %<fcnInfo.Name>(%<fcnInfo.CommonArgs>%<addArgs>);
            %else
              %% add traceability comment to the function call site
              %<callInfo.OpeningTraceComment>%<fcnInfo.Name>%<callInfo.ClosingTraceComment>(%<fcnInfo.CommonArgs>%<addArgs>);
            
          %endif
            
            
            
	%endif
	%endif
        
        %if 1 == rtmUnused
          %<SLibUnusedParameter(locSS)>        
        %endif
        %if 1 == cpiUnused
          %<SLibUnusedParameter(::tControlPortIdx)>
        %endif
        %if 1 == tidUnused
          %<SLibUnusedParameter(::tTID)>
        %endif
        %closefile fcnCode
        %<fcnCode>
        return (1);
      }
      %<SLibEndIfSystemVariantCondition16b(fcnCallSys)>
      %assign sysFcnPrototype = sysFcnPrototype + ...
        "%<LibExternInFcnDecls()>%<retArg> %<fcnName>(%<lowerArgDefs>);\n"
    %endforeach    
    %closefile tmpBuffer
    
    %if !SLibGenNonReusableSubsysFcnAsClassMemFcn(::CompiledModel.System[sysIdx])
      %assign fileSysIdx = ::CompiledModel.System[sysIdx].FileNameOwnerIdx
      %assign fileOwner  = ::CompiledModel.System[fileSysIdx]
      %<LibAddToSystemField(fileOwner, "SystemFcnPrototype", sysFcnPrototype)>
    %else
      %% When in generating non-reusable subsystem funcitons as C++ member function mode,
      %% system function prototoype cannot be put in the file owner subsystem, as they will
      %% need to be put into root_model.h
      %<LibAddToSystemField(::CompiledModel.System[sysIdx], "EncapSystemFcnPrototype", sysFcnPrototype)>
    %endif
  %endif
  
  %return tmpBuffer
%endfunction %% end: FcnGenerateFNIStubsForFcn

%% Function: SLibGenerateFNIStubs ==============================================
%% Abstract:
%%    This function is called by SLibGetBodyOutputUpdateFcnCache in
%%    commonbodlib.tlc in order to generate the function call stubs with a
%%    FNI (forced non-inlined) compatible interface.
%%
%function SLibGenerateFNIStubs(fcnCallSys) void
  %openfile tmpBuf
  %<FcnGenerateFNIStubsForFcn(fcnCallSys, "OutputUpdate")>\
  %<FcnGenerateFNIStubsForFcn(fcnCallSys, "SystemReset")>\    
  %<FcnGenerateFNIStubsForFcn(fcnCallSys, "Enable")>\
  %<FcnGenerateFNIStubsForFcn(fcnCallSys, "Disable")>\
  %closefile tmpBuf
  %return tmpBuf
%endfunction

%% Function: SLibGetFcnEventType ===============================================
%% Abstract:
%%      This function is called by LibGetFcnCallISR and LibGetFcnCallFNI. It
%%      attaches additional information to the system instance recode that is
%%      used to generate to generate the function call stubs.
%%
%function SLibGetFcnEventType(fcnCallDst, portEl, tidVal, fcnCallType, fcnType) void
  %if fcnCallDst.Type == "SubSystem"
    %with fcnCallDst
      %assign bType  = (Type == "SubSystem") ? "Subsystem" : ""
      %assign sysIdx = LibBlockParamSetting(bType, "SystemIdx")
    %endwith
    
    %assign        csIdx = fcnCallDst.CallSiteIdx
    %assign   fcnCallSys = ::CompiledModel.System[sysIdx]
    %if ISFIELD(fcnCallSys, "%<fcnType>Fcn")
      %assign      fcnName = fcnCallSys.%<fcnType>Fcn + fcnCallType
      %assign    fieldName = fcnCallType + fcnType + "CallSite"
      %assign numFieldName = "Num" + fcnCallType + fcnType + "CallSites"
      
      %if csIdx > 0 || portEl > 0
        %assign  fcnName = fcnName + "_%<csIdx>_%<portEl>"
      %endif
      
      %assign thisSytemIdx = BlockIdx[0]
      %assign thisBlockIdx = BlockIdx[2]
      
      %assign callSite = [%<fcnName>, %<sysIdx>, %<csIdx>, ...
        %<portEl>, %<tidVal>, %<thisSytemIdx>, %<thisBlockIdx>, 0]
      %if !LibIsSystemField(fcnCallSys, numFieldName)
        %assign callSite = Matrix (1,8) [[%<callSite>];]
        %<LibAddToSystem(fcnCallSys, numFieldName, 1)>
        %<LibAddToSystem(fcnCallSys, fieldName, callSite)>
      %else
        %assign  fcnExists = 0
        %assign  numFields = LibGetSystemField(fcnCallSys, numFieldName)
        %assign fieldValue = LibGetSystemField(fcnCallSys, fieldName)
        %foreach idx=numFields
          %if fieldValue[idx][0] == fcnName
            %assign  fcnExists = 1
            %break
          %endif
        %endforeach
        %if !fcnExists
          %<LibAddToSystemField(fcnCallSys, numFieldName, 1)>
          %<LibAddToSystemField(fcnCallSys, fieldName, callSite)>
        %endif
      %endif
      %return fcnName
    %else
      %return ""
    %endif
  %else
    %assert fcnCallDst.Type == "ModelReference"
    
    %% Check that this is being called from the right scope so we can
    %% correctly get the right fcn-call input on the Model block.
    %if !EXISTS(FcnPortIdx)
      %if fcnType == "OutputUpdate"
        %assign tlcFcnName = "LibGetFcnCall%<fcnCallType>"
      %else
        %assign tlcFcnName = "LibGetFcn%<fcnType>%<fcnCallType>"
      %endif
      %<SLibReportErrorWithIdAndArgs("RTW:tlc:SFcnSystemOutputCallOutOfScope", tlcFcnName)>
    %endif
    
    %assign fcnName = ""
    %if FcnPortIdx >= fcnCallDst.NumDataInputPorts && fcnType == "OutputUpdate" && ...
      ISFIELD(fcnCallDst.ParamSettings, "ModelEventPortNames")
      %assign eventPortIdx = FcnPortIdx - fcnCallDst.NumDataInputPorts
      %assign eventPortName = fcnCallDst.ParamSettings.ModelEventPortNames[eventPortIdx]
      %assign fcnName = "%<fcnCallDst.ParamSettings.ReferencedModelName>_%<fcnCallDst.Identifier>_%<eventPortName>_w"
      %assign TID = SLibGetFcnCallDstTID(fcnCallDst, FcnPortIdx)
      %assign isAsync = TLC_TRUE
      %assign groupIndex = -1
    %else
      %assign fcnCallInfo = SLibGetModelBlockFcnCallInputInfo(fcnCallDst, FcnPortIdx, fcnType)
      %if !ISEMPTY(fcnCallInfo)
        %assign fcnName = "%<fcnCallInfo.TaskName>_w"
        %assign TID = SLibGetFcnCallDstTID(fcnCallDst, FcnPortIdx)
        %assign isAsync = fcnCallInfo.isAsync
        %assign groupIndex = fcnCallInfo.FcnCallPortGroupIndex
      %endif
    %endif

    %if !ISEMPTY(fcnName)
      %if !ISFIELD(fcnCallDst, "WrapperFcns")
        %addtorecord fcnCallDst WrapperFcns {}
      %endif
      %addtorecord fcnCallDst.WrapperFcns %<fcnType> ...
        {FcnName fcnName; ...
         FcnPortIdx FcnPortIdx; ...
         TID TID; ...
         isAsync isAsync; ...
         FcnCallPortGroupIndex groupIndex}
    %endif
    
    %return fcnName
  %endif
%endfunction 

%function SLibGetFcnCallDstTID(dstBlock, dstPort)
  %if dstBlock.Type == "SubSystem"
    %return LibGetSubsystemBlkTIDForTask(dstBlock, TLC_TRUE)
  %else
    %assert dstBlock.Type == "ModelReference"
    %with dstBlock
      %if EXISTS("InputPortTIDs")
        %assign tid = InputPortTIDs[dstPort]
      %else
        %assign tid = TID
      %endif
    %endwith
    
    %return tid
  %endif
%endfunction

%% DocFunction{Other Useful Functions}: LibBlockExecuteFcnCall =================
%% Abstract:
%%   For use by inlined S-Functions to call fcn-call system output function. 
%%   Returns a string to either call function-call subsystem output function 
%%   with the appropriate number of arguments or the generate the subsystem output 
%%   code right there (inlined).
%%
%% Example:
%%   %foreach callIdx = NumSFcnSysOutputCallDsts
%%       %if LibIsEqual(SFcnSystemOutputCall[callIdx].BlockToCall, "unconnected")
%%          %continue
%%       %endif
%% 	 %% call the downstream system
%%       %<LibBlockExecuteFcnCall(block, callIdx)>\
%%    %endforeach
%%
%%  Consider using this function to replace LibBlockExecuteFcnCall and LibCallFCSS. 
%%  These two function are also used by inline S-Function with function call output
%%  function. However, LibExecuteFcnCall and LibCallFCSS works only if fcn-call 
%%  doesn't branch, can't handle fcn-call branches. LibBlockExecuteFcnCall works for 
%%  both cases
%% 
%function LibBlockExecuteFcnCall(sfcnBlock, callIdx) void
  %% Get the starting index of corresponding SFcnSystemOutputCall record first
  %% e.g.
  %%   'sfcnBlock' outputs 3 elements
  %%   The 1st element calls 2 function-call destinations: {'AAA', 'BBB'}
  %%   The 2nd element is unconnected: {'unconnected'}
  %%   The 3rd element calls 3 function-call destinations: {'CCC', 'DDD', 'EEE'}
  %%
  %%   Then it has a flat list of 'SFcnSystemOutputCall' records:
  %%   SFcnSystemOutputCall[0] --> 'AAA'
  %%   SFcnSystemOutputCall[1] --> 'BBB'
  %%   SFcnSystemOutputCall[2] --> 'unconnected'
  %%   SFcnSystemOutputCall[3] --> 'CCC'
  %%   SFcnSystemOutputCall[4] --> 'DDD'
  %%   SFcnSystemOutputCall[5] --> 'EEE'
  %%
  %%   The 'SFcnSystemOutputCallMappingInfo' has 3 records, each mapped to one 
  %%   output element of 'sfcnBlock':
  %%   SFcnSystemOutputCallMappingInfo[0].StartingIdx   = 0
  %%   SFcnSystemOutputCallMappingInfo[0].NumOfCalledFC = 2
  %%   SFcnSystemOutputCallMappingInfo[1].StartingIdx   = 2
  %%   SFcnSystemOutputCallMappingInfo[1].NumOfCalledFC = 1
  %%   SFcnSystemOutputCallMappingInfo[2].StartingIdx   = 3
  %%   SFcnSystemOutputCallMappingInfo[2].NumOfCalledFC = 3
  %%
  %%   When passing a 'callIdx' of 2, we should be able to get the starting
  %%   index in the list of 'SFcnSystemOutputCall' records, which is 3.
  %assign recIdx = sfcnBlock.SFcnSystemOutputCallMappingInfo[callIdx].StartingIdx

  %% Using the example shown above, given the starting index of 3, we should
  %% be able to get the first function-call destination block, which is 'CCC'.
  %assign dstSSBlk = LibGetFcnCallBlock(sfcnBlock, recIdx)
  
  %if LibIsEqual(dstSSBlk, "")
    %return "" %% Do nothing if the function-call signal is not connected
  %endif
  %with sfcnBlock
    %assign tidVal = ParamSettings.SampleTimesToSet[0][1]
    %% Get called block's function-call input port element index
    %assign fcInpPortEl = SFcnSystemOutputCall[recIdx].FcnPortElement
    %% Get number of called blocks
    %assign nCalledFC = SFcnSystemOutputCallMappingInfo[callIdx].NumOfCalledFC
    %assign dstBlkTid = SLibGetFcnCallDstTID(dstSSBlk, ...
      SFcnSystemOutputCall[recIdx].FcnPortIdx)
  %endwith
  
  %if FcnBlkIsAsyncTopSfcn(sfcnBlock)
    %assert !IsModelReferenceTarget()
    %% Output element of the S-function block
    %assign sfcnOutputEl   = sfcnBlock.SFcnSystemOutputCall[recIdx].OutputElement
    %assign tidFromSfcnBlk = FcnGetAsyncTidFromSfcnBlk(sfcnBlock, sfcnOutputEl)
          
    %assert LibAsynchronousTriggeredTID(tidFromSfcnBlk)
    %assert LibAsynchronousTriggeredTID(dstBlkTid)

    %openfile codeForAsyncTid
    %if !ISFIELD(sfcnBlock, "GenCodeForTopAsyncSS")
      %addtorecord sfcnBlock GenCodeForTopAsyncSS TLC_FALSE
    %endif
    %if sfcnBlock.GenCodeForTopAsyncSS
      %% Second time parse the async sfcn TLC file.
      %if tidFromSfcnBlk == dstBlkTid
         %% If the sfcn block is the top sfcn of the rate, the sfcn 
         %% will be reponsible to generate task entry fcn. Get the 
         %% code that is rate grouped with the async rate at root level
         %% so that code can be dumped in task entry fcn. 
         {
           %if SLibIsMappedSystemInDeploymentDiagram(sfcnBlock.BlkSysIdx)
             %assign ssIdx = sfcnBlock.BlkSysIdx
             %<SLibDumpOutputUpdateCodeForAsyncTidInSS(ssIdx, dstBlkTid)>
           %else
             %<SLibDumpOutputUpdateCodeForAsyncTid(dstBlkTid)>
           %endif
         }
      %else
        %% If the sfcn block is not the tops sfcn of the rate, 
        %% call task entry fcn for the rate. This sfcn block is 
        %% no repsonsible to generate the function body. 
        %% 
        %<RTWCGBlockExecuteAsyncEntryFcn(fcInpPortEl, dstBlkTid)>
      %endif
    %else     
      %% First time parse the async sfcn TLC file.
      %% Generate code body. The code will be rate grouped
      %% in parent system. 
      %<SLibExecuteFcnCallGeneralHelper(sfcnBlock, recIdx, nCalledFC, tidVal)>
    %endif
    %closefile codeForAsyncTid
    %return codeForAsyncTid
  %else
    %openfile retBuf
    %if !ISEQUAL(sfcnBlock.TID, dstBlkTid) && LibAsynchronousTriggeredTID(dstBlkTid)
      %% Destination block has different sample time and it is a union sample time. 
      %% Call the task entry fcn of the union sample time. 
      %%  %assert Sampletime[dstBlkTid].IsUnionTs == "yes"
      %<RTWCGBlockExecuteAsyncEntryFcn(fcInpPortEl, dstBlkTid)>
    %else
      %<SLibExecuteFcnCallGeneralHelper(sfcnBlock, recIdx, nCalledFC, tidVal)>
    %endif
    %closefile retBuf
    %return retBuf
  %endif
%endfunction %% end: LibBlockExecuteFcnCall

%% DocFunction{Other Useful Functions}: LibBlockExecuteFcnEnable =================
%% Abstract:
%%   For use by inlined S-Functions to call fcn-call system enable function. 
%%   Returns a string to either call function-call subsystem enable function 
%%   with the appropriate number of arguments or the generate the subsystem enable 
%%   code right there (inlined).
%%
%% Example:
%%   %foreach callIdx = NumSFcnSysOutputCallDsts
%%       %if LibIsEqual(SFcnSystemOutputCall[callIdx].BlockToCall, "unconnected")
%%          %continue
%%       %endif
%% 	 %% call the downstream system
%%       %<LibBlockExecuteFcnEnable(block, callIdx)>\
%%    %endforeach
%%
%%  Consider using this function to replace LibBlockExecuteFcnEnable and LibEnableFCSS. 
%%  These two function are also used by inline S-Function with function call enable
%%  function. However, LibExecuteFcnEnable and LibEnableFCSS works only if fcn-call 
%%  doesn't branch, can't handle fcn-call branches. LibBlockExecuteFcnEnable works for 
%%  both cases
%% 
%function LibBlockExecuteFcnEnable(sfcnBlock, callIdx)
  %return SLibBlockExecuteFcnEnableDisableHelper(sfcnBlock, callIdx, TLC_TRUE)
%endfunction

%% DocFunction{Other Useful Functions}: LibBlockExecuteFcnDisable =================
%% Abstract:
%%   For use by inlined S-Functions to call fcn-call system disable function. 
%%   Returns a string to either call function-call subsystem disable function 
%%   with the appropriate number of arguments or the generate the subsystem disable 
%%   code right there (inlined).
%%
%% Example:
%%   %foreach callIdx = NumSFcnSysOutputCallDsts
%%       %if LibIsEqual(SFcnSystemOutputCall[callIdx].BlockToCall, "unconnected")
%%          %continue
%%       %endif
%% 	 %% call the downstream system
%%       %<LibBlockExecuteFcnDisable(block, callIdx)>\
%%    %endforeach
%%
%%  Consider using this function to replace LibBlockExecuteFcnDisable and LibDisableFCSS. 
%%  These two function are also used by inline S-Function with function call disable
%%  function. However, LibExecuteFcnDisable and LibDisableFCSS works only if fcn-call 
%%  doesn't branch, can't handle fcn-call branches. LibBlockExecuteFcnDisable works for 
%%  both cases
%% 
%function LibBlockExecuteFcnDisable(sfcnBlock, callIdx)
  %return SLibBlockExecuteFcnEnableDisableHelper(sfcnBlock, callIdx, TLC_FALSE)
%endfunction

%% SLibBlockExecuteFcnEnableDisableHelper ======================================
%% Abstract: 
%%     Helper function for LibBlockExecuteFcnEnable & LibBlockExecuteFcnDisable
%%     When enableFcn == TLC_TRUE, generate enable function; otherwise, generate
%%     disable function.
%function SLibBlockExecuteFcnEnableDisableHelper(sfcnBlock, callIdx, enableFcn)
  %openfile retBuf
  %assign recIdx    = sfcnBlock.SFcnSystemOutputCallMappingInfo[callIdx].StartingIdx
  %assign nCalledFC = sfcnBlock.SFcnSystemOutputCallMappingInfo[callIdx].NumOfCalledFC
  
  %foreach fcIdx = nCalledFC
    %assign dstSSBlk = LibGetFcnCallBlock(sfcnBlock, recIdx)
    
    %if !LibIsEqual(dstSSBlk, "") %% Ignore unconnected function-call signal
      %with sfcnBlock
        %assign tidVal = ParamSettings.SampleTimesToSet[0][1]
        %assign fcInpPortEl  = SFcnSystemOutputCall[recIdx].FcnPortElement
        %assign fcInpPortIdx = SFcnSystemOutputCall[recIdx].FcnPortIdx
      %endwith
      
      %if enableFcn == TLC_TRUE %% Generate enable function
        %<SLibExecuteFcnEnableHelper(dstSSBlk, fcInpPortEl, fcInpPortIdx, tidVal,TLC_FALSE)>
      %else %% Generate disable function
        %<SLibExecuteFcnDisableHelper(dstSSBlk, fcInpPortEl, fcInpPortIdx, tidVal,TLC_FALSE)>
      %endif
    %endif
    
    %assign recIdx = recIdx + 1 %% Update the record index
  %endforeach
  %closefile retBuf
  
  %return retBuf
%endfunction

%function SLibBlockExecuteFcnInit(sfcnBlock, callIdx)
  %with sfcnBlock
    %assign recIdx    = SFcnSystemOutputCallMappingInfo[callIdx].StartingIdx
    %assign nCalledFC = SFcnSystemOutputCallMappingInfo[callIdx].NumOfCalledFC
    %assign tidVal = ParamSettings.SampleTimesToSet[0][1]
    %assign portEl = SFcnSystemOutputCall[recIdx].FcnPortElement
  %endwith
  
  %openfile retBuf
  %foreach fcIdx = nCalledFC
    %assign dstSSBlk = LibGetFcnCallBlock(sfcnBlock, recIdx)
    
    %if !LibIsEqual(dstSSBlk, "") %% Ignore unconnected function-call signal
      %<SLibExecuteFcnInitHelper(dstSSBlk, portEl, tidVal,TLC_FALSE)>
    %endif
    
    %assign recIdx = recIdx + 1 %% Update the record index
  %endforeach
  %closefile retBuf
  
  %return retBuf
%endfunction

%function SLibBlockExecuteSysFcn(sfcnBloc, callIdx, fcnType)
  %openfile retBuf
  %switch(fcnType)
    %case "OutputUpdate"
      %<LibBlockExecuteFcnCall(sfcnBloc, callIdx)>
      %break
    %case "Initialize"
      %<SLibBlockExecuteFcnInit(sfcnBloc, callIdx)>
      %break
    %case "Enable"
      %<LibBlockExecuteFcnEnable(sfcnBloc, callIdx)>
      %break
    %case "Disable"
      %<LibBlockExecuteFcnDisable(sfcnBloc, callIdx)>
      %break
    %default
      %<SLibReportErrorWithIdAndArgs("RTW:tlc:InvalidFcnType", fcnType)>
      %break
  %endswitch
  %closefile retBuf
  
  %return retBuf
%endfunction


%function SLibReportObsoleteFcnCallAPI(OldFcnName, NewFcnName, system)
  %<SLibReportErrorWithIdAndArgs("RTW:tlc:ObsoleteFcnCall", ...
    ["%<OldFcnName>", "%<system.Name>", "%<NewFcnName>"])>
%endfunction

%function SLibExecuteFcnCallGeneralHelper(sFcnBlock, recStartingIdx, nCalledFC, tidVal) void
  %assign recIdx = recStartingIdx
  %openfile buffer
  %foreach fcIdx = nCalledFC
    %assign blockToCall   = sFcnBlock.SFcnSystemOutputCall[recIdx].BlockToCall
    %assign sysIdx        = blockToCall[0]
    %assign blkIdx        = blockToCall[1]
    %assign calledBlock   = ::CompiledModel.System[sysIdx].Block[blkIdx]
    %with sFcnBlock
      %% Get called block's function-call input port element index
      %assign fcInpPortEl = SFcnSystemOutputCall[recIdx].FcnPortElement
      %assign fcPortIdx   = SFcnSystemOutputCall[recIdx].FcnPortIdx
      %assign subsysFcnCall = SLibExecuteFcnCallHelper(calledBlock, fcInpPortEl, ...
        fcPortIdx, tidVal, TLC_FALSE)
    %endwith
    %<SLibWrapSystemVariantCondition(calledBlock, subsysFcnCall)>
    
    %assign recIdx = recIdx + 1 %% Update the record index
  %endforeach
  %closefile buffer
  %return buffer
%endfunction

%function SLibExecuteFcnCallHelper(fcnCallDstBlock, portEl, portIdx, tidVal,checkUsage) void
  %assign isSubsystem = (fcnCallDstBlock.Type == "SubSystem")

  %if isSubsystem
    %with fcnCallDstBlock
      %assign bType  = (Type == "SubSystem") ? "Subsystem" : ""
      %assign sysIdx = LibBlockParamSetting(bType, "SystemIdx")
    %endwith

    %if checkUsage && ISFIELD(System[sysIdx],"IsBranchedSys")
      %<SLibReportObsoleteFcnCallAPI("LibExecuteFcnCall","LibBlockExecuteFcnCall",System[sysIdx])>
    %endif
    
    %if checkUsage && FcnSubsystemIsAsycnTopSS(System[sysIdx])
      %assign ssBlkTid = LibGetSubsystemBlkTIDForTask(fcnCallDstBlock, TLC_TRUE)
      %assert LibAsynchronousTriggeredTID(ssBlkTid)
      %assign topAsyncSfcn =  FcnGetTaskTopSfcnBlock(ssBlkTid)
      %if ISEMPTY(topAsyncSfcn)
        %% If the sfcn block is not the tops sfcn of the rate, 
        %% call task entry fcn for the rate. This sfcn block is 
        %% no repsonsible to generate the function body. 
        %% 
        %<RTWCGBlockExecuteAsyncEntryFcn(portEl,ssBlkTid)>
      %else
        %assign el = SampleTime[ssBlkTid].AsyncSfcnBlkElm 
        %return LibBlockExecuteFcnCall(topAsyncSfcn,el)
      %endif
    %else
      %assign        csIdx = fcnCallDstBlock.CallSiteIdx
      %assign           cs = System[sysIdx].CallSites[csIdx]
      %assign accessSysIdx = System[cs[0]].HStructDeclSystemIdx
      %assign      fciCont = SLibIsFcnCallerContinuous(tidVal)
      %return SLibCallFCSS(sysIdx, csIdx, accessSysIdx, ...
        SLibGetSimStruct(), portEl, tidVal, fciCont, "OutputUpdate")
    %endif
  %else
    %assert (fcnCallDstBlock.Type == "ModelReference")
    %if checkUsage && (portIdx == -1)
      %<SLibReportObsoleteFcnCallAPI("LibExecuteFcnCall", ...
        "LibBlockExecuteFcnCall", fcnCallDstBlock)>
    %endif

    %with System[fcnCallDstBlock.BlockIdx[0]]
      %with fcnCallDstBlock
        %return CallModelBlockAsyncFcnCallInput(fcnCallDstBlock, portIdx, tidVal, ...
          "OutputUpdate")
      %endwith
    %endwith
  %endif
%endfunction

%% DocFunction{Other Useful Functions}: LibExecuteFcnCall ======================
%% Abstract:
%%   For use by inlined S-Functions with function call outputs. Returns a
%%   string to either call function-call subsystem with the appropriate number
%%   of arguments or the generate the subsystem's code right there (inlined).
%%
%% Example:
%%   %foreach fcnCallIdx = NumSFcnSysOutputCallDsts
%% 	 %% call the downstream system
%% 	 %with SFcnSystemOutputCall[fcnCallIdx]
%% 	   %% skip unconnected function call outputs
%% 	   %if ISEQUAL(BlockToCall, "unconnected")
%% 	     %continue
%% 	   %endif
%% 	   %assign sysIdx = BlockToCall[0]
%% 	   %assign blkIdx = BlockToCall[1]
%% 	   %assign ssBlock = System[sysIdx].Block[blkIdx]
%% 	   %<LibExecuteFcnCall(ssBlock, FcnPortElement, ...
%%                             ParamSettings.SampleTimesToSet[0][1])>\
%% 	 %endwith
%%     %endforeach
%%
%%     BlockToCall and FcnPortElement are elements of the SFcnSystemOutputCall
%%     record.
%%
%function LibExecuteFcnCall(ssBlock, portEl, tidVal) void
  %return SLibExecuteFcnCallHelper(ssBlock, portEl, -1, tidVal,TLC_TRUE)
%endfunction


%function  SLibExecuteFcnEnableHelper(fcnCallBlock, portEl, fcnPort, tidVal,checkUsage)
  %assign isSubsystem = (fcnCallBlock.Type == "SubSystem")
  
  %if isSubsystem
    %with fcnCallBlock
      %assign bType  = (Type == "SubSystem") ? "Subsystem" : ""
      %assign sysIdx = LibBlockParamSetting(bType, "SystemIdx")
    %endwith
    
    %if checkUsage && ISFIELD(System[sysIdx],"IsBranchedSys")
      %<SLibReportObsoleteFcnCallAPI("LibExecuteFcnEnable","LibBlockExecuteFcnEnable",System[sysIdx])>
    %endif
    
    %assign        csIdx = fcnCallBlock.CallSiteIdx
    %assign           cs = System[sysIdx].CallSites[csIdx]
    %assign accessSysIdx = System[cs[0]].HStructDeclSystemIdx
    %assign      fciCont = SLibIsFcnCallerContinuous(tidVal)
    %openfile tmpBuf
    %with fcnCallBlock
      %assign bType = (Type == "SubSystem") ? "Subsystem" : ""
      %assign swe   = LibBlockParamSetting(bType, "StatesWhenEnabling")
    %endwith  
    
    %if swe == "reset"
      %openfile initBuffer
      %<SLibCallFCSS(sysIdx, csIdx, accessSysIdx, ...
        SLibGetSimStruct(), portEl, tidVal, fciCont, "SystemReset")>
      %closefile initBuffer
      %if !WHITE_SPACE(initBuffer)
        %if ProtectCallInitFcnTwice
          /* protect against calling initialize function twice at startup */
          if (!(%<LibIsFirstInitCond()>)) {
            %<initBuffer>\
          }
        %else  
          %<initBuffer>\
        %endif
      %endif
    %endif
    %<SLibCallFCSS(sysIdx, csIdx, accessSysIdx, ...
      SLibGetSimStruct(), portEl, tidVal, fciCont, "Enable")>
    %closefile tmpBuf
    %return tmpBuf
  %else
    %if checkUsage && (fcnPort == -1)
      %<SLibReportObsoleteFcnCallAPI("LibExecuteFcnEnable","LibBlockExecuteFcnEnable", fcnCallBlock)>
    %endif
    %with System[fcnCallBlock.BlockIdx[0]]
      %with fcnCallBlock
        %assign retBuf = CallModelBlockAsyncFcnCallInput(fcnCallBlock, fcnPort, tidVal, "Enable")
      %endwith
    %endwith
  %endif
  %return retBuf
%endfunction


%% DocFunction{Other Useful Functions}: LibExecuteFcnEnable ===================
%% Abstract:
%%   For use by inlined S-Functions with function call outputs. Returns a
%%   string to either call function-call subsystem with the appropriate number
%%   of arguments or the generate the subsystem's code right there (inlined).
%%
%% Example:
%%   %foreach fcnCallIdx = NumSFcnSysOutputCallDsts
%% 	 %% call the downstream system
%% 	 %with SFcnSystemOutputCall[fcnCallIdx]
%% 	   %% skip unconnected function call outputs
%% 	   %if ISEQUAL(BlockToCall, "unconnected")
%% 	     %continue
%% 	   %endif
%% 	   %assign sysIdx = BlockToCall[0]
%% 	   %assign blkIdx = BlockToCall[1]
%% 	   %assign ssBlock = System[sysIdx].Block[blkIdx]
%% 	   %<LibExecuteFcnCall(ssBlock, FcnPortElement, ...
%%                             ParamSettings.SampleTimesToSet[0][1])>\
%% 	 %endwith
%%     %endforeach
%%
%%     BlockToCall and FcnPortElement are elements of the SFcnSystemOutputCall
%%     record.
%%
%function LibExecuteFcnEnable(ssBlock, portEl, tidVal) void
  %return  SLibExecuteFcnEnableHelper(ssBlock, portEl, -1, tidVal,TLC_TRUE)
%endfunction

%function SLibExecuteFcnDisableHelper(fcnCallBlock, portEl, fcnPort, tidVal,checkUsage)
  %assign isSubsystem = (fcnCallBlock.Type == "SubSystem")
  
  %if isSubsystem
    %with fcnCallBlock
      %assign bType  = (Type == "SubSystem") ? "Subsystem" : ""
      %assign sysIdx = LibBlockParamSetting(bType, "SystemIdx")
    %endwith
    
    %if checkUsage && ISFIELD(System[sysIdx],"IsBranchedSys")
      %<SLibReportObsoleteFcnCallAPI("LibExecuteFcnDisable","LibBlockExecuteFcnDisable",System[sysIdx])>
    %endif
    
    %assign        csIdx = fcnCallBlock.CallSiteIdx
    %assign           cs = System[sysIdx].CallSites[csIdx]
    %assign accessSysIdx = System[cs[0]].HStructDeclSystemIdx
    %assign      fciCont = SLibIsFcnCallerContinuous(tidVal)
    %openfile tmpBuf
    %<SLibCallFCSS(sysIdx, csIdx, accessSysIdx, ...
      SLibGetSimStruct(), portEl, tidVal, fciCont, "Disable")>
    %closefile tmpBuf
    %return tmpBuf
  %else
    %if checkUsage && (fcnPort == -1)
      %<SLibReportObsoleteFcnCallAPI("LibExecuteFcnDisable","LibBlockExecuteFcnDisable",fcnCallBlock)>
    %endif
    %with System[fcnCallBlock.BlockIdx[0]]
      %with fcnCallBlock
        %assign retBuf = CallModelBlockAsyncFcnCallInput(fcnCallBlock, fcnPort, tidVal, "Disable")
      %endwith
    %endwith
  %endif  
  %return retBuf
%endfunction

%% DocFunction{Other Useful Functions}: LibExecuteFcnDisable ===================
%% Abstract:
%%   For use by inlined S-Functions with function call outputs. Returns a
%%   string to either call function-call subsystem with the appropriate number
%%   of arguments or the generate the subsystem's code right there (inlined).
%%
%% Example:
%%   %foreach fcnCallIdx = NumSFcnSysOutputCallDsts
%% 	 %% call the downstream system
%% 	 %with SFcnSystemOutputCall[fcnCallIdx]
%% 	   %% skip unconnected function call outputs
%% 	   %if ISEQUAL(BlockToCall, "unconnected")
%% 	     %continue
%% 	   %endif
%% 	   %assign sysIdx = BlockToCall[0]
%% 	   %assign blkIdx = BlockToCall[1]
%% 	   %assign ssBlock = System[sysIdx].Block[blkIdx]
%% 	   %<LibExecuteFcnCall(ssBlock, FcnPortElement, ...
%%                             ParamSettings.SampleTimesToSet[0][1])>\
%% 	 %endwith
%%     %endforeach
%%
%%     BlockToCall and FcnPortElement are elements of the SFcnSystemOutputCall
%%     record.
%%
%function LibExecuteFcnDisable(ssBlock, portEl, tidVal) void
  %return SLibExecuteFcnDisableHelper(ssBlock, portEl, -1, tidVal,TLC_TRUE)
%endfunction


%function SLibExecuteFcnInitHelper(ssBlock, portEl, tidVal,checkUsage)
  %with ssBlock
    %assign bType  = (Type == "SubSystem") ? "Subsystem" : ""
    %assign sysIdx = LibBlockParamSetting(bType, "SystemIdx")
  %endwith
  
  %assert !(checkUsage && ISFIELD(System[sysIdx],"IsBranchedSys"))
  
  %assign        csIdx = ssBlock.CallSiteIdx
  %assign           cs = System[sysIdx].CallSites[csIdx]
  %assign accessSysIdx = System[cs[0]].HStructDeclSystemIdx
  %assign      fciCont = SLibIsFcnCallerContinuous(tidVal)
  %openfile tmpBuf
  %<SLibCallFCSS(sysIdx, csIdx, accessSysIdx, ...
    SLibGetSimStruct(), portEl, tidVal, fciCont, "Initialize")>
  %closefile tmpBuf
  %return tmpBuf
%endfunction

%% DocFunction{Other Useful Functions}: LibCallFCSS ============================
%% Abstract:
%%   For use by inlined S-Functions with function call outputs. Returns a
%%   string to either call function-call subsystem with the appropriate number
%%   of arguments or the generate the subsystem's code right there (inlined).
%%
%%   Note:
%%     Used by inlined S-functions to make a function-call, LibCallFCSS
%%     returns the call to the function-call subsystem with the appropriate
%%     number of arguments or the inlined code.  An S-function can execute
%%     a function-call subsystem only via its first output port.
%%  
%%     See the SFcnSystemOutputCall record in the model.rtw file.
%%  
%%     The return string is determined by the current code format.
%%  
%%   Example:
%%     %foreach fcnCallIdx = NumSFcnSysOutputCallDsts
%% 	 %% call the downstream system
%% 	 %with SFcnSystemOutputCall[fcnCallIdx]
%% 	   %% skip unconnected function call outputs
%% 	   %if ISEQUAL(BlockToCall, "unconnected")
%% 	     %continue
%% 	   %endif
%% 	   %assign sysIdx = BlockToCall[0]
%% 	   %assign blkIdx = BlockToCall[1]
%% 	   %assign ssBlock = System[sysIdx].Block[blkIdx]
%% 	   %assign sysToCall = System[ssBlock.ParamSettings.SystemIdx]
%% 	   %<LibCallFCSS(sysToCall, SLibGetSimStruct(), FcnPortElement, ...
%% 	     ParamSettings.SampleTimesToSet[0][1])>\
%% 	 %endwith
%%     %endforeach
%%  
%%     BlockToCall and FcnPortElement are elements of the SFcnSystemOutputCall
%%     record.
%%  
%%     System is a record within the global ::CompiledModel record.
%%  
%function LibCallFCSS(system, simObject, portEl, tidVal) void
  %assign       sysIdx = system.SystemIdx
  %if !EXISTS("BlockToCall")
    %if EXISTS("SFcnSystemOutputCall")
      %assign BlockToCall = SFcnSystemOutputCall[0].BlockToCall
    %else
      %<SLibReportErrorWithIdAndArgs("RTW:tlc:IncorrectLibFcnCall", "LibCallFCSS")>
    %endif
  %endif
  %if ISFIELD(System[sysIdx],"IsBranchedSys")
    %<SLibReportObsoleteFcnCallAPI("LibCallFCSS","LibBlockExecuteFcnCall",system)>
  %endif
  
  %if FcnSubsystemIsAsycnTopSS(system)
    %assign sysTid = LibGetSubsystemTID(system, TLC_TRUE)
    %assert LibAsynchronousTriggeredTID(sysTid)
    %assign topAsyncSfcn =  FcnGetTaskTopSfcnBlock(sysTid)
    %if ISEMPTY(topAsyncSfcn)
      %% If the sfcn block is not the tops sfcn of the rate, 
      %% call task entry fcn for the rate. This sfcn block is 
      %% no repsonsible to generate the function body. 
      %% 
      %return RTWCGBlockExecuteAsyncEntryFcn(portEl,sysTid)
    %else
      %assign el = SampleTime[sysTid].AsyncSfcnBlkElm 
      %return LibBlockExecuteFcnCall(topAsyncSfcn,el)
    %endif
  %else
    %assign      ssBlock = System[BlockToCall[0]].Block[BlockToCall[1]]
    %assign        csIdx = ssBlock.CallSiteIdx
    %assign           cs = system.CallSites[csIdx]
    %assign accessSysIdx = System[cs[0]].HStructDeclSystemIdx
    %assign      fciCont = SLibIsFcnCallerContinuous(tidVal)
    %return SLibCallFCSS(sysIdx, csIdx, accessSysIdx, ...
      simObject, portEl, tidVal, fciCont, "OutputUpdate")
  %endif
%endfunction %% LibCallFCSS

%% Function: FcnGenerateOpenFCSSInitialize =====================================
%% Abstract: 
%%     This function generates the opening guard around calling the enable
%%     function for a function-call subsystem.  If setMode is true, we set the
%%     specfied mode to enabled, otherwise we do not set the mode vector.
%%     Currently, since Initialize is called before Enable, Initialize does not
%%     set the mode, but Enable does set the mode.
%%
%function FcnGenerateOpenFCSSInitialize(ssBlock) void
  %with ssBlock
  %assign numModes = ModeVector[0]
  %assign tmpBuffer = ""
  %if numModes > 1
    %openfile tmpBuffer
    CondStates enableState = SUBSYS_DISABLED;
    %foreach mIdx = numModes
      %assign blockMode = LibBlockMode("", "", mIdx)
      if (((CondStates) %<blockMode>) != SUBSYS_DISABLED) {
        enableState = (CondStates) %<blockMode>;
      }
    %endforeach
    if (enableState == SUBSYS_DISABLED) {
    %closefile tmpBuffer
  %endif
  %endwith
  %return tmpBuffer
%endfunction

%% Function: FcnGenerateCloseFCSSInitialize ====================================
%% Abstract: 
%%    This function generates the closing guard around calling the enable
%%    function for a function-call subsystem.
%%
%function FcnGenerateCloseFCSSInitialize(ssBlock) void
  %with ssBlock
  %assign numModes = ModeVector[0]
  %assign tmpBuffer = ""
  %if numModes > 1
    %openfile tmpBuffer
    }
    %closefile tmpBuffer
  %endif
  %endwith
  %return tmpBuffer
%endfunction

%% Function: FcnGenerateOpenFCSSEnable =========================================
%% Abstract: 
%%    This function generates the opening guard around calling the enable
%%    function for a function-call subsystem.  If setMode is true, we set the
%%    specfied mode to enabled, otherwise we do not set the mode vector.
%%    Currently, since Initialize is called before Enable, Initialize does not
%%    set the mode, but Enable does set the mode.
%%
%function FcnGenerateOpenFCSSEnable(ssBlock, portEl) void
  %with ssBlock
  %assign numModes = ModeVector[0]
  %assign tmpBuffer = ""
  %if numModes > 1
    %openfile tmpBuffer
    {
      CondStates enableState = SUBSYS_DISABLED;
      %foreach mIdx = numModes
        %assign blockMode = LibBlockMode("", "", mIdx)
        if (((CondStates) %<blockMode>) != SUBSYS_DISABLED) {
          enableState = (CondStates) %<blockMode>;
        }
      %endforeach
      %<LibBlockMode(portEl, "", "")> = SUBSYS_ENABLED;
      if (enableState == SUBSYS_DISABLED) {
    %closefile tmpBuffer
  %elseif numModes == 1
    %openfile tmpBuffer
    %<LibBlockMode(portEl, "", "")> = SUBSYS_ENABLED;
    %closefile tmpBuffer
  %endif
  %endwith
  %return tmpBuffer
%endfunction

%% Function: FcnGenerateCloseFCSSEnable ========================================
%% Abstract: 
%%    This function generates the closing guard around calling the enable
%%    function for a function-call subsystem.
%%
%function FcnGenerateCloseFCSSEnable(ssBlock) void
  %with ssBlock
  %assign numModes = ModeVector[0]
  %assign tmpBuffer = ""
  %if numModes > 1
    %openfile tmpBuffer
      }
    }
    %closefile tmpBuffer
  %endif
  %endwith
  %return tmpBuffer
%endfunction

%% DocFunction{Other Useful Functions}: LibEnableFCSS =========================
%% Abstract:
%%   For use by inlined S-Functions with function call outputs. Returns a
%%   string to either call the enable method for a function-call subsystem 
%%   or generate the subsystem's enable code inline (as well as initialize 
%%   code if the subsystem resets states on reset).
%%
%%   Note:
%%     An S-function can execute a function-call subsystem only via its 
%%     first output port.
%%  
%%     See the SFcnSystemOutputCall record in the model.rtw file.
%%  
%%     The return string is determined by the current code format.
%%  
%%   Example:
%%     %foreach fcnCallIdx = NumSFcnSysOutputCallDsts
%% 	 %% call the downstream system
%% 	 %with SFcnSystemOutputCall[fcnCallIdx]
%% 	   %% skip unconnected function call outputs
%% 	   %if ISEQUAL(BlockToCall, "unconnected")
%% 	     %continue
%% 	   %endif
%% 	   %assign sysIdx = BlockToCall[0]
%% 	   %assign blkIdx = BlockToCall[1]
%% 	   %assign ssBlock = System[sysIdx].Block[blkIdx]
%% 	   %assign sysToCall = System[ssBlock.ParamSettings.SystemIdx]
%% 	   %<LibEnableFCSS(sysToCall, SLibGetSimStruct(), FcnPortElement, ...
%% 	     ParamSettings.SampleTimesToSet[0][1])>\
%% 	 %endwith
%%     %endforeach
%%  
%%     BlockToCall and FcnPortElement are elements of the SFcnSystemOutputCall
%%     record.
%%  
%%     System is a record within the global ::CompiledModel record.
%%  
%function LibEnableFCSS(system, simObject, portEl, tidVal) void
  %assign sysIdx = system.SystemIdx
  %if !EXISTS("BlockToCall")
    %if EXISTS("SFcnSystemOutputCall")
      %assign BlockToCall = SFcnSystemOutputCall[0].BlockToCall
    %else
      %<SLibReportErrorWithIdAndArgs("RTW:tlc:IncorrectLibFcnCall", "LibEnableFCSS")>
    %endif
  %endif
  %if ISFIELD(System[sysIdx],"IsBranchedSys")
    %<SLibReportObsoleteFcnCallAPI("LibEnableFCSS","LibBlockExecuteFcnEnable",system)>
  %endif
  %assign      ssBlock = System[BlockToCall[0]].Block[BlockToCall[1]]
  %assign        csIdx = ssBlock.CallSiteIdx
  %assign           cs = system.CallSites[csIdx]
  %assign accessSysIdx = System[cs[0]].HStructDeclSystemIdx
  %assign      fciCont = SLibIsFcnCallerContinuous(tidVal)
  %openfile tmpBuf
  %if ssBlock.ParamSettings.StatesWhenEnabling == "reset"
    %openfile initBuffer
    %<SLibCallFCSS(sysIdx, csIdx, accessSysIdx, ...
      simObject, portEl, tidVal, fciCont, "SystemReset")>
    %closefile initBuffer
    %if !WHITE_SPACE(initBuffer)
      %if ProtectCallInitFcnTwice
	/* protect against calling initialize function twice at startup */
	if (!(%<LibIsFirstInitCond()>)) {
	  %<initBuffer>\
	}
      %else
	%<initBuffer>\
      %endif
    %endif
  %endif
  {
    %<SLibCallFCSS(sysIdx, csIdx, accessSysIdx, ...
      simObject, portEl, tidVal, fciCont, "Enable")>
  }
  %closefile tmpBuf
  %return tmpBuf
%endfunction %% LibEnableFCSS


%% Function: FcnGenerateOpenFCSSDisable ========================================
%% Abstract: 
%%    This function generates the opening guard around calling the disable
%%    function for a function-call subsystem.
%%
%function FcnGenerateOpenFCSSDisable(ssBlock, portEl) void
  %with ssBlock
  %assign numModes = ModeVector[0]
  %assign tmpBuffer = ""
  %if numModes > 1
    %openfile tmpBuffer
    {
      CondStates enableState = SUBSYS_DISABLED;
      %<LibBlockMode(portEl, "", "")> = SUBSYS_DISABLED;
      %foreach mIdx = numModes
        %assign blockMode = LibBlockMode("", "", mIdx)
        if (((CondStates) %<blockMode>) != SUBSYS_DISABLED) {
          enableState = (CondStates) %<blockMode>;
        }
      %endforeach
      if (enableState == SUBSYS_DISABLED) {
    %closefile tmpBuffer
  %elseif numModes == 1
    %openfile tmpBuffer
    %<LibBlockMode(portEl, "", "")> = SUBSYS_DISABLED;
    %closefile tmpBuffer
  %endif
  %endwith
  %return tmpBuffer
%endfunction

%% Function: FcnGenerateCloseFCSSDisable =======================================
%% Abstract: 
%%    This function generates the closing guard around calling the disable
%%    function for a function-call subsystem.
%%
%function FcnGenerateCloseFCSSDisable(ssBlock) void
  %with ssBlock
  %assign numModes = ModeVector[0]
  %assign tmpBuffer = ""
  %if numModes > 1
    %openfile tmpBuffer
      }
    }
    %closefile tmpBuffer
  %endif
  %endwith
  %return tmpBuffer
%endfunction

%% DocFunction{Other Useful Functions}: LibDisableFCSS =========================
%% Abstract:
%%   For use by inlined S-Functions with function call outputs. Returns a
%%   string to either call the disable method for a function-call subsystem 
%%   or generate the subsystem's disable code inline.
%%
%%   Note:
%%     An S-function can execute a function-call subsystem only via its 
%%     first output port.
%%  
%%     See the SFcnSystemOutputCall record in the model.rtw file.
%%  
%%     The return string is determined by the current code format.
%%  
%%   Example:
%%     %foreach fcnCallIdx = NumSFcnSysOutputCallDsts
%% 	 %% call the downstream system
%% 	 %with SFcnSystemOutputCall[fcnCallIdx]
%% 	   %% skip unconnected function call outputs
%% 	   %if ISEQUAL(BlockToCall, "unconnected")
%% 	     %continue
%% 	   %endif
%% 	   %assign sysIdx = BlockToCall[0]
%% 	   %assign blkIdx = BlockToCall[1]
%% 	   %assign ssBlock = System[sysIdx].Block[blkIdx]
%% 	   %assign sysToCall = System[ssBlock.ParamSettings.SystemIdx]
%% 	   %<LibDisableFCSS(sysToCall, SLibGetSimStruct(), FcnPortElement, ...
%% 	     ParamSettings.SampleTimesToSet[0][1])>\
%% 	 %endwith
%%     %endforeach
%%  
%%     BlockToCall and FcnPortElement are elements of the SFcnSystemOutputCall
%%     record.
%%  
%%     System is a record within the global ::CompiledModel record.
%%  
%function LibDisableFCSS(system, simObject, portEl, tidVal) void
  %assign       sysIdx = system.SystemIdx
  %if !EXISTS("BlockToCall")
    %if EXISTS("SFcnSystemOutputCall")
      %assign BlockToCall = SFcnSystemOutputCall[0].BlockToCall
    %else
      %<SLibReportErrorWithIdAndArgs("RTW:tlc:IncorrectLibFcnCall", "LibDisableFCSS")>
    %endif
  %endif
   %if ISFIELD(System[sysIdx],"IsBranchedSys")
     %<SLibReportObsoleteFcnCallAPI("LibDisableFCSS","LibBlockExecuteFcnDisable",system)>
  %endif
  %assign      ssBlock = System[BlockToCall[0]].Block[BlockToCall[1]]
  %assign        csIdx = ssBlock.CallSiteIdx
  %assign           cs = system.CallSites[csIdx]
  %assign accessSysIdx = System[cs[0]].HStructDeclSystemIdx
  %assign      fciCont = SLibIsFcnCallerContinuous(tidVal)
  %openfile tmpBuf 
  %<SLibCallFCSS(sysIdx, csIdx, accessSysIdx, ...
    simObject, portEl, tidVal, fciCont, "Disable")>
  %closefile tmpBuf
  %return tmpBuf
%endfunction %% LibDisableFCSS

%% Function: SLibIsFcnCallerContinuous =========================================
%% Abstract:
%%    This function determines if calling s-function block has a continous
%%    sample time.
%%
%function SLibIsFcnCallerContinuous (tid)
  %% 
  %assign tidVal = %<tid>
  %if TYPE(tidVal) == "Number" && tidVal >= 0
    %assign fciST = ::CompiledModel.SampleTime[tidVal].PeriodAndOffset[0]
    %assign fciOF = ::CompiledModel.SampleTime[tidVal].PeriodAndOffset[1]
    %return (fciST == 0.0 && fciOF == 0.0)
  %else
    %return TLC_FALSE
  %endif
%endfunction

%% Function: SLibCallFCSS ======================================================
%% Abstract:
%%     This function is called by LibCallFCSS and LibExecuteFcnCall
%%     and friends
%%     It either returns the generated code for inlined 
%%     or a function call to a non-inlined fuction call subsystem.
%%    
%%     See LibCallFCSS and LibExecuteFcnCall for further documentation.
%%
%function SLibCallFCSS(sysIdx, csIdx, accessSysIdx, ...
                       simObject, portEl, tidVal, fciCont, callType) void
  %assign      fcnCallSys = ::CompiledModel.System[sysIdx]
  %assign accelGuardStart = ""
  %assign   accelGuardEnd = ""
  
  %assign fcnCallSys.CurrentTID = FcnGetSubsystemCodeBufTID(fcnCallSys)

  %if fciCont && fcnCallSys.RunFcnCallSSInMinorStep == "yes"
    %assign fciCont = 0
    %%
    %% For Simulink accelerator, do not execute function-call subsystem
    %% code when a function-call initiator is continuous (e.g., an async ISR
    %% pseudo source) and we are in the Simulink consistency check stage.
    %%
    %if Accelerator || IsModelReferenceSimTarget ()
      %assign accelGuardStart = "if (!%<RTMSolverAssertCheck()>) {"
      %assign accelGuardEnd   = "}"
    %endif
  %endif
  
  %assign inlinedFCSS = LibSystemIsInlined(fcnCallSys)
      
  %% Return nothing if empty
  %if LibSystemFcnIsEmptyForTID(fcnCallSys,callType) 
    %assign fcnCallSys.CurrentTID = -1
    %return ""
  %endif
  %%
  %% 1. S-Function always have SimStruct.
  %% 2. RealTime only has SimStruct if it is forced to be a function call
  %%    (because it has a non-inlined s-function calling it)
  %% 3. Embedded-C never needs SimStruct.
  %%
  %assign argList = []
  %assign numArgs = 0
  %if Accelerator && LibAsynchronousTriggeredTID(tidVal)
    %% Accelerator does not maintain timing information for 
    %% asynchronous tasks, asynchronous task should use 
    %% base rate timing information. See g313672
    %assign tidVal = 0
  %endif
  %assign fcnInfo = LibGetFcnInfo(fcnCallSys, callType, fcnCallSys.CurrentTID)
  %if (inlinedFCSS)
    %%
    %if FcnSysNeedAddRTMArg(fcnCallSys, callType)
      %if RTMGetModelSS() != simObject
	%assign argList = argList + ...
	  "%<::tSimStructType> *const %<RTMGetModelSS()> = %<simObject>"
	%assign numArgs = numArgs + 1
      %endif
    %endif
    %if LibSystemFcnNeedsCPI(fcnCallSys,callType)
      %assign argList = argList + "int_T %<::tControlPortIdx> = %<portEl>"
      %assign numArgs = numArgs + 1
    %endif	   
    %if LibSystemFcnNeedsTID(fcnCallSys,callType)
      %assign argList = argList + "int_T %<::tTID> = %<tidVal>"
      %assign numArgs = numArgs + 1
    %endif
  %else
    %assign cgirName = fcnInfo.CGIRName
    
    %% Non-inlined FCSS
    %assign calleeModIdx = fcnCallSys.CGIRModuleIdx
    %assign calleeModule = ::CompiledModel.RTWCGModules.RTWCGModule[calleeModIdx]
    
    %assign hasTIDArg = 0
    %assign hasCPIArg = 0
    %assign hasRTMArg = 0
    
    %if ISFIELD(calleeModule, "SystemFunctions") && ...
      ISFIELD(calleeModule.SystemFunctions, cgirName)
      %assign fcnIdx = GETFIELD(calleeModule.SystemFunctions, cgirName)
      %assign calleeFcn = calleeModule.Function[fcnIdx]
      %assign hasTIDArg = calleeFcn.TIDArgIndex > -1
      %assign hasCPIArg = calleeFcn.CPIArgIndex > -1
      %assign hasRTMArg = calleeFcn.SimStructArgIndex > -1
    %endif
        
    %if !hasRTMArg && FcnSysNeedAddRTMArg(fcnCallSys, callType)
      %assign argList = argList + "%<simObject>"
      %assign numArgs = numArgs + 1
    %endif
    %if !hasCPIArg && LibSystemFcnNeedsCPI(fcnCallSys, callType)
      %assign argList = argList + "%<portEl>"
      %assign numArgs = numArgs + 1
    %endif
    %if !hasTIDArg && LibSystemFcnNeedsTID(fcnCallSys, callType)
      %assign argList = argList + "%<tidVal>"
      %assign numArgs = numArgs + 1
    %endif
  %endif
  %%
  %assign cgirName = fcnInfo.CGIRName
  %assign fcnCallSysFcn = fcnInfo.Name
  %% Dump the args array to a string
  %assign args = ""
  %%
  %% We first try call a function call subsystem within the given context
  %% (call outputs from outputs).
  %%
  %assign argVec = []
  %assign modIdx = ::CurrentModuleIdx
  %assign fcnIdx = ::CurrentFunctionIdx
  %if SLibTLCSystemFcnCallExists(callType, sysIdx, csIdx, modIdx, fcnIdx)
    %assign callInfo = ...
      SLibTLCSystemFcnCallInfo(callType, sysIdx, csIdx, modIdx, fcnIdx)
    %assign argVec = callInfo.Args
    %assign cgirName = callInfo.Name
  %else
    %%
    %% If the context is unknown, we dispach the function call 
    %% to use global argument references.
    %%
    %assign modIdx = ::CompiledModel.RTWCGModules.NumRTWCGModules-1
    %assign fcnIdx = ::CompiledModel.RTWCGModules.TestInterfaceFcnIdx
    
    %if SLibTLCSystemFcnCallExists(callType, sysIdx, csIdx, modIdx, fcnIdx)
      %assign callInfo = ...
        SLibTLCSystemFcnCallInfo(callType, sysIdx, csIdx, modIdx, fcnIdx)
      %assign argVec = callInfo.Args
      %assign cgirName = callInfo.Name
    %endif
  %endif    
  %openfile callBuffer
  %if inlinedFCSS
    %assign needBrace = (numArgs > 0) 
    %if (needBrace > 0)
      {
    %endif
    %if (numArgs > 0)
      %foreach argIdx = numArgs
	%<argList[argIdx]>;
      %endforeach
    %endif
    %assign fcnCache = "SLibGetBody%<callType>FcnCache"
    %assign fcnCacheBuf = %<fcnCache>(fcnCallSys)
    %if fciCont
      if (%<RTMIs("MajorTimeStep")>) {
      %<fcnCacheBuf>
      }
    %else
      %<accelGuardStart>
      %<fcnCacheBuf>
      %<accelGuardEnd>
    %endif
    %if (needBrace > 0)
      }
    %endif
  %else
    %assign comma = ""
    %if (numArgs > 0)
      %foreach argIdx = numArgs
        %assign args = args + comma + argList[argIdx]
        %assign comma = ", "
      %endforeach
    %endif    
    %assign addArgs = FcnGetAdditionalArgs(cgirName, argVec, callType, ...
      sysIdx, accessSysIdx, csIdx, TLC_FALSE, TLC_FALSE)
    %if !WHITE_SPACE(addArgs)
      %assign args = args + comma + addArgs
    %endif
    
    %if fciCont
      if (%<RTMIs("MajorTimeStep")>) {
        %if !EXISTS(callInfo.OpeningTraceComment)
      %<fcnCallSysFcn>(%<args>);
        %else
	  %% add traceability comment to the function call site
          %<callInfo.OpeningTraceComment>%<fcnCallSysFcn>%<callInfo.ClosingTraceComment>(%<args>);
        %endif
      }
    %else
      %<accelGuardStart>
      %if !EXISTS(callInfo.OpeningTraceComment)
      %<fcnCallSysFcn>(%<args>);
      %else
	%% add traceability comment to the function call site
        %<callInfo.OpeningTraceComment>%<fcnCallSysFcn>%<callInfo.ClosingTraceComment>(%<args>);
      %endif
      %<accelGuardEnd>
    %endif
  %endif %% inlinedFCSS
  %closefile callBuffer
  %assign fcnCallSys.CurrentTID = -1
  %if !WHITE_SPACE(callBuffer)
    %return callBuffer
  %else
    %return ""
  %endif    
%endfunction %% SLibCallFCSS

%<LibAddToCompiledModel("LibTID01Eq_Seen", 0)>
%% Function: LibTID01Eq ========================================================
%% Abstract:
%%      Return 1 if TID 0 and 1 are equivalent tasks, otherwise return 0.
%%
%% 	Note:  This function is left for backward compatibility only.  Use
%% 	       ::CompiledModel.FixedStepOpts.TID01EQ instead of this
%% 	       function.  This function may produce incorrect results due
%% 	       to round-off errors.
%%
%function LibTID01Eq() void
  %if !LibTID01Eq_Seen
    %assign ::CompiledModel.LibTID01Eq_Seen = 1
    %<SLibReportWarningWithId("RTW:tlc:DetectLibTID01Eq")>
  %endif
  %if NumSynchronousSampleTimes > 1
    %assign periodTID0 = SampleTime[0].PeriodAndOffset[0]
    %assign periodTID1 = SampleTime[1].PeriodAndOffset[0]
    %assign stepSize = FixedStepOpts.FixedStep
    %if periodTID0 == 0.0 && (stepSize == periodTID1)
      %return 1
    %endif
  %endif
  %return 0
%endfunction

%with ::CompiledModel
%assign RootSystemTasks = []
%foreach tidIdx = NumRuntimeExportedRates
  %assign RootSystemTasks = RootSystemTasks + tidIdx
%endforeach
%assign ::CompiledModel = ::CompiledModel + RootSystemTasks
%endwith

%% Function: LibSystemTasks ====================================================
%% Abstract:
%%   LibSystemTasks returns a vector containing the subsystem's TIDs.
%%
%%   Note, for convenience, the model tasks are group in a vector named
%%   RootSystemTasks and attached to ::CompiledModel
%%
%function LibSystemTasks(system) void
  %if system.Type == "root"
    %return ::CompiledModel.RootSystemTasks
  %endif
  %assign sysIdx  = system.CallSites[0][2]
  %assign blkIdx  = system.CallSites[0][3]
  %assign ssBlock = ::CompiledModel.System[sysIdx].Block[blkIdx]
  %if TYPE(ssBlock.SubsystemTID) == "Vector"
    %return ssBlock.SubsystemTID
  %else
    %return [%<ssBlock.SubsystemTID>]
  %endif
%endfunction

%% Function: LibTasksEqual =====================================================
%% Abstract:
%%   Determine if all specified tasks are equal (i.e. have the same TID)
%%
%%   Arguments:
%%      taskVector: Vector of TIDs
%%
%%
%function LibTasksEqual(taskVector) void
  %assign task = taskVector[0]
  %foreach idx = SIZE(taskVector, 1) - 1
    %if !ISEQUAL(taskVector[idx+1], task)
      %return 0
    %endif
  %endforeach
  %return 1
%endfunction

%% Function: LibIsSingleRateSystem ============================================
%% Abstract:
%%   LibIsSingleRateSystem returns one if the system is a single rate
%%   system, and zero otherwise.
%%   
%%   The system paramsetting for single rate is used to determine result.  Note that
%%   model wide events such as parameter sample time are not factored into the 
%%   setting
%%
%%
%function LibIsSingleRateSystem(system) void
  %if system.Type == "root"
    %assign sr = ::CompiledModel.SingleRate
  %else
    %assign sysIdx = system.CallSites[0][2]
    %assign blkIdx = system.CallSites[0][3]
    %with ::CompiledModel.System[sysIdx].Block[blkIdx]
      %assign bType  = (Type == "SubSystem") ? "Subsystem" : ""
      %assign sr     = LibBlockParamSetting(bType, "SingleRate")
    %endwith    
  %endif
  %if sr == "yes"
    %return 1
  %else
    %return 0
  %endif
%endfunction

%% Function: LibIsRateTransitionBlock ==========================================
%% Abstract:
%%   	LibIsRateTransitionBlock returns one if a block is being used as a rate
%%	transition and zero otherwise. The build-in unit delay and zoh
%%      block can be rate transition blocks. S-function blocks can also
%%      be rate transition blocks if they specify the SS_OPTION to do so.
%%
%function LibIsRateTransitionBlock(system, block)
  %if !LibIsSingleRateSystem(system) && SIZE(TID,1) == 1 && ...
    EXISTS("SampleTimeIdx")
    %if (TID != SampleTimeIdx)
      %return 1
    %endif
  %endif
  %return 0
%endfunction


%% Function: FcnERTIsSampleHitInMain ==================================================
%% Abstract
%%   Called by FcnGenerateTidGuardOpenCodeInMain for ERT code format.  
%%
%% NOTE: This function is similar to FcnERTIsSampleHit function except for the 
%% MajorTimeStep check (since this code will be in main.c)
%function FcnERTIsSampleHitInMain(tid) void
  %assert SLibIsERTCodeFormat() && !IsModelReferenceTarget()
  %if LibAsynchronousTriggeredTID(tid) && GenRTModel
    %% Generated code allways rate group async task 
    %% code. LibIsSampleHit(asyncTid) is not neccessary 
    %% for async code. It always returns true
    %return "1"
  %endif
  %if !SLibSingleTasking()
    %% Multitasking
    %if Tid01Eq && ISEQUAL(tid,1)
      %if SLibIsPeriodicRateGrouping()
        %return "1"
      %else
        %return "%<LibTID()> == 0"
      %endif
    %else
      %return "%<LibTID()> == %<tid>"
    %endif
  %elseif ISEQUAL(tid,0)
    %% Singletasking and tid==0; base rate always runs
    %return "1"
  %elseif NumContStates > 0
    %% Singletasking, need task counter
    %if RTMTaskCountersIsReqFcn()
      %assign taskCountStr = RTMGet("TaskCounters") + "." + ...
        SLibERTMultiRateCounterField(tid) + " == 0"
      %return "%<taskCountStr>"
    %else
      %return "1"
    %endif
  %elseif Tid01Eq && ISEQUAL(tid,1)
    %return "1"
  %else
    %% Otherwise
    %if RTMTaskCountersIsReqFcn()
      %return RTMGet("TaskCounters") + "." + ...
        SLibERTMultiRateCounterField(tid) + ...
        " == 0"
    %else
      %return "1"
    %endif
  %endif
%endfunction


%% Function: FcnERTsSampleHit ==================================================
%% Abstract
%%   Called by LibIsSampleHit for ERT code format.  Not to be call directly.
%%
%function FcnERTIsSampleHit(tid) void
  %assign modIdx = ::CurrentModuleIdx  
  %if modIdx > -1
    %assign thisModule = ::CompiledModel.RTWCGModules.RTWCGModule[modIdx]
    %assign thisSystem = ::CompiledModel.System[thisModule.CGSystemIdx]
    %if LibIsSingleRateSystem(thisSystem)
      %return "1"
    %endif
  %endif

  %% Export Function does not need local tid as each entry point is explicitly 
  %% scheduled. g1735899
  %if !SLibSingleTasking() && !SLibIsExportFcnDiagram()
    %% Multitasking
    %if Tid01Eq && ISEQUAL(tid,1)
      %if NumContStates > 0 || IsModelReferenceTarget()
        %if SLibIsPeriodicRateGrouping()
          %return "%<RTMIs("MajorTimeStep")>"
        %else
          %return "%<RTMIs("MajorTimeStep")> && \n" + "%<LibTID()> == 0"
        %endif
      %else
        %if SLibIsPeriodicRateGrouping()
          %return "1"
        %else
          %return "%<LibTID()> == 0"
        %endif
      %endif
    %else
      %return "%<LibTID()> == %<tid>"
    %endif
  %elseif ISEQUAL(tid,0)
    %% Singletasking and tid==0; base rate always runs
    %return "1"
  %elseif IsModelReferenceTarget()
    %assert ::CompiledModel.NumRuntimeExportedRates > 1
    %assert TYPE(tid) == "Number" && tid > 0
    %assign ans = ""
    %if Tid01Eq && ISEQUAL(tid,1)
      %assert LibIsContinuous(0)
      %assign ans = "%<RTMIs("MajorTimeStep")>"
    %else
      %if LibIsContinuous(0)
        %assign ans = "%<RTMIs("MajorTimeStep")> && "
      %endif
      %assign ans = "%<ans>%<RTMIsSampleHit(tid)>"
    %endif
    %return ans
  %elseif NumContStates > 0
    %% Singletasking, need MajorStepGuard + task counter
    %if RTMTaskCountersIsReqFcn()
      %assign taskCountStr = RTMGet("TaskCounters") + "." + ...
        SLibERTMultiRateCounterField(tid) + " == 0"
      %return "%<RTMIs("MajorTimeStep")> &&\n" + "%<taskCountStr>"
    %else
      %return "%<RTMIs("MajorTimeStep")>"
    %endif
  %elseif Tid01Eq && ISEQUAL(tid,1)
    %return "1"
  %else
    %% Otherwise
    %if RTMTaskCountersIsReqFcn()
      %return RTMGet("TaskCounters") + "." + ...
        SLibERTMultiRateCounterField(tid) + ...
        " == 0"
    %else
      %return "1"
    %endif
  %endif
%endfunction

%% Function: LibIsSampleHit ====================================================
%% Abstract:
%%   LibIsSampleHit returns the appropriate TID scope given that the tid is
%%   
%%   Discrete:   ssIsSampleHit(S, %<tid>, tid)
%%   Continuous: ssIsContinuousTask(S, tid)
%%   
%%   This function cannot be called with a TID that is neither
%%   discrete nor continuous.
%%   
%%   S-function blocks should not use this function directly. They should 
%%   instead use LibIsSFcnSampleHit().
%%
%%   Arguments:
%%      tid: Global integer task identifier (TID) of block
%%       or
%%      tid: String indicating that you are accessing discrete tasks
%%           using an indexing array.  This form is useful when looping
%%           over the sample times.  String indexing for ERT code format
%%           is supplied for backwards compatibility, however, results
%%           in inefficient code.
%%
%%   Returns:
%%      Non-ERT code formats:
%%
%%	One of the following sample hit macros:
%%
%%      rtmIsSampleHit(S, %<tid>, tid)  for a discrete TID
%%      rtmIsContinuousTask(S, tid)     for a continuous TID
%%
%%      ERT code format:
%%
%%      Appropriate tid check (e.g., tid == 0)
%%
%%
%function LibIsSampleHit(tid) void
  %% See Also:
  %%      LibIsSFcnSampleHit
  %%
  %if LibAsynchronousTriggeredTID(tid) && GenRTModel
    %% Generated code allways rate group async task 
    %% code. LibIsSampleHit(asyncTid) is not neccessary 
    %% for async code. It always returns true
    %return "1"
  %endif
  %if TYPE(tid) == "String"
    %if LibTriggeredTID(tid) || tid == "constant"
      %<SLibReportErrorWithIdAndArgs("RTW:tlc:InvalidTID", tid)>
    %endif
    %if SLibIsERTCodeFormat()
      %return FcnERTIsSampleHit(tid)
    %else
      %return RTMIsSampleHit(tid)
    %endif
  %else
    %if TYPE(tid) == "Number" && tid < 0
      %<SLibReportErrorWithIdAndArgs("RTW:tlc:InvalidTID", tid)>
    %endif
    %if SLibIsERTCodeFormat()
      %return FcnERTIsSampleHit(tid)
    %endif
    %assign period = ::CompiledModel.SampleTime[tid].PeriodAndOffset[0]
    %assign offset = ::CompiledModel.SampleTime[tid].PeriodAndOffset[1]
    %if period == 0.0 && offset == 0.0
      %return RTMIsContinuousTask()
    %else
      %return RTMIsSampleHit(tid)
    %endif
  %endif
%endfunction %% LibIsSampleHit


%% Function: LibIsSpecialSampleHit =============================================
%% Abstract:
%%   LibIsSpecialSampleHit returns the appropriate special sample hit macro.
%%   
%%   S-function blocks should not use this function directly. They should
%%   instead use LibIsSFcnSpecialSampleHit().
%%   (See the Simulink Coder documentation for more
%%   information about multi-tasking models.)
%%
%%   Arguments:
%%      sti: Sample time index of block (only relevant for Zero-Order Hold and
%%           Unit Delay blocks). The sample time index is the index of the
%%           slower sample time.
%%      tid: task identifier (TID) of block.  The TID is the index of the task
%%           with the faster sample time.
%%
%%   Returns:
%%	Non-ERT: rtmIsSpecialSampleHit(rtM,a,b,tid)
%%      ERT    : Appropriate rate interaction flag
%%
%function LibIsSpecialSampleHit(sti, tid) void
  %% See Also:
  %%      LibIsSFcnSpecialSampleHit
  %%
  %if SLibIsERTCodeFormat()
    %if SLibSingleTasking()
      %assign ::CompiledModel.RequireMultiRateSampleHits = 1
      %return LibIsSampleHit(%<sti>)
    %else
      %<SLibSetNeedRateInteraction(sti,tid)>
      %if IsModelReferenceTarget()
        %assign returnVal =  RTMIsSpecialSampleHit(%<sti>, %<tid>)
      %elseif SuppressMultiTaskScheduler
        %assign returnVal = ...
          "%<RTMGet("PerTaskSampleHits") + "." + ...
          SLibERTMultiRateTimingField(sti,tid)> == 1"
        %% Base system update need maintain SpecialSampleHit flags
        %assign baseSystem =  System[GetBaseSystemIdx()]
        %<SLibAccessThisSysFcnArgHelper(baseSystem.Interface.RTMArgDef,"Update","",tid, TLC_TRUE)>
      %else
        %assign returnVal = ...
          "%<RTMGet("PerTaskSampleHits") + "." + ...
          SLibERTMultiRateTimingField(sti,tid)>"
      %endif
      %if (NumContStates > 0) && ISEQUAL(%<tid>, 0)
        %assign returnVal = "%<RTMIs("MajorTimeStep")>" + " && " + returnVal
      %endif
      %return returnVal
    %endif
  %else
    %return RTMIsSpecialSampleHit(%<sti>, %<tid>)
  %endif
%endfunction

%<LibAddToCompiledModel("BlockInstanceDataCache", 0)>
%% Function: LibGenerateBlockInstanceData ======================================
%% Abstract:
%%   LibCacheBlockInstanceData generates the data allocation code for
%%   each block in a Simulink system.  This function updates
%%   the global variable, ::CompiledModel.BlockInstanceDataCache.
%%
%function LibCacheBlockInstanceData() void
  %assign rootSystem = System[NumSystems-1]
  %openfile buffer
  %with rootSystem
    %foreach blkIdx = NumBlocks
      %openfile tmpBuffer
      %<GENERATE(Block[blkIdx], "BlockInstanceData", rootSystem)>\
      %closefile tmpBuffer
      %if WHITE_SPACE(tmpBuffer) == 0
        {
          %<tmpBuffer>\
        }
      %endif
    %endforeach
  %endwith
  %closefile buffer
  %assign ::CompiledModel.BlockInstanceDataCache = buffer
%endfunction

%% Function: LibBlockInstanceDataIsEmpty =======================================
%% Abstract:
%%   LibBlockInstanceDataIsEmpty determines if there is any block instance
%%   data for this model.  It returns one if the cache is only white space
%%   and zero otherwise.
%% 
%%   Returns:
%%	1 if ::CompiledModel.BlockInstanceDataCache is only white space
%%      0 otherwise
%%
%function LibBlockInstanceDataIsEmpty() void
  %<LibTrapCacheAssert(BlockInstanceDataCache)>
  %return WHITE_SPACE(BlockInstanceDataCache)
%endfunction

%% Function: LibDumpBlockInstanceData =========================================
%% Abstract:
%%   LibDumpBlockInstanceData outputs the current block instance data
%%   cache to the output buffer.  The data cache that is output is
%%   stored in ::CompiledModel.BlockInstanceDataCache.
%%
%function LibDumpBlockInstanceData() Output
  %<LibTrapCacheAssert(BlockInstanceDataCache)>
  %if !WHITE_SPACE(BlockInstanceDataCache)
    
    /* block instance data */
    %<BlockInstanceDataCache>
  %endif
  %<SLibResetTLCGlobal("BlockInstanceDataCache")>\
%endfunction


%%------------------------------%
%% End of function library code %
%%------------------------------%

%% Function: SLibSetSkipInitializationFlag =====================================
%% Abstract:
%%   Low level function used by discrete integrator and unit-delay block to
%%   avoid re-initializing memory to zero.  This function is called in
%%   BlockInstanceSetup.  When the parameter is scalar, initialization
%%   requirements are determined up front (once).  If there is no initial
%%   value parameter, call this function with [] for the param.
%%
%function SLibSetSkipInitializationFlag(system,block,param) void
  %if ISEMPTY(param)
    %<SETFIELD(block, "SkipInitialization", ...
      !SLibXBInitRequired(system,block,[],"","",0))>
  %else
    %if system.StatesCanReset == "no" && !FcnParamInitRequired(param, -1)
      %<SETFIELD(block,"SkipInitialization",1)>
    %else
      %<SETFIELD(block,"SkipInitialization",0)>
    %endif
  %endif
%endfunction


%% Function: SLibXBInitRequired ================================================
%% Abstract:
%%   Whenever possible, avoid re-initializing the states and block outputs to
%%   zero since they are initialized to zero in the model's registration
%%   function.  Initialization is necessary in the following cases:
%%
%%   1) The code will roll (to avoid an empty for-loop).
%%   2) The code is located inside the system's initialize function (the
%%      states must re-initialize whenever the system enables).
%%   3) Initial condition (IC) value is not zero or not empty
%%
%%   This check will not be necessary when state and block outputs
%%   initialization is changed from run-time to static initialization.
%%
%% Note:
%%	Always returns true if the parameter is complex or the code format
%%      is other than Embedded-C.
%%
%%
%%   Arguments:
%% 	system: Reference to a Simulink system
%% 	block:  Reference to a block
%% 	param:  Parameter (If there is no initial value parameter, call 
%%              this function with [] for the param)
%% 	ucv:    User control variable string
%% 	lcv:    Loop control variable string
%% 	idx:    Index into parameter vector
%%
%%   Returns:
%%	1 if initialization of states and block outputs is required
%%      0 otherwise
%%
%%
%function SLibXBInitRequired(system, block, param, ucv, lcv, idx) void 

  %if system.StatesCanReset == "yes"
    %return 1
  %else
    %return !ISEMPTY(param) && SLibParamInitRequired(param,ucv,lcv,idx)
  %endif

%endfunction


%% Function: SLibParamInitRequired =============================================
%% Abstract:
%%   Whenever possible, avoid re-initializing parameters to zero since they
%%   are initialized to zero in the model's registration function.
%%   Parameter initialization (on it's own without enable and reset
%%   considerations) is necessary in the following cases:
%%
%%   1) The code will roll (to avoid an empty for-loop).
%%   2) Initial condition (IC) value is not zero.
%%
%% Note:
%%   Always returns true if the parameter is complex or the code format
%%   is other than Embedded-C.
%%
%%   Arguments:
%% 	param:  Parameter
%% 	ucv:    User control variable string
%% 	lcv:    Loop control variable string
%% 	idx:    Index into parameter vector
%%
%%   Returns:
%%	1 if initialization is required
%%      0 otherwise
%%
%%
%function SLibParamInitRequired(param, ucv, lcv, idx) void 

  %% If we are initializing any of the elements in the array (checked by SkipInitialization)
  %% then we need to initialize all of the elements if rolling.
  %% Otherwise, check this element to see if it needs to be initialized.
  %if ((SLibGetWidthOfValueFromParamRec(param) > 1) && (ucv != "" || lcv != ""))
    %return 1
  %else
    %return FcnParamInitRequired(param, idx)
  %endif
%endfunction


%% Function: FcnParamInitRequired =============================================
%% Abstract:
%%   Helper function; use idx == -1 to check all the elements
%%
%function FcnParamInitRequired(param, idx) void 

  %assign prmValue = SLibGetValueFromParamRec(param, TLC_TRUE)
  %assign nRows = SIZE(prmValue,0)
  %assign nCols = SIZE(prmValue,1)
  %assign width = nRows * nCols

  %if !SLibIsERTTarget()
    %return 1
  %endif
  
  %assign ASTNode = param.ASTNode

  %switch (ASTNode.Op)
    %case "SL_INLINED"
    %case "SL_CALCULATED"
      %% if the parameter is inlined or calculated, it is a candidate for
      %% the optimization
      %assign complex = SLibGetASTNodeIsComplex(ASTNode)

      %if complex
        %return 1
      %endif

      %assign dtype = SLibGetASTNodeDataTypeId(ASTNode)
      %% Can use param.Value in following line
      %% since param.Value == ModelParameter.Value
      %if TYPE(idx) == "Number" && idx == -1
	%foreach idx2 = width
	  %assign icValue = SLibParameterValue(prmValue, dtype, complex, 0, idx2)
	  %if !ISEQUAL(icValue,0)
	    %return 1
	  %endif
	%endforeach
      %else
	%assign icValue = SLibParameterValue(prmValue, dtype, complex, 0, idx)
	%if !ISEQUAL(icValue,0)
	  %return 1
	%endif
      %endif

      %break

    %default
      %% if the parameter is tunable or not inlined, don't optimize away 
      %% initialization
        %return 1
      %break
  %endswitch

  %return 0
%endfunction


%% =============================================================================
%% Enable subsystems use the ssIsFirstInitCond macro to determine time zero.
%% In order to optionally generate the boolean in the ERT real-time object,
%% we track the usage of this macro with LibIsFirstInitCond().
%%

%<LibAddToCompiledModel("IsFirstInitCondMacroUsed", 0)>
%% Function: SLibGetIsFirstInitCondAccessed ===================================
%% Abstract:
%%   SLibGetIsFirstInitCondAccessed returns the value of the global flag
%%   ::CompiledModel.IsFirstInitCondMacroUsed.
%%
%function SLibGetIsFirstInitCondAccessed() void
  %return IsFirstInitCondMacroUsed
%endfunction


%% Function: SLibIsFirstInitCond ==============================================
%% Abstract:
%%   Implements LibIsFirstInitCond. This bypasses the ExportFunctionsMode
%%   check. This bypass is generally not safe except to implement enabling
%%   semantics.  The following 'positive' case is safe if the call is made 
%%   during the Initialize (or Start, although superfluous) function since
%%   the initCondFlag is still maintained properly in the model Initialize 
%%   (and Start) functions when ExportFunctionsMode==1:
%%     if(%<LibIsFirstInitCond>) { ... }
%%   The following 'negative' case is safe only if guarded by:
%%     %if ProtectCallInitFcnTwice
%%        if(!%<LibIsFirstInitCond) {...}
%%     %endif
%%
%function SLibIsFirstInitCond() void
  %assign ::CompiledModel.IsFirstInitCondMacroUsed = 1
  %return RTMIs("FirstInitCond")
%endfunction

%% DocFunction{Other Useful Functions}: LibIsFirstInitCond =====================
%% Abstract:
%%   LibIsFirstInitCond returns generated code intended for placement in
%%   the initialization function.  This code determines, during run-time,
%%   whether the initialization function is being called for the first time.
%%
%%   This function also sets a flag to determine if the first-initialize-condition
%%   flag is needed.
%%
%%   This function is the TLC version of the SimStruct macro: ssIsFirstInitCond
%%
%function LibIsFirstInitCond() void
  %if ExportFunctionsMode == 1
    %<SLibReportErrorWithId("RTW:tlc:FirstInitInExpFcn")>
  %endif
  %return SLibIsFirstInitCond()
%endfunction




%% Function: SLibCallerHStuctDeclSystem =======================================
%% Abstract:
%%     return root or callers' HStructDeclSystem (caller's reused parent)
%%
%function SLibCallerHStuctDeclSystem(system, callSiteIdx) void

  %assign parentIdx = system.CallSites[callSiteIdx][0]
  %assign rSysIdx   = ::CompiledModel.System[parentIdx].HStructDeclSystemIdx
  %assign parent    = ::CompiledModel.System[rSysIdx]
  
  %return parent
  
%endfunction %% SLibCallerHStuctDeclSystem

%% Function: SLibCallerReusedParentSystem ====================================
%% Abstract:
%%     return root or callers' ReusedParentSystemIdx
%%
%function SLibCallerReusedParentSystem(system, callSiteIdx) void

  %assign parentIdx = system.CallSites[callSiteIdx][0]
  %assign rSysIdx   = ::CompiledModel.System[parentIdx].ReusedParentSystemIdx
  
  %return ::CompiledModel.System[rSysIdx]
  
%endfunction %% SLibCallerHStuctDeclSystem

%% Function: SLibResetNextVHTDueToEnable ======================================
%% Abstract:
%%   This method is called by a block's private enable method to properly 
%%   handle variable sample time inside an enabled subsystem.
%%   The subsystem will be calling BdSystemOutput before the sampleHit 
%%   vector is updated so we need to set the block's entry to true to 
%%   make sure it gets to run its output function in the next opportunity
%%
%function SLibResetNextVHTDueToEnable(block) void
  %assign tid = block.VarTsTID
  %if IsModelReferenceForASimstructBasedTarget()
    %assign idx = %<tid>
  %else
    %assign idx = CAST("Number", ::CompiledModel.SampleTime[tid].PeriodAndOffset[1])
  %endif
  %openfile buffer
  /* Force a sample hit at this major time step */
  %if IsModelReferenceForASimstructBasedTarget()
    %<FcnGenSpecialAccess(FcnInferredSystemAndAccessRTMArgDef(), "SampleHit", "set", 2, ...
      ["%<tid>", "0"], "1", SLibGetSimStruct())>;
  %else
    %<RTMuSetIdxed("SampleHit", tid, 1)>; 
  %endif
  %<RTMuSetIdxed("TaskTime", tid, LibGetT())>;
  %<RTMuSetIdxed("VarNextHitTime", "%<idx>", LibGetT())>;
  %closefile buffer
  %return buffer
%endfunction %% SLibResetNextVHTDueToEnable

%% Function: SLibFcnComputeInput ===============================================
%% Abstract:
%%    This function is used by blocks that conditionally need their inputs, 
%%    e.g., switch block. This function generates output code for the 
%%    conditionally executed subsystem driving the specified input.
%%
%function SLibFcnComputeInput(block, portIdx) Output
  %assign sysToCall   = SLibBlockSystemToCallForInput(portIdx)
  %assign sysIdx      = sysToCall[0]
  %assign callSiteIdx = sysToCall[1]
  %if sysIdx >= 0
    %assign ss = ::CompiledModel.System[sysIdx]
    %if !LibSystemFcnIsEmpty(ss, "Output")
      %<LibGenSystemFcnCall(ss, "Output", callSiteIdx)>\
    %endif
  %endif
%endfunction %%SLibFcnComputeInput

%% Function: SLibFcnComputeOutput ===============================================
%% Abstract:
%%    This function is used by blocks that conditionally call their outputs, 
%%    This function generates output code for the conditionally executed 
%%    subsystem driven by the specified output port.
%%
%function SLibFcnComputeOutput(block, portIdx) Output
  %assign sysToCall   = SLibBlockSystemToCallForOutput(portIdx)
  %assign sysIdx      = sysToCall[0]
  %assign callSiteIdx = sysToCall[1]
  %if sysIdx >= 0
    %assign ss = ::CompiledModel.System[sysIdx]
    %if !LibSystemFcnIsEmpty(ss, "Output")
      %<LibGenSystemFcnCall(ss, "Output", callSiteIdx)>\
    %endif
  %endif
%endfunction %%SLibFcnComputeOutput

%% Function: SLibZeroOutDerivativesForSystem ===================================
%% Abstract: 
%%   This function will geenrate the code to zero out the derivatives
%%   in a conditionally executed subsystem. Note it is
%%   the callers responsibility to declare the loop index i and 
%%   the double pointer dx.
%function SLibZeroOutDerivativesForSystem(ssBlock,system) Output

%%  %assign idx = system.Interface.ContStatesArgDef.FirstLocation
  %with  ssBlock
    %assign cStates = LibBlockParamSetting("Subsystem", "SystemContStates")
  %endwith
  %assign ncStates = cStates[0]
  %if (ncStates == 0) 
    %return 
  %endif  
  %assign idx = cStates[1]
  %assign cs = ::CompiledModel.ContStates.ContState[idx]
  %assign blkIdx = cs.SigSrc[2]
  %assign isMdlRef = FcnOwnerBlkType(cs) == "ModelReference"
  %assign varGroupIdx = cs.VarGroupIdx[2]
  %assign cross = system.CrossNoArgFcnBound  
  %assign blockPath = SLibCGIRVarGroupPath( ...
    varGroupIdx, system.HStructDeclSystemIdx, cross)

  %% Cstates for model reference block is stored in a structure
  %assign dxId = "%<blockPath>%<cs.Identifier>"
  
  %if ncStates > 1
    %if isMdlRef
      dx = (real_T *) &(%<dxId>);
    %elseif  cs.Width >1 
      dx = &(%<dxId>[0]);
    %else 
      dx = &(%<dxId>);
    %endif
    %assign dxZeroUpperLimitPlus1 = ncStates
    for (i=0; i < %<dxZeroUpperLimitPlus1>; i++) {
    dx[i] = 0.0;
    }
  %else
    %if  isMdlRef
      {
	real_T *dx = (real_T *) &(%<dxId>);
	(*dx) = 0.0;
      }
    %else
      %<dxId> = 0.0;
    %endif
  %endif
%endfunction

%% Function: SLibZeroOutZcSignalsForSystem ================================
%% Abstract: 
%%   This function will generate the code to zero out the zcSignals 
%%   in a conditionally executed subsystem. 
%% for adzc
%function SLibZeroOutZcSignalsForSystem(ssBlock,system) Output
  %with  ssBlock
    %assign nNSZC = LibBlockParamSetting("Subsystem", "NumNonsampledZCs")
  %endwith
  %if (nNSZC == 0)
    %return
  %endif
  
  %assert(SolverType == "VariableStep")
  %% This is not done before and happend to be ok becuase the zcsWith
  %% of modelref zcSignal is always 1. even so, the pointer is not casted.
  %% Need to handle model reference block (see 
  %%   SLibZeroOutDerivativesForSystem function)
  %assert(!IsModelReferenceTarget())
  
  %with  ssBlock
    %assign idx  =  LibBlockParamSetting("Subsystem", "BlkZcRecOffset")
    %assign nZCs =  LibBlockParamSetting("Subsystem", "NumZcSignalEls")
  %endwith
  
  %assign blkZcRec = ::CompiledModel.ZcRec.BlkZcRec[idx]
  %assign isMdlRef = FcnOwnerBlkType(blkZcRec) == "ModelReference"
  %assign idxVec = SLibGetSystemAndCallSideIndex(blkZcRec)
  %assign cross  = system.CrossNoArgFcnBound
  %assign sysIdx = idxVec[0]
  %assign  csIdx = idxVec[1]
  %assign varGroupIdx = FcnSysVarGroupIndex(System[sysIdx], ...
    "ZCSV", csIdx)
  %assign blockPath = SLibCGIRVarGroupPath...
      (varGroupIdx, system.HStructDeclSystemIdx, cross)
  %assign zcSignalInfo = blkZcRec.ZcSignalInfo[0]
  %assign name = FcnGetZCSignalCGVarName(zcSignalInfo)
  %if nZCs > 1    
    %if isMdlRef 
      real_T* zcsv = (real_T*)&(%<blockPath>%<name>);
    %elseif zcSignalInfo.Width > 1 
      real_T* zcsv = &(%<blockPath>%<name>[0]);
    %else
      real_T* zcsv = &(%<blockPath>%<name>);
    %endif
    int_T i;
    %assign dxZeroUpperLimitPlus1 = nZCs
    for (i=0; i < %<dxZeroUpperLimitPlus1>; i++) {
      zcsv[i] = 0.0;
    }
  %else
    %if  isMdlRef
      real_T *zcsv = (real_T *) &(%<blockPath>%<name>);
      (*zcsv) = 0.0;
    %else
      %<blockPath>%<name> = 0.0;
    %endif 
  %endif	
%endfunction


%% Function SLibSetStatesDisabled ===========================================
%% Abstract: 
%%   This function generates code to set the system states to the value
%%   passed
%function SLibSetStatesDisabled(ssBlock,system,value) Output
  %with  ssBlock
    %assign cStates = LibBlockParamSetting("Subsystem", "SystemContStates")
  %endwith
  %assign ncStates = cStates[0]
  %if (ncStates == 0) 
    %return 
  %endif  
  
  %assert(SolverType == "VariableStep")

  %assign idx = cStates[1]
  %assign cs = ::CompiledModel.ContStates.ContState[idx]
  %assign varGroupIdx = cs.VarGroupIdx[1]
  %assign cross = system.CrossNoArgFcnBound
  %assign blockPath = SLibCGIRVarGroupPath( ...
    varGroupIdx, system.HStructDeclSystemIdx, cross)

  %if ncStates > 1
    %if FcnOwnerBlkType(cs) == "ModelReference"
      %assign blk = System[cs.SigSrc[0]].Block[cs.SigSrc[2]]
      %assign intrf = GetModelrefInterface(blk)
      %assign mdlRefCsWith  = CAST("Number", %<intrf.xOptWidth>)
      %assign isArray = mdlRefCsWith > 1
    %else
      %assign isArray = cs.Width > 1
    %endif
      
    %if isArray >1
      (void) %<LibGenMemFcnCall("memset", ...
	"&(%<blockPath>%<cs.Identifier>[0])", value, ...
	"%<ncStates>*sizeof(boolean_T)")>;
    %else 
      (void) %<LibGenMemFcnCall("memset", ...
	"&(%<blockPath>%<cs.Identifier>)", value, ...
	"%<ncStates>*sizeof(boolean_T)")>;
    %endif
  %else
    %<blockPath>%<cs.Identifier> = %<value>;
  %endif
%endfunction

%% Function: SLibUnusedParameter ========================
%%
%function SLibUnusedParameter(param) 
  %if IsModelReferenceTarget()
    %openfile retBuf
    (void) (%<param>);
    %closefile retBuf
  %else
    %openfile retBuf
    %<LibGenUnusedParamFcnCall("RT_UNUSED_PARAMETER", "%<param>")>;
    %closefile retBuf
  %endif
  %return retBuf
%endfunction 


%% Function: SLibGenNonReusableSubsysFcnAsClassMemFcn =======================
%%  Should a non-reusable subsystem function be generated as a member function
%%  in the model class?
%function SLibGenNonReusableSubsysFcnAsClassMemFcn(system)
  %assign result = GenerateClassInterface && ...
                   !IsModelReferenceBaseSys(system) && ...
                   LibSystemIsNonReusedFcn(system)

  %return result
%endfunction %% SLibGenNonReusableSubsysFcnAsClassMemFcn


%% Function: SLibGetAlignmentSyntax =======================
%%  Should a non-reusable subsystem function be generated as a member function
%%  in the model class?
%function SLibGetAlignmentSyntax(mdlName, symbol, dataType, align, alignType)
  %assert (align > 0)
  %assign ret = ""
  %assign das = FEVAL("rtwprivate", "da_syntax", mdlName, symbol, dataType, align, alignType)  
  %if !ISEMPTY(das.err)
    %openfile errMsg
    %<das.err>
    %closefile errMsg
    %<SLibReportErrorWithIdAndArgs("RTW:tlc:GenericMsg", errMsg)>
  %else
    %assign ret = das.syntax
  %endif  
  %return ret
  
%endfunction

%% Function: SLibDumpPublicServerInterfaces ===============================================
%% Abstract:
%%
%function SLibDumpPublicServerInterfaces() void
  %if Accelerator || IsModelReferenceSimTarget() || isRAccel || SLibAutosarActive()
    %return
  %endif
  %with ::CompiledModel
  %if NumSimulinkFunctions == 0
    %return
  %endif

  %% Perform error checking
  %createrecord serverInterface { NumberOfServers 0 }
  %assign numFunctionsInThisModel = 0
  %foreach fcnIdx = NumSimulinkFunctions 
    %assign fcn = SimulinkFunction[fcnIdx]
    %if SLibSimulinkFunctionNeedsDeclaration(fcn)
      %assign numFunctionsInThisModel = numFunctionsInThisModel + 1
      %assign proto = SLibDeclareSimulinkFunction(fcn, TLC_TRUE, TLC_TRUE)
      %createrecord fcnRec { ...
        serverName "" ...
        model "" ...
        definedInThisModel TLC_FALSE ...
        fcnIdx -1 ...
        serverPrototype "" }
      %if ::GenerateClassInterface && (fcn.FullPathToFunction == "P")
        %assign classConfObj = FcnGetRTWCPPStepPrototypeRecord()
        %assign theClassName = classConfObj.ModelClassName
        %assign fcnRec.serverName = theClassName + "::" + fcn.CGFunctionName
      %else
        %assign fcnRec.serverName = fcn.CGFunctionName
      %endif
      %assign fcnRec.model = ::CompiledModel.Name
      %assign fcnRec.fcnIdx = fcnIdx
      %assign fcnRec.definedInThisModel = fcn.IsDefinedInThisModel == "yes"
      %assign fcnRec.serverPrototype = proto 
      %addtorecord serverInterface FunctionRecord %<fcnRec>
    %endif
  %endforeach
  
  %% It is possible that all the functions in the model are private,
  %% for example, they are all utility functions for DES or Messages.
  %% In this case, return early to simplify subsequent logic.
  %if numFunctionsInThisModel == 0    
    %return
  %endif

  %assert ::CompiledModel.GenUtilsSrcInSharedLocation == 1

  %assign serverInterface.NumberOfServers = numFunctionsInThisModel
  %assign result = FEVAL("rtwprivate", "addServerFunctionsToSCM", "%<LocalSharedCodeManagerFile>", serverInterface)
  %if !ISEMPTY(result.code)
    %if result.code == "ERROR"
      %<LibReportFatalError(result.message)>
    %elseif result.code == "WARNING"
      %<LibReportWarning(result.message)>
    %endif
  %endif

  %% Write out headers
  %% For sure if the header file doesn't exist, generate it.
  %foreach fcnIdx = NumSimulinkFunctions 
    %assign fcn = SimulinkFunction[fcnIdx]
    %if SLibSimulinkFunctionNeedsDeclaration(fcn) && !(GenerateClassInterface && fcn.FullPathToFunction != "G")
      %assign fileName = "%<::CompiledModel.RTWInfoMatFile.sharedSourcesDir>%<fcn.CGFunctionName>"
      %if FILE_EXISTS(fileName + ".h") == 0
        %assign fcn.WriteHeaderFile = "yes"
      %endif
    %endif
  %endforeach

  %% Then also write out ones that need to be updated
  %assign writeHeaderFileFcnIdx = result.writeHeaderFileFcnIdx
  %assign numHdrFiles = SIZE(writeHeaderFileFcnIdx, 1)
  %foreach fcnIdx = numHdrFiles
    %assign fcn = SimulinkFunction[writeHeaderFileFcnIdx[fcnIdx]]
    %assign fcn.WriteHeaderFile = "yes"
  %endforeach

  %% Now write them out
  %foreach fcnIdx = NumSimulinkFunctions 
    %assign fcn = SimulinkFunction[fcnIdx]
    %if SLibAutosarActive() && fcn.IsDefinedInThisModel == "no" && ...
      !IsModelReferenceTarget()
      %% Skip generating header file for AUTOSAR targets if:
      %% (a) The function is not defined in this model, that is, the model only
      %% contains the function-caller block. 
      %% (b) The model is not a referenced model
      %% The model where the function is defined will be responsible for 
      %% generating the header file. If such a model does not exist, then
      %% no header file will get generated.
      %continue
    %endif
    
    %if SLibSimulinkFunctionNeedsDeclaration(fcn) && !(GenerateClassInterface && fcn.FullPathToFunction != "G")
      %assign baseFileName = fcn.CGFunctionName
      %assign fileName = "%<::CompiledModel.RTWInfoMatFile.sharedSourcesDir>%<fcn.CGFunctionName>"
      %if fcn.WriteHeaderFile == "yes" 
        %if !ISFIELD(::CompiledModel, "RTWInfoMatFile")
          %<LoadRTWInfoMatFileforTLC()>
        %endif
        %assign proto = SLibDeclareSimulinkFunction(fcn, TLC_FALSE, TLC_FALSE)
        %openfile fcnSignature
        #ifndef RTW_HEADER_%<fcn.CGFunctionName>_
        #define RTW_HEADER_%<fcn.CGFunctionName>_
        
        /* Shared type includes */
        #include "%<SLibCoderTypesFilename()>"
        %<LibPushEmptyStackSharedUtils()>
        %assign multiWord = TLC_FALSE

        %foreach idx = SIZE(fcn.SymbDimsHeaderFiles, 1)
          %assign header = fcn.SymbDimsHeaderFiles[idx]
          %if header[0] == "<" || header[0] == "\""
            %<LibAddtoSharedUtilsIncludes(header)>
          %else
            %assign header = "\"" + header + "\""
            %<LibAddtoSharedUtilsIncludes(header)>
          %endif
        %endforeach
        %foreach idx = SIZE(fcn.ArgTypeIds, 1)
          %assign dtId = fcn.ArgTypeIds[idx]
          %assign header = LibHeaderForDataTypeIdx(dtId)
          %if !ISEMPTY(header)
            %<LibAddtoSharedUtilsIncludes(header)>
          %elseif LibIsDataTypeMultiWordFixpt(dtId)
            %assign multiWord = TLC_TRUE
          %endif
        %endforeach
        %if multiWord
          #include "%<SLibCoderMultiwordTypesFilename()>"
        %endif
        %assign sharedTypesHeaders = LibPopStackSharedUtilsIncludes()
        %foreach idx = SIZE(sharedTypesHeaders, 1)
          #include %<sharedTypesHeaders[idx]>
        %endforeach
        
        %% include Compiler.h to define AUTOSAR compiler abstraction macros
        %if SLibAutosarCompilerAbstractionRequired()
            #include "Compiler.h"
        %endif
        
        %if (fcn.IsVariantSimulinkFunction == "yes") 
          %assign isGlobalFcn = (fcn.IsGlobal == "yes")
          %if !isGlobalFcn
            %assign variantCondition = fcn.VariantCondition
            %assign ifCond = SLibIfVariantConditionForm16b(variantCondition)
            %assign ifEndCond = SLibEndIfVariantConditionForm16b(variantCondition)
          %endif
          %% Do not guard function declaration if public Simulink Function with declaration in the shared folder.
          %% TopTester: test/toolbox/simulink/variants/inlineVariants/simulinkFunction/tmLatchInputFromServer1_VC1.m
          %if !isGlobalFcn
            %<ifCond>
          %endif
          %if !GenerateClassInterface
            %if CGMODEL_ACCESS("CGModel.isIndividualFunctionMappingEnabled")
              %<SLibGetFcnMemSecPragmaForFunction(fcn.CGFunctionName, "SimulinkFunction", fcn.Name,  "Pre")>\
            %else
              %<SLibGetFcnMemSecPragmaOnDecl(fcn.CGFunctionName, "MemSecFuncExecute", "Pre")>\
            %endif
          %endif
          %<proto>
          %if !GenerateClassInterface
            %if CGMODEL_ACCESS("CGModel.isIndividualFunctionMappingEnabled")
              %<SLibGetFcnMemSecPragmaForFunction(fcn.CGFunctionName, "SimulinkFunction", fcn.Name,  "Post")>\
            %else
              %<SLibGetFcnMemSecPragmaOnDecl(fcn.CGFunctionName, "MemSecFuncExecute", "Post")>\
            %endif
          %endif
          %if !isGlobalFcn
            %<ifEndCond>
          %endif
        %else
          %if !GenerateClassInterface
            %if CGMODEL_ACCESS("CGModel.isIndividualFunctionMappingEnabled")
              %<SLibGetFcnMemSecPragmaForFunction(fcn.CGFunctionName, "SimulinkFunction", fcn.Name,  "Pre")>\
            %else
              %<SLibGetFcnMemSecPragmaOnDecl(fcn.CGFunctionName, "MemSecFuncExecute", "Pre")>\
            %endif
          %endif
          %<proto>
          %if !GenerateClassInterface
            %if CGMODEL_ACCESS("CGModel.isIndividualFunctionMappingEnabled")
              %<SLibGetFcnMemSecPragmaForFunction(fcn.CGFunctionName, "SimulinkFunction", fcn.Name,  "Post")>\
            %else
              %<SLibGetFcnMemSecPragmaOnDecl(fcn.CGFunctionName, "MemSecFuncExecute", "Post")>\
            %endif
          %endif
        %endif
        
        #endif
        %closefile fcnSignature
        %openfile bannerBuf
        /*
        * %<fileName>.h
        * 
        %<SLibCommonUtilHeaderInfo()>\
        */
        %closefile bannerBuf
        %assign file = LibCreateSourceFileAtPath("Header","Simulink",fileName,baseFileName)
        %<SLibSetModelFileAttribute(file, "Group", "utility")>
        %<LibSetSourceFileSection(file, "Functions", fcnSignature)>
        %<LibSetSourceFileSection(file, "Banner", bannerBuf)>
        %<SLibSetModelFileIndent(file, TLC_TRUE)>
        %<SLibSetModelFileShared(file, TLC_TRUE)>
      %else
        %<SLibAddGeneratedFileToList(fileName+".h", "utility", "header","")>
      %endif  
    %endif
  %endforeach

  %endwith
%endfunction


%endif %% _SYSLIB_

%% [EOF] syslib.tlc
