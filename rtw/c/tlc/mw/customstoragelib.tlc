%%
%% Copyright 1994-2018 The MathWorks, Inc.
%%

%if EXISTS("_CUSTOMSTORAGELIB_") == 0
%assign _CUSTOMSTORAGELIB_ = 1

%% For internal testing
%if EXISTS("CustomStorageIncludeFile")
  %include "%<CustomStorageIncludeFile>"
%endif

%%==================================%%
%% Custom storage support functions %%
%%==================================%%

%% Function: LibBlockSetCustomStorageComplianceLevel ===========================
%% Abstract:
%%   Set the custom storage compliance level of a block
%%
%function LibBlockSetCustomStorageComplianceLevel(block, level) void
  %assign block.CustomStorageClassCompliant = level
%endfunction


%% Function: LibHasCustomStorage ================================================
%% Abstract:
%%   Return 1 if the data record has a custom storage class, otherwise 0.
%%
%function LibHasCustomStorage(record) void
  %if record.StorageClass == "Custom"
    %if LibGetCustomStorageClassName(record) == ""
      %assign errTxt = "The custom storage class property is not " + ...
      "defined for data with identifier '%<LibGetRecordIdentifier(record)>'"
      %<LibReportFatalError(errTxt)>
    %endif
    %return 1
  %elseif SLibIsLegacyStorageClassForDataRecord(record)
    %return 1
  %endif
  %return 0
%endfunction

%% Function: LibCustomDataIsComplex ============================================
%% Abstract:
%%   Return whether the custom data is complex.
%%
%function LibCustomDataIsComplex(record)
  %switch record.RecordType
    %case "ZcSignalInfo"
    %case "BlockOutput"
    %case "ExternalInput"
    %case "ExternalOutput"
    %case "ModelParameter"
      %return LibGetRecordIsComplex(record)
      %%break
    
    %case "DWork"
      %return SLibDWorkIsComplex(record)
      %%break
    
    %case "MachineData"
      %assign errTxt = "Custom storage classes are not supported for Stateflow machine data"
      %<LibReportFatalError(errTxt)>
      
    %default
      %assign errTxt = "Unknown record type: %<record.RecordType>"
      %<LibReportFatalError(errTxt)>
  %endswitch
%endfunction

%function LibTrackFcnScope(record, type)
  %if !ISFIELD(record, "isFcnScoped")
    %return TLC_FALSE
  %endif
   
  %assign activeFcn = FcnGetActiveFcnForDecl()
  %if activeFcn == "GlobalMap"
    %return TLC_FALSE
  %endif

  %% Maybe we should also include initialize?  Thought can't really initialize
  %% function scope data in the same way.
  %if (type == "contents") || (type == "address")
    %assign declareInFcnScope = "DeclareIn%<activeFcn>FcnScope"
    %assign record.%<declareInFcnScope> = 1
    %<ReAssignLocalBlockOutputTID(record)>
    %return TLC_FALSE
  %endif
  
  %return TLC_TRUE
%endfunction
%% Function: LibAccessCustomData ================================================
%% Abstract:
%%   Call the "Data Access" method for the data record's custom storage
%%   class, using the specified access type.  Access types may be
%%   predefined (e.g. "contents", "declare") or user-defined.
%%
%function LibAccessCustomData(record,type,idx,reim,extra) void
  %assign cscDefn = SLibGetCSCDefForData(record)

  %% Call "Data Access" method without evaluating need for a cast
  %assign retVal = SLibAccessCustomDataNoMacroCasts(record,type,idx,reim,extra)

  %% Track function scope variables so we know to declare them
  %<LibTrackFcnScope(record, type)>

  %% Check if cast is needed
  %if type == "contents"
    %assign dtId = SLibGetRecordDataTypeId(record)
    %assign needCast = ((SLibGetDataInitForData(cscDefn, record) == "Macro") && ...
      ((SLibGetDataScope(cscDefn, record) == "Imported") || ...
       ( SLibIsIntegerDataTypeNotSizeofTargetInt(dtId))))

    %% Cast MACRO's to correct datatype
    %if needCast
      %assign dtypeName = LibGetRecordCompositeDataTypeName(record)
      %assign retVal = "((%<dtypeName>)%<retVal>)"
    %endif

  %endif

  %return retVal
%endfunction

%% Function: LibIsAccessingCustomDataForSILPIL
%% Abstract:
%%   Returns true if the DataAccess function associated with signal,
%%   parameter, or custom storage class record 'record' is being called to
%%   request information needed to build the interface for SIL or PIL.
%function LibIsAccessingCustomDataForSILPIL(record) void
    %return ISFIELD(record, "DataAccessForSILPIL") && ...
        record.DataAccessForSILPIL == TLC_TRUE
%endfunction

%% Function: SLibCustomDataNoMacroCasts
%% Abstract:
%%   Call the "Data Access" method for the data record's custom storage
%%   class, using the specified access type.  Access types may be
%%   predefined (e.g. "contents", "declare") or user-defined.

%function SLibAccessCustomDataNoMacroCasts(record,type,idx,reim,extra) void
  %assign genType = SLibGetGenerateTypeForData(record)
  %assign dTypeId = LibGetRecordDataTypeId(record)    
  %assign isComplex = LibCustomDataIsComplex(record)
  %assign isMultiWord = LibIsDataTypeMultiWordFixpt(dTypeId) 

  
  %% we cannot tell whether a bus field is complex or not from
  %% the bus signal record. always add reim part if it is a bus.
  %if isComplex || LibDataTypeIsBus(dTypeId)
    %% If the record is complex, prepend with a dot if necessary
    %switch reim
      %case tRealPart
      %case tImagPart
	%assign dot_reim = ".%<reim>"
	%break
      %default
	%assign dot_reim = reim
	%break
    %endswitch
    %% If it is not complex, slam it to null
  %else
    %assign dot_reim = ""
  %endif

  %if record.CustomStorageClassVersion > 1 || ...
    ISFIELD(record, "InstanceSpecificVersion")
    %if isMultiWord && type == "set" && LibIsMultiWordValue(extra)
      %%Mutliword case: set value
      %assign dTypeName = LibGetDataTypeNameFromId(dTypeId)    
      %assign tmpVar = "temp"
      %assign retVal = ""      
      %openfile retVal
      {
        %<dTypeName> %<tmpVar> = %<extra>;
        %<GENERATE_TYPE(record,"DataAccess",genType,type,idx,dot_reim,tmpVar)>
      }
      %closefile retVal
      %%
    %elseif isMultiWord && type == "initialize"
      %%Mutliword case: initialize      
      %assign grndName = SLibGetDtGroundName(dTypeId, isComplex, reim)
      %assign retVal = GENERATE_TYPE(record,"DataAccess",genType,"set",idx,dot_reim,grndName)
      %%
    %else
      %%Multiword else + single word
      %assign retVal = GENERATE_TYPE(record,"DataAccess",genType,type,idx,dot_reim,extra)
    %endif
  %else
    %if !ISEMPTY(extra)
      %assign errTxt = "Can not call custom storage class version 1 with " + ...
	"LibAccessCustomData unless the fifth argument is empty"
      %<LibReportFatalError(errTxt)>
    %endif
    %if isMultiWord && type == "initialize"
      %%Multiword case: initialize
      %assign grndName = SLibGetDtGroundName(dTypeId, isComplex, reim)
      %assign retVal = ""      
      %openfile retVal
      %<GENERATE_TYPE(record,"DataAccess",genType,"contents",idx,dot_reim)>  = %<grndName>; 
      %closefile retVal
    %else
      %assign retVal = GENERATE_TYPE(record,"DataAccess",genType,type,idx,dot_reim) 
    %endif
  %endif

  %if type == "define" || type == "declare"
    %if !ISEMPTY(retVal) && TYPE(retVal) != "String"
      %assert (TYPE(retVal) == "Scope")
      %if ISFIELD(retVal, "CustomDeclare")
        %assign fieldName = "CustomDeclare"
      %elseif ISFIELD(retVal, "CustomDefine")
        %assign fieldName = "CustomDefine"
      %else
        %assign errTxt = "When Custom TLC file returns non-empty data declaration/definition, " + ... 
        "the content must be put into a record field CustomDeclare/CustomDefine respectively"
        %<LibReportFatalError(errTxt)>
      %endif

      %assign contents = retVal.%<fieldName>
      %if !ISEMPTY(contents)
        %assign retVal.%<fieldName> = contents
      %endif
    %endif
  %endif

  %return retVal
%endfunction

%% Function: LibCustomDataIsAddressable =====================================
%% Abstract:
%%   Is data addressable?
%%
%function LibCustomDataIsAddressable(record) void
  %assign dataLayout = LibCustomData(record, "layout", "", "")
  %return dataLayout[0] != "other"
%endfunction

%% Function: LibCustomData ================================================
%% Abstract:
%%   Older version of LibAccessCustomData
%%
%function LibCustomData(record,type,idx,reim) void

  %switch type

   %case "qualifier"
     %assign msDefn = SLibGetMemorySectionDefForData(record)
     %return SLibGetQualifier(msDefn)
     %%break

   %default
     %return LibAccessCustomData(record,type,idx,reim,"")
     %%break
     
  %endswitch
%endfunction

%% Function: LibCustomClass =====================================================
%% Abstract:
%%   Call the "Class Access" method for the data record's custom storage
%%   class, using the specified access type.  Access types may be
%%   predefined (e.g. "setup", "comment") or user-defined.
%%
%function LibCustomClass(record,type) void
  %assign genType = SLibGetGenerateTypeForCSC(record)

  %return GENERATE_TYPE(record, "ClassAccess", genType, type)
%endfunction

%%=========================%%
%% Record access functions %%
%%=========================%%


%% Function: LibGetDataRecord ===================================================
%% Abstract:
%%   Return the record corresponding to the idx'th entry in the
%%   segment of the global memory map corresponding to the specified
%%   custom storage class
%%
%function LibGetDataRecord(class, idx) void
  %return class.Data[idx].RTWRecord
%endfunction

%% Function: LibGetRecordIdentifier =============================================
%% Abstract:
%%   Return the identifier associated with a given data record
%%
%function LibGetRecordIdentifier(record) void
  %if ISFIELD(record, "VarGroupIdx")
    %return SLibVarGroupElementName(record.VarGroupIdx[0], record.VarGroupIdx[1])
  %else
    %return record.Identifier
  %endif
%endfunction

%% Function: LibSetRecordIdentifier =============================================
%% Abstract:
%%   Modifies the identifier associated with a given data record
%%
%function LibSetRecordIdentifier(record, newIdentifier) void
  %if ISFIELD(record, "VarGroupIdx")
    %<SLibVarGroupSetElementName(...
      record.VarGroupIdx[0], record.VarGroupIdx[1], newIdentifier)>
  %endif
  %if ISFIELD(record, "Identifier")
    %assign record.Identifier = newIdentifier
  %endif
%endfunction

%% Function: LibGetRecordVarName ================================================
%% Abstract:
%%   Return the variable name for the data record
%%   (may be different to the identifier due to alias names)
%%
%function LibGetRecordVarName(record) void
  %if ISEMPTY(record.OrigIdentifier)
    %return LibGetRecordIdentifier(record)
  %else
    %return record.OrigIdentifier
  %endif
%endfunction

%% Function: LibGetCustomStorageClassName =======================================
%% Abstract:
%%   Return the name of the custom storage class associated with a data
%%   record
%%
%function LibGetCustomStorageClassName(record) void
  %assign rtwInfo = LibGetRTWInfoObjectProperties(record)
  %return rtwInfo.CustomStorageClass
%endfunction

%% Function: SLibGetRTWInfoObject ============================================
%% Abstract:
%%   Return RTWInfo object for data record
%%
%function SLibGetRTWInfoObject(record) void
  %% XXX (kramkuma) Function needs clean up
  %if ISFIELD (record, "Object")
    %assign parentProps = record.Object.ObjectProperties
    
    %if ISFIELD(parentProps, "RTWInfo")
      %return parentProps.RTWInfo.Object
    %else
      %return parentProps.CoderInfo.Object
    %endif
  %elseif (ISFIELD (record, "VarGroupIdx"))
    %assign coderGroupId = SLibGetCoderGroupIdForDataRecord(record)
    %if coderGroupId >= 0
      %assign coderGroup = ::CompiledModel.CoderDataGroup[coderGroupId]
      %return coderGroup.Object
    %else
      %return []
    %endif  
  %elseif (ISFIELD (record, "RTWRecord"))
    %assign coderGroupId = SLibGetCoderGroupIdForDataRecord(record.RTWRecord)
    %if coderGroupId >= 0
      %assign coderGroup = ::CompiledModel.CoderDataGroup[coderGroupId]
      %return coderGroup.Object
    %else
      %return []
    %endif  
  %else
    %return []
  %endif  
%endfunction

%% Function: LibGetRTWInfoObjectProperties ======================================
%% Abstract:
%%   Return the RTWInfo properties associated with a data record 
%%   corresponding to a Simulink data object
%%
%function LibGetRTWInfoObjectProperties(record) void
  %assign rtwInfoObj = SLibGetRTWInfoObject(record)
  %return rtwInfoObj.ObjectProperties
%endfunction

%% Function: LibGetRTWInfoObjectPackage =========================================
%% Abstract:
%%   Return the RTWInfo package associated with a data record 
%%   corresponding to a Simulink data object
%%
%function LibGetRTWInfoObjectPackage(record) void
  %% Get package name from property "CSCPackageName" if it exists
  %assign rtwInfo = LibGetRTWInfoObjectProperties(record)
  %if ISFIELD(rtwInfo, "CSCPackageName")
    %return rtwInfo.CSCPackageName
  %else
    %% Otherwise, get package name of the RTWInfo object
    %assign rtwInfoObj = SLibGetRTWInfoObject(record)
    %return rtwInfoObj.Package
  %endif   
%endfunction

%% Function: LibGetRTWInfoObjectClass ===========================================
%% Abstract:
%%   Return the RTWInfo class associated with a data record 
%%   corresponding to a Simulink data object
%%
%function LibGetRTWInfoObjectClass(record) void
  %assign rtwInfoObj = SLibGetRTWInfoObject(record)
  %return rtwInfoObj.Class
%endfunction

%% Function: LibGetCustomStorageAttributes ======================================
%% Abstract:
%%   Return the storage class attributes associated with a data record 
%%   corresponding to a Simulink.CustomParameter or Simulink.CustomSignal
%%
%function LibGetCustomStorageAttributes(record) void
  %assign rtwInfo = LibGetRTWInfoObjectProperties(record)
  %return rtwInfo.CustomAttributes.Object.ObjectProperties
%endfunction


%%=============================================================================
%function LibGetInstanceSpecificProp(cscDefn, customAttrProps, propname) void
%% Abstract:
%%   Return the instance-specific property value (from CustomAttributes) if
%%   it exists. Otherwise, return the default value (from the CSC definition)
%%
  %assert !ISEMPTY(cscDefn)

  %% Get the default value
  %if ISFIELD(cscDefn, propname)
    %assign propVal = cscDefn.%<propname>
  %elseif ISFIELD(cscDefn.CSCTypeAttributes, propname)
    %assign propVal = cscDefn.CSCTypeAttributes.%<propname>
  %else
    %assign errTxt = "Instance specific property '%<propname>' does not " + ...
                     "have a default counterpart in custom storage class " + ...
                     "definition '%<cscDefn.Name>'"
    %<LibReportFatalError(errTxt)>
  %endif

  %% Override with the instance-specific value
  %if LibIsPropInstanceSpecific(cscDefn, customAttrProps, propname)
    %assign propVal = customAttrProps.%<propname>
  %endif

  %return propVal
%endfunction


%%=============================================================================
%function LibIsPropInstanceSpecific(cscDefn, customAttrProps, propname) void
%% Abstract:
%%   Return true if the named CSC property is instance-specific
%%
  %assert !ISEMPTY(cscDefn)

  %if ISFIELD(customAttrProps, propname)
    %return TLC_TRUE
  %else
    %return TLC_FALSE
  %endif
%endfunction


%%=============================================================================
%function SLibGetDescriptionForData(record) void
  %assign desc = ""
  %if (record.HasObject == 1) && (ConfigSet.SimulinkDataObjDesc == 1)
    %assign desc = record.Object.ObjectProperties.Description
    %if !ISEMPTY(desc)
      %assign desc = FEVAL("strrep", desc, "/*", "/+")
      %assign desc = FEVAL("strrep", desc, "*/", "+/")
    %endif
  %endif

  %return desc
%endfunction


%%=============================================================================
%function SLibGetCSCDefForName(rtwInfoPkg, cscName) void
  %assign cscDefn = []

  %assign pkgRec  = GETFIELD(::CompiledModel.CustomStorageClasses.CSCReg, rtwInfoPkg)
  %assign cscDefn = GETFIELD(pkgRec.CSCDefs, cscName)
  %return cscDefn
%endfunction


%%=============================================================================
%% Abstract:
%%   Return the memory section definition, given a package and memory section name.
%%
%function SLibGetMemorySectionDefForName(rtwInfoPkg, msName) void
  %assign msDefn = []
  %if ISFIELD(::CompiledModel.CustomStorageClasses.CSCReg, rtwInfoPkg)
    %assign prec = GETFIELD(::CompiledModel.CustomStorageClasses.CSCReg, rtwInfoPkg)

    %if !ISEMPTY(prec.MemorySectionDefs) && ISFIELD(prec.MemorySectionDefs, msName)
      %assign msDefn = GETFIELD(prec.MemorySectionDefs, msName)
    %endif
  %endif
  
  %if ISEMPTY(msDefn)
    %assign errMsg = ...
      "Could not find memory section '%<msName>' in package '%<rtwInfoPkg>'.\n" + ...
      "Select a valid memory section on the 'Memory Sections' tab " + ...
      "in the Configuration Parameters dialog."
    %<LibReportError(errMsg)>
  %endif
  
  %return msDefn
%endfunction

%%=============================================================================
%% Abstract:
%%   Return the CSC Definition associated with the record. The CSC definition
%%   is a function of the CSCName and PackageName of the record. 
%%   The definition  is added to the record at TLC setup stage. See
%%   FcnAddCustomData in globalmaplib.tlc
%function SLibGetCSCDefForData(record) void
  %% Taking a data record as argument

  %return record.CSCDefn
%endfunction


%%=============================================================================
%% Abstract:
%%   Return the Memory Section Definition associated with the record. The 
%%   memory section is a function of the  memory section name (instance specific) 
%%   and PackageName of the record. 
%%   The definition  is added to the record at TLC setup stage. See
%%   FcnAddCustomData in globalmaplib.tlc
%function SLibGetMemorySectionDefForData(record) void
  %% Taking a data record as argument

  %return record.MSDefn
%endfunction


%%=============================================================================
%% NOTE: DataInit could be instance specific
%%
%function SLibGetDataInitForData(cscDefn, datarec) void
  %assign customAttrProps = LibGetCustomStorageAttributes(datarec)
  %assign dataInit = LibGetInstanceSpecificProp(cscDefn, customAttrProps, "DataInit")
  %assert !ISEMPTY(dataInit)

  %return dataInit
%endfunction


%%=============================================================================
%% NOTE: DataAccess could be instance specific
%%
%function SLibGetDataAccess(cscDefn, datarec) void
  %assign customAttrProps = LibGetCustomStorageAttributes(datarec)
  %assign dataAccess = LibGetInstanceSpecificProp(cscDefn, customAttrProps, "DataAccess")
  %assert !ISEMPTY(dataAccess)

  %return dataAccess
%endfunction

%%=============================================================================
%% NOTE: DataScope could be instance specific
%%
%function SLibGetDataScope(cscDefn, datarec) void
  %assign customAttrProps = LibGetCustomStorageAttributes(datarec)
  %assign dataScope = LibGetInstanceSpecificProp(cscDefn, customAttrProps, "DataScope")
  %assert !ISEMPTY(dataScope)

  %return dataScope
%endfunction

%%=============================================================================
%% NOTE: HeaderFile could be instance specific
%%
%function SLibGetHeaderFile(cscDefn, datarec) void
  %assign customAttrProps = LibGetCustomStorageAttributes(datarec)
  %assign hdr = LibGetInstanceSpecificProp(cscDefn, customAttrProps, "HeaderFile")
  %if ISEMPTY(hdr)
    %assign hdr = ""
  %endif

  %return hdr
%endfunction

%%=============================================================================
%% NOTE: Get the AccessDataThroughMacro property from the csc record
%%
%function SLibGetAccessDataThroughMacro(cscDefn) void
  %assert (cscDefn.CSCType == "AccessFunction")
  %return cscDefn.CSCTypeAttributes.AccessDataThroughMacro
%endfunction

%%=============================================================================
%% NOTE: Get the IsReusable property from the csc record
%%
%function SLibGetIsReusable(record) void
  %assert (record.StorageClass == "Custom") || ...
           SLibIsLegacyStorageClassForDataRecord(record)
  %if ISFIELD(record, "IsRemovedInIR") && SLibOmitRecord(record)
    %return TLC_FALSE
  %endif
  %assign cscDefn = record.CSCDefn
  %assign customAttrProps = LibGetCustomStorageAttributes(record)
  %return LibGetInstanceSpecificProp(cscDefn, customAttrProps, "IsReusable")
%endfunction

%%=============================================================================
%function SLibAddHeaderFileDelimeter(hdrfile) void
  %assert !ISEMPTY(hdrfile)

  %% Add "" as default if there's no delimiter
  %assign hlen = SIZE(hdrfile, 1)
  %if ((hdrfile[0] == "\"") && (hdrfile[hlen-1] == "\"")) || ...
      ((hdrfile[0] == "<") && (hdrfile[hlen-1] == ">"))
    %assign newhdr = hdrfile
  %else
    %assign newhdr = "\"" + hdrfile + "\""
  %endif

  %return newhdr
%endfunction

%function SLibGetQualifierString(aQualifier, aIsConst, aIsVolatile) void
  %assign qualifier = ISEMPTY(aQualifier) ? "" : "%<aQualifier> "
  %assign const = (aIsConst) ? "const " : ""
  %assign volatile = (aIsVolatile) ? "volatile " : ""
  %return "%<qualifier>%<const>%<volatile>"
%endfunction

%%=============================================================================
%function SLibGetQualifier(msDefn) void
  %return SLibGetQualifierString(msDefn.Qualifier, msDefn.IsConst, msDefn.IsVolatile)
%endfunction

%%=============================================================================
%function SLibGetQualifierWithoutConst(msDefn) void
    %assign qualifier = msDefn.Qualifier 
    %assign qualifier = ISEMPTY(qualifier) ? "" : "%<qualifier> "
    %assign volatile = (msDefn.IsVolatile) ? "volatile " : ""
    %return "%<qualifier>%<volatile>"
%endfunction

%%=============================================================================
%function SLibGetCSCDefForCSC(record) void
  %% Taking a class record as argument

  %assign rtwInfoPkg = record.Package
    %% RTWInfo package. May not be same as cscDefn.OwnerPackage.

  %assign cscName = record.Name

  %return SLibGetCSCDefForName(rtwInfoPkg, cscName)
%endfunction


%%=============================================================================
%function SLibGetMemorySectionDefForCSC(record) void
  %% Taking a class record as argument

  %assign rtwInfoPkg = record.Package
    %% RTWInfo package. May not be same as cscDefn.OwnerPackage.

  %assign cscDefn = SLibGetCSCDefForCSC(record)
  %assign msName = cscDefn.MemorySection

  %return SLibGetMemorySectionDefForName(cscDefn.MSPackage, msName)
%endfunction

%% Function: SLibCheckForUndefinedImportedMacros ===============================
%% Abstract:
%%   Cache code to validate imported macros.
%function SLibCheckForUndefinedImportedMacros(csc) void
  %assign cscDefn = SLibGetCSCDefForCSC(csc)
  %assign mdlPrivateBuffer = ""
  %assign mdlTypesBuffer   = ""
  %assign numData = SIZE(csc.Data)[1]
  %openfile mdlPrivateBuffer
  %openfile mdlTypesBuffer
  %foreach dataIdx = numData
    %selectfile NULL_FILE
    %% Get Data Record
    %assign dataRec = csc.Data[dataIdx]
    %assign props = LibGetCustomStorageAttributes(dataRec)

    %if (SLibGetDataInitForData(cscDefn, dataRec) == "Macro" && ...
         cscDefn.DataScope == "Imported")

      %% emit check to see if the macro is defined
      %assign id   = LibGetRecordIdentifier(dataRec.RTWRecord)
      %assign varName = LibGetRecordVarName(dataRec.RTWRecord)
      %% Skip this if we have pre-processor conditions on CSC set in global map
      %% this is to ensure that when we generate error checking code for CSC's
      %% we need to make sure VariantObject data is dumped. It is found that this
      %% function is called from many places even while generating global definitions
      %% for CSC's in model .c file. So with pre-processor conditions we need to defer
      %% it to a later stage while generating commonheader file for model.
      %% check the 'empty' because default is empty
      %if EXISTS(dataRec.PPIf) && !ISEMPTY(dataRec.PPIf)
        %continue
      %endif
      %if SLibParamIsVariantControlParam(LibGetDataRecord(csc, dataIdx))        
        %selectfile mdlTypesBuffer
      %else
        %selectfile mdlPrivateBuffer
      %endif
      %if varName == id
        %assign idDescr = "variable for the parameter \"%<varName>\""
      %else
        %assign idDescr = "variable \"%<id>\" for the parameter \"%<varName>\""
      %endif
      #ifndef %<id>
      #error The %<idDescr> is not defined
      #endif
    %endif
  %endforeach
  %closefile mdlPrivateBuffer
  %closefile mdlTypesBuffer
  %assign mdlPrivateCodeExists = !WHITE_SPACE(mdlPrivateBuffer)
  %assign mdlTypesCodeExists   = !WHITE_SPACE(mdlTypesBuffer)
  %if mdlPrivateCodeExists || mdlTypesCodeExists
    %openfile prequel
    
    /* 
     * Check that imported macros with storage class "%<csc.Name>" are defined
     */
     %closefile prequel
     %if mdlTypesCodeExists
       %<SLibCacheCodeToFile("data_simulink_variant_define", prequel+mdlTypesBuffer)>
     %endif
     %if mdlPrivateCodeExists
       %<SLibCacheCodeToFile("mdl_priv_macro_define", prequel+mdlPrivateBuffer)>
     %endif
   %endif
%endfunction

%%=============================================================================
%function SLibExpandGroundForStaticInit(width, isSymbolic, cmplx, gnd) void
  %if cmplx
    %assign initStr = "{%<gnd>, %<gnd>}"
  %endif
  %if TYPE(gnd) == "String"
    %assign initStr = gnd
  %else
    %assign initStr = STRING(gnd)
  %endif

  %if width == "1"
    %return initStr
  %elseif isSymbolic
    %% the width is symbolic, so we just initialize the first
    %% element. Although it is incomplete, it is only needed by
    %% compiler and not because of correctness so it is fine.
    %return "{%<initStr>}"
  %else
    %% the width is fixed size
    %openfile gndBuf
    {\
    %foreach idx = %<width>
      %if idx < %<width> - 1
        %<gnd>,\
      %else
        %<gnd>\
      %endif
    %endforeach
    }\
    %closefile gndBuf
    %return gndBuf
  %endif
%endfunction


%%=============================================================================
%function SLibExpandInitialValueForStaticInit(width, isSymbolic, cmplx, dtIdx, iv) void
  %openfile ivBuf
  %%
  %if isSymbolic || %<width> > 1
    {\
  %endif
  %%
  %% symbolic matrix must be emitted as array (need { and }). But we will
  %% initialize only the first element. Although it is incomplete, it is only
  %% needed by compiler and not because of correctness so it is fine.
  %if isSymbolic
    %assign width = 1
  %else
    %assign width = %<width>
  %endif
  %%
  %foreach idx = width
    %%
    %if cmplx
      %assign rval = SLibGetFormattedValueFromId(dtIdx, REAL(iv[idx]))
      %assign ival = SLibGetFormattedValueFromId(dtIdx, IMAG(iv[idx]))
      %assign val = "{%<rval>, %<ival>}"
    %elseif LibDataTypeIsBus(dtIdx)
      %assign val = "{%<SLibGetFormattedValueFromId(dtIdx, iv[idx])>}"
    %else
      %assign val = SLibGetFormattedValueFromId(dtIdx, iv[idx])
    %endif
    %%
    %if idx < (width - 1)
      %<val>,\
    %else
      %<val>\
    %endif
  %endforeach
  %%
  %if isSymbolic || width > 1
    }\
  %endif
  %%
  %closefile ivBuf
  %return ivBuf
%endfunction


%%=============================================================================
%function LibDataAccessInSpecificTLC(toPackage, toTLCName, record, request, idx, reim) void

  %assign genType = toPackage + "::" + toTLCName

  %if !%<GENERATE_TYPE_FUNCTION_EXISTS(record, "DataAccess", genType)>
    %assign toFilePath  = FcnGetTLCPathFromPackageName(toPackage, toTLCName)

    %generatefile "%<genType>" "%<toFilePath>"

    %if !%<GENERATE_TYPE_FUNCTION_EXISTS(record, "DataAccess", genType)>
      %assign myPackage = LibGetRTWInfoObjectPackage(record)
      %assign cscName   = LibGetCustomStorageClassName(record)
      %assign errTxt = "The DataAccess function does not exist in file: %<toFilePath>, " + ...
	"but it is needed for custom storage class: %<myPackage>::%<cscName>"
      %<LibReportFatalError(errTxt)>
    %endif
  %endif

  %return GENERATE_TYPE(record, "DataAccess", genType, request, idx, reim)
%endfunction


%%=============================================================================
%function LibClassAccessInSpecificTLC(toPackage, toTLCName, record, request) void
  %assign myPackage = record.Package
  %assign cscName = record.Name

  %assign genType = toPackage + "::" + toTLCName

  %if !%<GENERATE_TYPE_FUNCTION_EXISTS(record, "ClassAccess", genType)>
    %assign toFilePath  = FcnGetTLCPathFromPackageName(toPackage, toTLCName)
  
    %generatefile "%<genType>" "%<toFilePath>"
  
    %if !%<GENERATE_TYPE_FUNCTION_EXISTS(record, "ClassAccess", genType)>
      %assign errTxt = "The ClassAccess function does not exist in file: %<toFilePath>, " + ...
	"but it is needed for custom storage class: %<myPackage>::%<cscName>"
      %<LibReportFatalError(errTxt)>
    %endif
  %endif

  %return GENERATE_TYPE(record, "ClassAccess", genType, request)
%endfunction


%% Function: LibCustomStorageRecordIsCustomStorageClassInMap ====================
%% Abstract: 
%%   Return whether a record is a custom storage class record in
%%   the global memory map.
%%
%function LibCustomStorageRecordIsCustomStorageClassInMap(record) void
  %return (record.RecordType == "CustomStorageClassInMap")
%endfunction



%% Function: LibCustomStorageRecordIsModelParameter =============================
%% Abstract: 
%%   Return whether a record is a model parameter.
%%
%function LibCustomStorageRecordIsModelParameter(record) void
  %return (record.RecordType == "ModelParameter")
%endfunction



%% Function: LibCustomStorageRecordIsBlockState =================================
%% Abstract: 
%%   Return whether a record is a block state
%%
%function LibCustomStorageRecordIsBlockState(record) void
  %return (record.RecordType == "DWork")
%endfunction


%% Function: LibCustomStorageRecordIsBlockOutput ================================
%% Abstract: 
%%   Return whether a record is a block output
%%
%function LibCustomStorageRecordIsBlockOutput(record) void
  %return (record.RecordType == "BlockOutput")
%endfunction


%% Function: LibCustomStorageRecordIsExternalInput ==============================
%% Abstract: 
%%   Return whether a record is an external input
%%
%function LibCustomStorageRecordIsExternalInput(record) void
  %return (record.RecordType == "ExternalInput")
%endfunction


%% Function: LibCustomStorageRecordIsExternalOutput =============================
%% Abstract: 
%%   Return whether a record is an external output
%%
%function LibCustomStorageRecordIsExternalOutput(record) void
  %return (record.RecordType == "ExternalOutput")
%endfunction


%% Function: LibCustomStorageVerifyRecordIsModelParameter =======================
%% Abstract: 
%%   Report an error if record is not a parameter yet the custom storage
%%   class associated with the record only supports parameters
%%
%function LibCustomStorageVerifyRecordIsModelParameter(record) void
  %if LibCustomStorageRecordIsModelParameter(record) == 0
    %assign varName = LibGetRecordVarName(record)
    %assign sc = LibGetCustomStorageClassName(record)
    %assign errTxt = "Custom storage class '%<sc>' " + ...
      "is not legal for '%<varName>' because it is not a parameter"
    %<LibReportError(errTxt)>
  %endif
  %return
%endfunction


%% Function: LibCustomStorageVerifyAttributesIsNotEmpty ============================
%% Abstract: 
%%   Report an error if the specified custom attributes property does not exist or
%%   is empty
%%
%function LibCustomStorageVerifyAttributesIsNotEmpty(record, propName) void
  %assign customAttribs = LibGetCustomStorageAttributes(record)
  %assign varName = LibGetRecordVarName(record)
  %if ISFIELD(customAttribs, propName)
    %if ISEMPTY(customAttribs.%<propName>)
      %assign errTxt = "Data '%<varName>' must have '%<propName>' set"
      %<LibReportError(errTxt)>
    %endif
  %else
    %assign errTxt = "Data '%<varName>' does not have custom attribute '%<propName>'"
    %<LibReportError(errTxt)>
  %endif
  %return
%endfunction


%% Function: LibCustomStorageVerifyRecordIsScalar ===============================
%% Abstract: 
%%   Report an error if record is not a scalar yet the custom storage
%%   class associated with the record only supports scalars
%%
%function LibCustomStorageVerifyRecordIsScalar(record) void
  %if LibGetDataWidth(record) != 1 
    %assign varName = LibGetRecordVarName(record)
    %assign sc = LibGetCustomStorageClassName(record)
    %assign errTxt = "Custom storage class '%<sc>' " + ...
      "is not legal for '%<varName>' because it is not a scalar"
    %<LibReportError(errTxt)>
  %endif
  %return
%endfunction



%% Function: LibCustomStorageVerifyRecordIsNonComplex ===========================
%% Abstract: 
%%   Report an error if record is complex yet the custom storage
%%   class associated with the record only supports non-complex
%%
%function LibCustomStorageVerifyRecordIsNonComplex(record) void
  %if LibGetRecordIsComplex(record)
    %assign varName = LibGetRecordVarName(record)
    %assign sc = LibGetCustomStorageClassName(record)
    %assign errTxt = "Custom storage class '%<sc>' " + ...
      "is not legal for %<varName> because it is complex"
    %<LibReportError(errTxt)>
  %endif
  %return
%endfunction

%% Function: LibCustomStorageVerifyRecordIsNonStruct ===========================
%% Abstract: 
%%   Report an error if record is struct yet the custom storage
%%   class associated with the record only supports non-struct
%%
%function LibCustomStorageVerifyRecordIsNonStruct(record) void
  %assign dataTypeId = ...
        LibGetDataTypeIdAliasedThruToFromId(LibGetRecordDataTypeId(record))
  %if LibIsStructDataType(dataTypeId)
    %assign varName = LibGetRecordVarName(record)
    %assign sc = LibGetCustomStorageClassName(record)
    %assign errTxt = "Custom storage class '%<sc>' " + ...
      "is not legal for %<varName> because it is a structure"
    %<LibReportError(errTxt)>
  %endif
  %return
%endfunction

%% Function: FcnErrorForIdentifierSub ==========================================
%% Abstract: 
%%   Error out if $N is found in pragma string.
%%
%function FcnErrorForIdentifierSub(pragma) void
  %if !ISEMPTY(FEVAL("strfind", pragma, "$N"))
    return TLC_TRUE
  %endif
  %return TLC_FALSE
%endfunction
  
%% Function: SLibCheckMemorySectionConsistency ==================
%% Abstract: 
%%   This function puts the CSCDefn and Memory Section of
%%   the package that is passed in into the ::CompiledModel
%%
%function SLibCheckPackageConsistency(CSCDefs, MemorySectionDefs) void
  %if !ISEMPTY(MemorySectionDefs)
    %assign memSecDefns = FIELDNAMES(MemorySectionDefs)
    %assign numMemSecs  = SIZE(memSecDefns)[1]
    %foreach memIdx = numMemSecs
      %assign memSecName = memSecDefns[memIdx]
      %assign memSecDef = MemorySectionDefs.%<memSecName>

      %% If the pragmas go around all variables for this MS
      %if !memSecDef.PragmaPerVar
        
        %% We should not find $N in pragma strings
        %if (%<FcnErrorForIdentifierSub(memSecDef.PrePragma)> || ...
             %<FcnErrorForIdentifierSub(memSecDef.PostPragma)>)
          %assign errTxt = ...
            "%<memSecName>: Identifier substution not allowed in " ...
            "memory section if pragmas do not apply to individual variables."
          %<LibReportError(errTxt)>
        %endif
      %endif
    %endforeach

    %if !ISEMPTY(CSCDefs)
      %assign cscDefns = FIELDNAMES(CSCDefs)
      %assign numCscs  = SIZE(cscDefns)[1]
      %foreach cscIdx = numCscs
        %assign cscDef = CSCDefs.%<cscDefns[cscIdx]>
  
        %% If the csc is not of type 'Unstructured'
        %if cscDef.CSCType != "Unstructured"
          %assign memSecDef = SLibGetMemorySectionDefForName(cscDef.MSPackage, cscDef.MemorySection)
          
          %if (%<FcnErrorForIdentifierSub(memSecDef.PrePragma)> || ...
            %<FcnErrorForIdentifierSub(memSecDef.PostPragma)>)
            %assign errTxt = "%<cscDefns[cscIdx]>: Memory section cannot " ...
              "do identifier substitution if CSC is not Unstructured."
            %<LibReportError(errTxt)>
          %endif
          
        %endif
      %endforeach
    %endif
  %endif
  %return
%endfunction

%% Function: FcnLoadAllRelatedPackages ========================
%% Abstract:
%% This is a recursive function which adds the CSC/MS definitions
%% through MATLAB code if the package does not exist in the compiled model

%function FcnLoadAllRelatedPackages(packagename) void
  %% If the package is not already registered, add it now
  %if !ISFIELD(::CompiledModel.CustomStorageClasses.CSCReg, packagename)
    
    %% Add Record
    %addtorecord ::CompiledModel.CustomStorageClasses.CSCReg %<packagename> {}
    %assign prec = GETFIELD(::CompiledModel.CustomStorageClasses.CSCReg, packagename)
    
    %% Get CSCs and check for any errors
    %assign userDefs = FEVAL("cscdefn2struct", packagename)
    %if !ISEMPTY(userDefs.ErrorString)
      %<LibReportError(userDefs.ErrorString)>      
    %endif
    
    %if ISEMPTY(userDefs.CSCDefs)
      %addtorecord prec CSCDefs {}
    %else
      %addtorecord prec CSCDefs %<userDefs.CSCDefs>
    %endif
    
    %if ISEMPTY(userDefs.MemorySectionDefs)
      %addtorecord prec MemorySectionDefs {}
    %else
      %addtorecord prec MemorySectionDefs %<userDefs.MemorySectionDefs>
    %endif     
    
    %% CSCDefs.%_cscDefns[cscIdx]>
    %% Add packages of CSCs/MSs being refered to
    %assign cscdefns =  FIELDNAMES(prec.CSCDefs)
    %assign numOfCSCs = SIZE(cscdefns)[1]
    %foreach idx = numOfCSCs     
      %assign mspkgname = prec.CSCDefs.%<cscdefns[idx]>.MSPackage
      %if !ISFIELD(::CompiledModel.CustomStorageClasses.CSCReg, mspkgname)
        %<FcnLoadAllRelatedPackages(mspkgname)>
      %endif               
    %endforeach     
    
  %endif  
  %return 
%endfunction     
     
%% Function: SLibCacheRTWInfoPackage ===========================
%% Abstract: 
%%   This function puts the CSCDefn and Memory Section of
%%   the package that is passed in into the ::CompiledModel
%%
%function SLibCacheRTWInfoPackage(packagename) void
    %<FcnLoadAllRelatedPackages(packagename)>
    %assign prec = GETFIELD(::CompiledModel.CustomStorageClasses.CSCReg, packagename)
    %<SLibCheckPackageConsistency(prec.CSCDefs, prec.MemorySectionDefs)>
    %return
%endfunction     
     
%% Function: SLibAreInternalMemorySectionsDefined ==============================
%% Abstract:
%%   Check if internal memory sections are defined.
%%
%% NOTE: For model-level data/functions, the system is the ConfigSet.
%%
%function SLibAreInternalMemorySectionsDefined() void
  %if SLibIsERTTarget()   
    %return (::CompiledModel.CoderDictionary.DefaultMemorySections.MemSecPackage != "--- None ---")
  %else
    %return TLC_FALSE
  %endif

%endfunction

%% Function: SLibGetInternalMemorySectionDefForName ============================
%% Abstract:
%%   Return the memory section definition for internal data/functions
%%   given a memory section name.
%% 
%function SLibGetInternalMemorySectionDefForName(memsecname)
  %assert(SLibAreInternalMemorySectionsDefined())
  
  %assign memSecPkg = ::CompiledModel.CoderDictionary.DefaultMemorySections.MemSecPackage
  %return SLibGetMemorySectionDefForName(memSecPkg, memsecname)
%endfunction
  
%% Function: SLibSetupInternalMemorySections ===================================
%% Abstract: 
%%   This function puts the CSCDefn and Memory Section in the 
%%   ::CompiledModel for the package defined by MemSecPackage in the ConfigSet
%%
%function SLibSetupInternalMemorySections() void
  %if (!SLibAreInternalMemorySectionsDefined())
    %return 
  %endif

  %assign msPkg = ::CompiledModel.CoderDictionary.DefaultMemorySections.MemSecPackage
  %if ISEMPTY(msPkg)
    %return
  %endif

  %%
  %% Cache all registered CSCDefs/MemorySectionDefs of given RTWInfo package
  %% into ::CompiledModel.CustomStorageClasses.CSCReg.$msPkg if not
  %% already done so.
  %%
  %<SLibCacheRTWInfoPackage(msPkg)>
  
%endfunction

%% Function: SLibPragmaRegexp =====================================
%% Abstract: 
%%   Perform token substitutions associated with memory section definitions 
%%
%function SLibPragmaRegexp(MemorySectionName, pragmastring) void

  %if !ISEMPTY(pragmastring)
    %assign AUTOSAR_COMPONENT = SLibAutosarActive() ? AutosarSWCName() : LibGetModelName()
    %assign pragmastring = FEVAL("regexprep", pragmastring, "\%<AUTOSAR_COMPONENT>", AUTOSAR_COMPONENT)
    %assign pragmastring = FEVAL("regexprep", pragmastring, "\%<MemorySectionName>", MemorySectionName)
  %endif

  %return pragmastring

%endfunction

%% Function: SLibSetupCustomStorageClasses =====================================
%% Abstract: 
%%   Perform actions associated with custom storage classes prior to 
%%   their use
%%
%function SLibSetupCustomStorageClasses() void

  %with ::CompiledModel.CustomStorageClasses
  
    %% Set up the record to cache CSC & Memory Sections
    %if !ISFIELD(::CompiledModel.CustomStorageClasses, "CSCReg")
      %addtorecord ::CompiledModel.CustomStorageClasses CSCReg {}
    %endif

    %foreach idx = NumCustomStorageClasses
      %assign sc = CustomStorageClass[idx] 
      %assign cscName = sc.Name
      %assign rtwInfoPkg = sc.Package
      %% RTWInfo package. May not be same as cscDefn.OwnerPackage.
  
      %%
      %% Cache all registered CSCDefs/MemorySectionDefs of given RTWInfo package
      %% into ::CompiledModel.CustomStorageClasses.CSCReg.$rtwInfoPkg if not
      %% already done so.
      %%
      %<SLibCacheRTWInfoPackage(rtwInfoPkg)>      
  
      %%
      %% Setup the generate type to the right TLC file of this custom storage class
      %%
      %addtorecord sc Data {}
      %assign dummyScope = sc

      %assign filePkgAndName = FcnGetTLCFilePackageAndName(rtwInfoPkg, cscName)
      %assign filePkg = filePkgAndName[0]
      %assign fileName = filePkgAndName[1]

      %assign filePath = FcnGetTLCPathFromPackageName(filePkg, fileName)
 
      %if !FILE_EXISTS(filePath)
        %assign errTxt = "The file %<filePath> does not exist, " + ...
  	  "but it is needed for the custom storage class %<rtwInfoPkg>::%<cscName>"
        %<LibReportError(errTxt)>
      %endif
  
      %assign genType = SLibGetGenerateTypeForName(rtwInfoPkg, cscName)
      %generatefile "%<genType>" "%<filePath>"

      %if !%<GENERATE_TYPE_FUNCTION_EXISTS(dummyScope, "DataAccess", genType)>
	%assign errTxt = "The DataAccess function does not exist in file: %<filePath>, " + ...
	  "but it is needed for custom storage class: %<rtwInfoPkg>::%<cscName>"
        %<LibReportFatalError(errTxt)>
      %endif

      %if !%<GENERATE_TYPE_FUNCTION_EXISTS(dummyScope, "ClassAccess", genType)>
	%assign errTxt = "The ClassAccess function does not exist in file: %<filePath>, " + ...
	  "but it is needed for custom storage class: %<rtwInfoPkg>::%<cscName>"
        %<LibReportFatalError(errTxt)>
      %endif

    %endforeach  %% idx in CustomStorageClass
    
    %%
    %% If MemSecPackage is not '--- None ---', load the MemSecPackage.
    %%
    %<SLibSetupInternalMemorySections()>
    
    %%
    %% Create the custom part of the map
    %%
    %<SLibMapCustomData()>
    
    %%
    %% Loop through RTWInfo packages and Sanitize user strings for use in TLC
    %%
    %assign rtwInfoPkgNames = FIELDNAMES(CSCReg)
    %assign numRTWInfoPkgs = SIZE(rtwInfoPkgNames)[1]
    %foreach idx = numRTWInfoPkgs
  
      %assign rtwInfoPkg = rtwInfoPkgNames[idx]
      %assign rtwInfoPkgDefs = CSCReg.%<rtwInfoPkg>

      %% Sanitize CSC Definitions in this RTWInfo package
      %assign cscDefns = FIELDNAMES(rtwInfoPkgDefs.CSCDefs)
      %assign numCSCs  = SIZE(cscDefns)[1]
      %foreach cscIdx = numCSCs
        %assign cscDefn = rtwInfoPkgDefs.CSCDefs.%<cscDefns[cscIdx]>
        
        %if SLibIsCSCObjectBasedByName(cscDefn.OwnerPackage, cscDefn.Name)
          %% Object-based CSCs have all comments generated from RTWCG/IR directly
          %assign cscRec = LibGetCustomStorageInMap(rtwInfoPkg, cscDefn.Name)
          %if !ISEMPTY(cscRec)
            %assign cscDefn.TypeComment    = ""
            %assign declFcnName = "SLibObjectCSCClass_Decl_" + cscDefn.OwnerPackage + "_" + cscDefn.Name
            %assign cscDefn.DeclareComment = %<declFcnName>()
            %assign defnFcnName = "SLibObjectCSCClass_Defn_" + cscDefn.OwnerPackage + "_" + cscDefn.Name
            %assign cscDefn.DefineComment  = %<defnFcnName>()
          %endif
        %elseif cscDefn.CommentSource == "Default"
          %assign cscRec = LibGetCustomStorageInMap(rtwInfoPkg, cscDefn.Name)
          %if !ISEMPTY(cscRec)
            %assign cscDefn.TypeComment    = LibCustomClass(cscRec, "typeComment")
            %assign cscDefn.DeclareComment = LibCustomClass(cscRec, "declComment")
            %assign cscDefn.DefineComment  = LibCustomClass(cscRec, "defnComment")
          %endif
        %else
          %assign cscDefn.TypeComment = FcnSanitizeUserString(cscDefn.TypeComment)
          %assign cscDefn.DeclareComment = \
                                     FcnSanitizeUserString(cscDefn.DeclareComment)
          %assign cscDefn.DefineComment = \
                                     FcnSanitizeUserString(cscDefn.DefineComment)
        %endif
  
        %assign cscDefn.HeaderFile     = FcnSanitizeUserString(cscDefn.HeaderFile)
        %assign cscDefn.DefinitionFile = FcnSanitizeUserString(cscDefn.DefinitionFile)
        %assign cscDefn.Owner          = FcnSanitizeUserString(cscDefn.Owner)
      %endforeach
  
      %% Sanitize Memory Section comments in this RTWInfo package
      %assign memSecDefns = FIELDNAMES(rtwInfoPkgDefs.MemorySectionDefs)
      %assign numMemSecs  = SIZE(memSecDefns)[1]
      %foreach memIdx = numMemSecs
        %assign memSecDef = rtwInfoPkgDefs.MemorySectionDefs.%<memSecDefns[memIdx]>
        %assign memSecDef.Comment    = FcnSanitizeUserString(memSecDef.Comment)
        %assign memSecDef.PrePragma  = SLibPragmaRegexp(memSecDef.Name, FcnSanitizeUserString(memSecDef.PrePragma))
        %assign memSecDef.PostPragma = SLibPragmaRegexp(memSecDef.Name, FcnSanitizeUserString(memSecDef.PostPragma))
      %endforeach
  
    %endforeach

    %%
    %% Call the create method for the storage class, passing the map entry as
    %% the record
    %%

    %foreach idx = NumCustomStorageClasses
      %assign sc         = CustomStorageClass[idx]
      %assign cscName    = sc.Name
      %assign rtwInfoPkg = sc.Package
      %assign class      = LibGetCustomStorageInMap(rtwInfoPkg, cscName)
      %%
      %% Do not call LibCustomClass when there are no instances of a
      %% recognized class. When there are no instances the class record
      %% is empty.
      %%
      %% This allows classes that have been emptied by custom target
      %% preprocessing. Removing this will cause errors to any custom
      %% target code generation process that removes all instances of
      %% data that are of a CustomStorageClass.
      %%
      %if !ISEMPTY(class)
        %<LibCustomClass(class, "setup")>
      %endif
    %endforeach
  %endwith

%endfunction

%% Function LibDefaultCustomStorageDeclare ======================================
%% Abstract:
%%   Generate default data declaration for data with a custom storage
%%   class.  The declaration takes the form of a standalone global
%%   variable, e.g.
%%
%%                      real32_T x;
%%                      uint8_T  y[3];
%%
%function LibDefaultCustomStorageDeclare(record)
  %assign id = LibGetRecordIdentifier(record)
  %assign dt = LibGetRecordCompositeDataTypeName(record)
  %assign width = LibGetDataWidth(record)
  %if width == 1
    %assign dims = ""
  %else
    %assign dims = "[%<width>]"
  %endif
  %return "%<dt> %<id>%<dims>;"
%endfunction

%% Function LibDefaultCustomStorageInitialize ===================================
%% Abstract:
%%   Generate default data initialization for external I/O and states.  The 
%%   initialization is to the value of ground for the datatype, e.g.
%%
%%                      x = 0.0;
%%                      y[1] = 0;
%%                      y[2] = 0;
%%                      y[3] = 0;
%%
%function LibDefaultCustomStorageInitialize(record, idxInfo, reim)
  %if record.RecordType == "ModelParameter"
    %return ""
  %else
    %assign gndValue = LibGetGroundValue(record, tRealPart)
    %return ...
      "%<LibDefaultCustomStorageContents(record, idxInfo, reim)> = " + ...
      "%<gndValue>;"
  %endif
%endfunction

%% Function LibDefaultCustomStorageDefine =======================================
%% Abstract:
%%   Generate default data definition for data with a custom storage
%%   class.  If the data is a parameter, the definition includes its
%%   initialization to its nominal value.   The definition takes the 
%%   form of a standalone global variable, e.g.
%%
%%                      real32_T x;
%%                      uint8_T  p[3] = {4, 27, 92};
%%                      uint8_T  y[3];
%%
%function LibDefaultCustomStorageDefine(record)
  %assign id = LibGetRecordIdentifier(record)
  %assign dt = LibGetRecordCompositeDataTypeName(record)
  %assign width = LibGetDataWidth(record)
  %if width == 1
    %assign dims = ""
  %else
    %assign dims = "[%<width>]"
  %endif
  %if record.RecordType == "ModelParameter"
    %openfile initStr
     %<dt> %<id>%<dims> = %<LibParameterInstanceInitStr(record)>;
    %closefile initStr
    %return initStr
  %else
    %return "%<dt> %<id>%<dims>;"
  %endif
%endfunction

%% Function LibDefaultCustomStorageContents =====================================
%% Abstract:
%%   Generate default data access for data with a custom storage
%%   class.  The definition takes the form of a standalone global 
%%   variable, e.g.
%%
%%                      x
%%                      y[2]
%%
%function LibDefaultCustomStorageContents(record, idxInfo, reim)
  %assign cscDefn = SLibGetCSCDefForData(record)
  %assign msDefn  = SLibGetMemorySectionDefForData(record)
  %if SLibIsAuxBufferForReusableCSC(record) && ...
    !ISFIELD(record, "IsAtRootInputOrOutput")
    %assign id = record.ReuseBufferName
  %else
    %assign id = LibGetRecordIdentifier(record)
  %endif
  %assign scalar  = ((LibGetDataWidth(record) == 1) && !LibRecordHasSymbolicWidth(record))
  %assign pointer = (SLibGetDataAccess(cscDefn, record) == "Pointer")
  
  %if SLibIsContainerCGTypeND(record)
    %% Insert an nD reference to the first element if a flat index is
    %% used on an nD variable; g1738124.
    %if !ISEMPTY(idxInfo) && !LibIsNdIndex(idxInfo)
      %assign recDims = LibGetRecordDimensions(record)
      %assign id = LibGetAddressOfFirstElement(id, recDims)
    %endif
  %endif

  %if (scalar && pointer)
    %% Scalar data with pointer access
    %assign rtn = "(*%<id>)%<idxInfo>%<reim>"
  %else
    %% Two cases:
    %% 1. Direct access
    %% 2. Non-scalar data with pointer access
    %assign rtn = "%<id>%<idxInfo>%<reim>"
  %endif
  
  %return rtn
%endfunction

%% Function LibDefaultCustomStorageSet =====================================
%% Abstract:
%%   Generate default data access for data with a custom storage
%%   class.  The definition takes the form of a standalone global 
%%   variable, e.g.
%%
%%                      x = u;
%%                      y[2] = u;
%%
%function LibDefaultCustomStorageSet(record, idxInfo, reim, value)
  %return "%<LibDefaultCustomStorageContents(record, idxInfo, reim)> = %<value>;\n"
%endfunction

%% Function LibDefaultCustomStorageAddress ======================================
%% Abstract:
%%   Generate default data address for data with a custom storage
%%   class.  The definition takes the form of a standalone global 
%%   variable, e.g.
%%
%%                      &(x)
%%                      y[2]
%%
%function LibDefaultCustomStorageAddress(record, idxInfo, reim)
  %assign msDefn    = SLibGetMemorySectionDefForData(record)
  %assign dtypeId   = LibGetRecordDataTypeId(record)
  %assign cmplx     = LibGetRecordIsComplex(record)
  %assign cast      = LibGetNonVolatileCmplxPointerCast(msDefn, dtypeId, cmplx, idxInfo)
  
  %return "%<cast>&%<LibDefaultCustomStorageContents(record, idxInfo, reim)>"
%endfunction

%% Function LibDefaultCustomStorageLayout =======================================
%% Abstract:
%%   For a given record, return a vector containing information about
%%   the layout of that data; see LibGetDataLayout() for more information.
%%
%function LibDefaultCustomStorageLayout(record)
  %return LibGetDataLayout(record)
%endfunction

%% Function LibDefaultCustomStorageDataDeclComment ==============================
%% Abstract:
%%   For a given data record, return a comment to be inserted before / at the end
%%   of / after declarations of that data.
%%
%function LibDefaultCustomStorageDataDeclComment(record)
  %return ["", "", ""]
%endfunction

%% Function LibDefaultCustomStorageDataDefnComment ==============================
%% Abstract:
%%   For a given data record, return a comment to be inserted before / at the end
%%   of / after definition of that data.
%%
%function LibDefaultCustomStorageDataDefnComment(record)
  %return ["", "", ""]
%endfunction

%% Function LibDefaultCustomStorageComment ======================================
%% Abstract:
%%   For a given class record, return a comment to be generally inserted before
%%   the data of that class
%%
%function LibDefaultCustomStorageComment(record)
  %return "/* Data with custom storage class %<record.Name> */"
%endfunction

%% Function LibDefaultCustomStorageTypeComment ==================================
%% Abstract:
%%   For a given class record, return a comment to be inserted before
%%   type definition (if there is) of the data of that class
%%
%function LibDefaultCustomStorageTypeComment(record)
  %return "/* Type definition of data with custom storage class %<record.Name> */"
%endfunction

%% Function LibDefaultCustomStorageDeclComment ==================================
%% Abstract:
%%   For a given class record, return a comment to be inserted before
%%   declaration of the data of that class
%%
%function LibDefaultCustomStorageDeclComment(record)
  %return "/* Declaration of data with custom storage class %<record.Name> */"
%endfunction

%% Function LibDefaultCustomStorageDefnComment ==================================
%% Abstract:
%%   For a given class record, return a comment to be inserted before
%%   definition of the data of that class
%%
%function LibDefaultCustomStorageDefnComment(record)
  %return "/* Definition of data with custom storage class %<record.Name> */"
%endfunction

%% Function LibDefaultCustomStorageUnknownDataAccessType ========================
%% Abstract:
%%   Handle the case where an unknown access type is used when calling DataAccess
%%
%function LibDefaultCustomStorageUnknownDataAccessType ...
  (record, type, idxInfo, reim) void
  
  %switch type
    %case "layout"
      %% Assume worst case if not defined
      %return ["other"]
      %%break

    %case "qualifier"
      %% Return the default type qualifier if not defined
      %return ""
      %%break

    %case "declComment"
    %case "defnComment"
      %% Return empty strings for comments to place
      %% before / on same line / after code.
      %return ["", "", ""]
      %%break
      
    %% These are critical and must be defined
    %case "initialize"
    %case "contents"
    %case "address"
    %case "declare"
    %case "define"
    %% Unknown access type
    %default
      %assign rtwInfoPkg = LibGetRTWInfoObjectPackage(record)
      %assign cscName = LibGetCustomStorageClassName(record)
      %assign varName = LibGetRecordVarName(record)
      %assign errTxt = "The access type '%<type>' is not defined for " + ...
	"custom storage class '%<cscName>' used by data item " + ...
	"'%<varName>' of package '%<rtwInfoPkg>'"
      %<LibReportFatalError(errTxt)>
      %break

  %endswitch
%endfunction

%% Function LibDefaultCustomStorageUnknownClassAccessType =======================
%% Abstract:
%%   Handle the case where an unknown access type is used when calling
%%   ClassAccess
%%
%function LibDefaultCustomStorageUnknownClassAccessType(record, type) void

  %switch type

    %% For backward compatibility, the following will fall back to "comment"
    %case "typeComment"
    %case "declComment"
    %case "defnComment"
      %assign genType = SLibGetGenerateTypeForCSC(record)

      %return GENERATE_TYPE(record, "ClassAccess", genType, "comment")
      %%break

    %case "comment"
      %% Just return a null if not defined
      %return [""]
      %%break

    %% These are critical and must be defined
    %case "setup"
    %% Unknown access type
    %default
      %assign rtwInfoPkg = record.Package
      %assign cscName = record.Name
      %assign errTxt = "The access type '%<type>' is not defined for " + ...
	"custom storage class '%<cscName>' used by data of " + ...
        "package '%<rtwInfoPkg>'"
      %<LibReportFatalError(errTxt)>
      %break

  %endswitch
%endfunction

%% Function LibCustomStorageClassRecordNumData ==================================
%% Abstract: 
%%   in the ClassAccess method, return the number of data subrecords in the 
%%   class record
%%
%function LibCustomStorageClassRecordNumData(record) void
  %return record.NumData
%endfunction


%% Function LibConvertNameToIdentifier ==========================================
%% Abstract:
%%   convert filename to legal C identifier
%%
%function LibConvertNameToIdentifier(s) void
  %assign str = "char(bitor(bitand('%<s>'>='0','%<s>'<='9')," + ...
    "bitor(bitand('%<s>'>='a','%<s>'<='z'),bitand('%<s>'>='A'," + ...
    "'%<s>'<='Z'))).*'%<s>' + ~bitor(bitand('%<s>'>='0','%<s>'<='9')" + ...
    ",bitor(bitand('%<s>'>='a','%<s>'<='z'),bitand('%<s>'>='A'," + ...
    "'%<s>'<='Z'))).*'_')"
  %return "_INCLUDED_" + FEVAL("eval", str) + "_"
%endfunction

%% Function SLibCustomStorageStructTemplateDataAccess ===========================
%% Abstract:
%%   Define DataAccess() template function for arbitrary flat data structures.
%%
%function SLibCustomStorageStructTemplateDataAccess(record, request, ...
  idx, reim, structInstanceName)

  %switch request

    %% The "initialize" request is used by the model registration 
    %% function to zero internal or external data.  
    %case "initialize"
      %assign props = LibGetCustomStorageAttributes(record)
      %assign gnd = LibGetGroundValue(record, tRealPart)
      %return "%<structInstanceName>.%<props.FieldName> = %<gnd>;"

    %% The "contents" request is used to generate code corresponding
    %% to the usage of data on the left-hand or right-hand side of
    %% an assignment.  
    %case "contents"
      %assign props = LibGetCustomStorageAttributes(record)
      %return "%<structInstanceName>.%<props.FieldName>"
      
    %% The "address" request is used to generate code corresponding
    %% to the address of data.  
    %case "address"
      %assign props = LibGetCustomStorageAttributes(record)
      %return "&(%<structInstanceName>.%<props.FieldName>)"
      
    %% Since the data is embedded as fields in a composite, we will
    %% not declare or define it individually using the "declare"
    %% and "define" requests
    %case "declare"
    %case "define"
      %return ""

    %% The "layout" request is used to define the way data is mapped to
    %% memory. In this case, the data is simply scalar elements
    %% (embedded in a structure) so we can use the default layout.
    %case "layout"
      %return LibDefaultCustomStorageLayout(record)
      %%break

    %% Handle unrecognized requests
    %default
      
      %% You should invoke LibDefaultCustomStorageUnknownDataAccessType
      %% for unrecognized requests.  It gracefully errs out for unknown
      %% or known, critical requests not handled above, but supplies 
      %% safe defaults for known, noncritical requests not handled above.
      %return LibDefaultCustomStorageUnknownDataAccessType ...
	(record, request, idx, reim)
      %%break
      
  %endswitch
  
%endfunction


%% Function SLibCustomStorageStructTemplateClassAccess ===================
%% Abstract:
%%   define ClassAccess() function for the Struct template
%%
%% NOTE: This function is obsolete.
%%
%function SLibCustomStorageStructTemplateClassAccess(record, request, ...
  structTypeName, structInstanceName, structFieldNames, ...
  booleanBitField)

  %if structTypeName == ""
    %<LibReportFatalError("Undefined structure type name")>
  %endif
  %if structInstanceName == ""
    %<LibReportFatalError("Undefined structure instance name")>
  %endif
  %if structFieldNames == []
    %<LibReportFatalError("Undefined structure field names")>
  %endif
    
  %switch request

    %% The "setup" request performs class-wide operations prior to
    %% code generation.
    %case "setup"

      %% Do some error checking: for each object in this class, 
      %% * make sure it is a scalar, noncomplex
      %% * make sure it is the only object referencing a particular field
      %% * make sure it uses a valid fieldname
      %%
      %% Also, establish data type for each field and initial value for
      %% each field.
      %createrecord fieldProps {}
      %assign numFields = SIZE(structFieldNames)[1]
      %foreach idx = numFields
        %if booleanBitField
  	  %addtorecord fieldProps %<structFieldNames[idx]> ...
           { Used 0;\
             CDataType "unsigned int";\
             InitValue "false" \
	   }
	 %else
  	  %addtorecord fieldProps %<structFieldNames[idx]> ...
           { Used 0;\
             CDataType "real_T";\
             InitValue "0.0" \
	   }
	 %endif
      %endforeach
      %assign numData = LibCustomStorageClassRecordNumData(record)

      %foreach idx = numData
	%% Get the idx'th data record with BitField storage
	%assign item  = LibGetDataRecord(record, idx)

	%% Make sure the data is scalar and noncomplex
	%<LibCustomStorageVerifyRecordIsScalar(item)>
	%<LibCustomStorageVerifyRecordIsNonComplex(item)>

	%% If this is a boolean bitfield, make sure the datatype is boolean
	%if booleanBitField && ...
	  LibGetDataTypeIdAliasedThruToFromId(LibGetRecordDataTypeId(item)) != tSS_BOOLEAN
	  %assign errTxt = "Bitfields are only supported for boolean data"
	  %<LibReportError(errTxt)>
	%endif
	
	%% Make sure the object's fieldname is OK with what the TLC
	%% says the legal fieldnames are, and that no two objects utilize
	%% the same field.
	%assign varName  = LibGetRecordVarName(item)
        %assign props = LibGetCustomStorageAttributes(item)
	%assign fieldName = props.FieldName
        %if !ISFIELD(fieldProps, fieldName)
	  %assign errTxt = "The field name '%<fieldName>' of object '%<varName>' " +...
	    "is not defined as a legal field name by the custom storage " +...
	    "TLC file defining the '%<structTypeName>' type"
	  %<LibReportError(errTxt)>
	%endif
        %assign field = GETFIELD(fieldProps, fieldName)
	%if field.Used != 0
	  %assign errTxt = "The object field '%<fieldName>' " +...
	    "is used by multiple objects"
	  %<LibReportError(errTxt)>
	%else
	  %assign field.Used = field.Used + 1
	%endif
	
	%% Cache away the C data type, and the initial value of the field.
	%assign field.CDataType = LibGetRecordCompositeDataTypeName(item)
	%if LibCustomStorageRecordIsModelParameter(item)
	  %assign field.InitValue = LibParameterInstanceInitStr(item)
	%else
	  %assign field.InitValue = LibGetGroundValue(item, tRealPart)
	%endif
      %endforeach  	  

      %% Build up the type definition
      %openfile structTypeBuf
      /* %<structTypeName> data type */
      typedef struct {
	%foreach idx = numFields
	  %assign fieldName = structFieldNames[idx]
          %assign field = GETFIELD(fieldProps, fieldName)
          %if booleanBitField
	    unsigned int %<fieldName>:1;
	  %else
	    %<field.CDataType> %<fieldName>;
	  %endif
	%endforeach
      } %<structTypeName>;
      %closefile structTypeBuf
      
      %% Build up the structure initializer
      %openfile structInitBuf
      {\
	%foreach idx = numFields
	  %assign fieldName = structFieldNames[idx]
          %assign field = GETFIELD(fieldProps, fieldName)
	  %if idx > 0
	    , \
	  %endif
	  %<field.InitValue>\
	%endforeach
      } \
      %closefile structInitBuf
      
      %% Cache the structure type definition and instance definition
      %<LibHeaderFileCustomCode(structTypeBuf,"trailer")>
      %<LibPrmFileCustomCode(...
	"%<structTypeName> %<structInstanceName>" + ...
	" = %<structInitBuf>;\n","trailer")>
      %return ""
      %%break

    %case "comment"
      %% No individual data declarations or definitions.
      %return ""
      %%break

    %case "groupTypeDeclDefn"
      %return ["", "", ""]
      %%break

    %% Handle unrecognized requests
    %default
      
      %return LibDefaultCustomStorageUnknownClassAccessType ...
	(record, request)
      %%break
      
  %endswitch
      
%endfunction

%% Function: LibBlockAssignOutputSignal ========================================
%% Abstract:
%%  Assign a block's output to a specified right-hand-side value
%%
%function LibBlockAssignOutputSignal(portIdx, ucv, lcv, sigIdx, rhs) void
  %assign op = FcnGetOutputPortRecord(portIdx)
  %assign sigRec = SLibGetSourceRecord(op, 0)
  %if (ISFIELD(sigRec, "StorageClass") && ...
       sigRec.StorageClass == "Custom" && ...
       sigRec.CustomStorageClassVersion > 1)
    %assign tmpVect = SLibGetReimAndIdx(sigIdx)
    %assign reim    = tmpVect[0]
    %assign sigIdx  = tmpVect[1]
    %% Index into memory in code may be different to signal index in Simulink
    %% (e.g., concatenation block combines memory for multiple inputs).
    %assign portObj  = FcnGetOutputPortRecord(portIdx)
    %assign sigRecAndMapInfo = SLibGetSourceRecordAndMapInfo(portObj, sigIdx, TLC_TRUE, TLC_FALSE)
    %assign sigOffset = sigRecAndMapInfo.signalOffset
    %assign sigIndexer = SLibGet1DArrayIndexer(LibGetRecordWidth(sigRec), ucv, lcv, sigOffset)
    %return LibAccessCustomData(sigRec, "set", sigIndexer, reim, rhs)
  %elseif sigRec.UseAccessFunctions && (sigRec.AccessMode == "Value")
    %assign tmpVect = SLibGetReimAndIdx(sigIdx)
    %assign reim    = tmpVect[0]
    %assign sigIdx  = tmpVect[1]
    %% Index into memory in code may be different to signal index in Simulink
    %% (e.g., concatenation block combines memory for multiple inputs).
    %assign portObj  = FcnGetOutputPortRecord(portIdx)
    %assign sigRecAndMapInfo = SLibGetSourceRecordAndMapInfo(portObj, sigIdx, TLC_TRUE, TLC_FALSE)
    %assign sigOffset = sigRecAndMapInfo.signalOffset
    %assign sigIndexer = SLibGet1DArrayIndexer(LibGetRecordWidth(sigRec), ucv, lcv, sigOffset)
    %return FcnSetAccessFunctionSignalReference(sigRec, sigIndexer, rhs)
  %else
    %return "%<LibBlockOutputSignal(portIdx, ucv, lcv, sigIdx)> = %<rhs>;\n"
  %endif
%endfunction


%% Function: LibBlockAssignDWork ===============================================
%% Abstract:
%%  Assign a block's dwork to a specified right-hand-side value
%%
%function LibBlockAssignDWork(dwork, ucv, lcv, sigIdx, rhs) void
  %assign dworkAndRec = FcnGetDworkAndRec(dwork)
  %assign dworkRec = dworkAndRec.DWorkRec

  %if dworkRec.StorageClass == "Custom" && ...
    dworkRec.CustomStorageClassVersion > 1
    %assign tmpVect = SLibGetReimAndIdx(sigIdx)
    %assign reim    = tmpVect[0]
    %assign sigIdx  = tmpVect[1]
    %assign sigIndexer = SLibGet1DArrayIndexer(SLibDWorkWidth(dworkRec), ucv, lcv, sigIdx)
    %return LibAccessCustomData(dworkRec, "set", sigIndexer, reim, rhs)
  %else
    %return "%<LibBlockDWork(dwork, ucv, lcv, sigIdx)> = %<rhs>;\n"
  %endif
%endfunction

%% Function: SLibAssignCustomData ===============================================
%% Abstract:
%%  Assign data to a specified right-hand-side value
%%
%function SLibAssignCustomData(data, idx, reim, rhs) void
  %assert data.StorageClass == "Custom"
  %if data.StorageClass == "Custom" && ...
    data.CustomStorageClassVersion > 1
    %return LibAccessCustomData(data, "set", idx, reim, rhs)
  %else
    %return "%<LibAccessCustomData(data, "contents", idx, reim, "")> = %<rhs>;\n"
  %endif
%endfunction

%% Function: VerifyCustomStorageCompliance =====================================
%% Abstract:
%%  Verify a block's dworks and outputs of with custom storage class
%%  are not a version higher than that which the block is compliant to
%%
%function VerifyCustomStorageCompliance() void
  %foreach sysIdx = NumSystems
    %assign system = System[sysIdx]
    %with system
    %foreach blkIdx = NumBlocks+NumVirtualOutportBlocks
      %assign block = Block[blkIdx]
      %%
      %% The opaque block might include ports of block, which aren't CS2 
      %% compliant. The error will be reported by those blocks. The auto-
      %% generated TLC code for the opaque block is always CS2 compliant.
      %%
      %if block.Type == "Opaque"
        %continue
      %endif
      %with block
      %if NumDWork > 0
	%foreach idx = NumDWork
	  %assign dwork = DWork[idx]
	  %assign dworkAndRec = FcnGetDworkAndRec(dwork)
	  %assign dworkRec = dworkAndRec.DWorkRec
	  %if dworkRec.StorageClass == "Custom" && ...
	    dworkRec.CustomStorageClassVersion > CustomStorageClassCompliant
	    %assign errTxt = ...
	      "DWork %<LibGetRecordVarName(dworkRec)> " + ...
	      "uses custom storage class, level " + ...
	      "%<dworkRec.CustomStorageClassVersion> but the compliance " + ...
	      "level of this block is only " + ...
	      "%<CustomStorageClassCompliant>; use a different block or " + ...
	      "a different custom storage class, level " + ...
	      "%<CustomStorageClassCompliant> or lower"
	    %<LibBlockReportError(block, errTxt)>
          %elseif ISFIELD(dworkRec, "UseAccessFunctions") && dworkRec.UseAccessFunctions && ...
            ISFIELD(dworkRec, "AccessMode") && (dworkRec.AccessMode == "Value") && ...
            CustomStorageClassCompliant < 2
              %assign errTxt = ...
                "DWork %<LibGetRecordVarName(dworkRec)> " + ...
                "uses an access method with mode 'ByValue', " + ...
                "but the custom storage class compliance " + ...
                "level of this block is only " + ...
                "%<CustomStorageClassCompliant>; use a different block or " + ...
                "an access method with mode 'ByPointer'."
              %<LibBlockReportError(block, errTxt)>
	  %endif
	%endforeach
      %endif	
      %if NumDataOutputPorts > 0
	%foreach idx = NumDataOutputPorts
	  %assign op = FcnGetOutputPortRecord(idx)
	  %assign sigSrc = IDNUM(op.SignalSrc[0])[0]
	  %if (sigSrc == "E") || (sigSrc == "Y")
	    %assign sigRec = SLibGetSourceRecord(op, 0)
	    %if sigRec.StorageClass == "Custom" && ...
	      sigRec.CustomStorageClassVersion > CustomStorageClassCompliant
              %assign errTxt = ...
                "Block output %<LibGetRecordVarName(sigRec)> " + ...
                "uses custom storage class, level " + ...
                "%<sigRec.CustomStorageClassVersion> but the compliance " + ...
                "level of this block is only " + ...
                "%<CustomStorageClassCompliant>; use a different block or " + ...
                "a different custom storage class, level " + ...
                "%<CustomStorageClassCompliant> or lower"
              %<LibBlockReportError(block, errTxt)>
            %elseif ISFIELD(sigRec, "UseAccessFunctions") && sigRec.UseAccessFunctions && ...
              ISFIELD(sigRec, "AccessMode") && (sigRec.AccessMode == "Value") && ...
              CustomStorageClassCompliant < 2
              %assign errTxt = ...
                "Block output %<LibGetRecordVarName(sigRec)> " + ...
                "uses an access method with mode 'ByValue', " + ...
                "but the custom storage class compliance " + ...
                "level of this block is only " + ...
                "%<CustomStorageClassCompliant>; use a different block or " + ...
                "an access method with mode 'ByPointer'."
              %<LibBlockReportError(block, errTxt)>
            %endif
	  %endif
	%endforeach
      %endif	
      %endwith
    %endforeach
  %endwith
  %endforeach
%endfunction

%% Function: FcnSanitizeUserString ==========================================
%%
%function FcnSanitizeUserString(userString) void
  %if ISEMPTY(userString)
    %return ""
  %elseif WHITE_SPACE(userString)
    %return ""
  %endif
  %return userString
%endfunction


%%=============================================================================
%function FcnGetTLCFilePackageAndName(rtwInfoPkg, cscName) void
  %assign filePkg = ""
  %assign fileName = ""

  %assign cscDefn = SLibGetCSCDefForName(rtwInfoPkg, cscName)
  %if cscDefn.CSCType != "Other"
    %% ie. Unstructured, FlatStructure or AccessFunction
    %assign filePkg = "Simulink"
    
  %else
    %% MSPackage controls actual path of TLCFileName. Not RTWInfo package.
    %assign filePkg = cscDefn.MSPackage
  %endif
  
  %assign fileName = cscDefn.TLCFileName

  %if ISEMPTY(fileName)
    %assign fileName = cscName + ".tlc"
  %endif

  %return ["%<filePkg>", "%<fileName>"]
  
%endfunction  %% of FcnGetTLCFilePackageAndName()


%%=============================================================================
%function SLibGetGenerateTypeForName(rtwInfoPkg, cscName) void
  %assign filePkgAndName = FcnGetTLCFilePackageAndName(rtwInfoPkg, cscName)

  %assign genType = filePkgAndName[0] + "::" + filePkgAndName[1]
  
  %return genType
%endfunction


%%=============================================================================
%function SLibGetGenerateTypeForCSC(record) void
  %assign rtwInfoPkg = record.Package
    %% RTWInfo package. May not be same as cscDefn.OwnerPackage.

  %assign cscName = record.Name

  %return SLibGetGenerateTypeForName(rtwInfoPkg, cscName)
%endfunction

%%=============================================================================
%% Abstract:
%%   Return the GenerateType attribute of the record. The GenerateType attribute
%%   is a function of the CSCName and PackageName of the record. 
%%   The GenerateType attribute is added to the record at TLC setup stage. See
%%   FcnAddCustomData in globalmaplib.tlc
%function SLibGetGenerateTypeForData(record) void
  
  %return record.GenerateType

%endfunction



%% Function: LibGetSLDataObjectInfo ================================================
%% Abstract:
%%   Return the requested property value of the Simulink data object associated 
%%   with a data record
%function LibGetSLDataObjectInfo(record, property) void
 
  %if !ISFIELD(record, "Object") || !ISFIELD(record.Object, "ObjectProperties")
      %assign errTxt = "Invalid record for requesting data object property"
      %<LibReportFatalError(errTxt)>
  %endif   

  %assign baseProps = record.Object.ObjectProperties
  %assign RTWInfoProps = LibGetRTWInfoObjectProperties(record)
  %assign cusAttriProps = LibGetCustomStorageAttributes(record)
  %if ISEQUAL(property,"Class")
      %assign propValue = record.Object.Class
      %return propValue
  %elseif ISEQUAL(property,"DataType")
      %assign propValue = DataTypes.DataType[LibGetRecordDataTypeId(record)].DTName
      %return  propValue
  %else 
      %if ISFIELD(baseProps, property)
        %assign propValue = GETFIELD(baseProps, property)
        %return  propValue
      %elseif ISFIELD(RTWInfoProps, property)
        %assign propValue = GETFIELD(RTWInfoProps, property)
        %return  propValue
      %elseif ISFIELD(cusAttriProps, property)
        %assign propValue = GETFIELD(cusAttriProps, property)
        %return  propValue
      %else
        %assign errTxt = "Invalid property %<property>"
        %<LibReportFatalError(errTxt)>
      %endif 
  %endif

%endfunction

%endif %% _CUSTOMSTORAGELIB_

%% Function: FcnGetTLCPathFromPackageName ================================================
%% Abstract:
%%   Returns path of tlc code for custom storage classes.

%function FcnGetTLCPathFromPackageName(filePkg, toTLCName) void
  
  %assign tmpstr = "fileparts(which('%<filePkg>.csc_registration'))" 
  %% Need to use FEVAL("eval" since which('pkg.class') needs to be
  %% evaluated before evaluating file parts
  %assign filePkgPath = FEVAL("eval", tmpstr)

  %return "%<filePkgPath>/tlc/%<toTLCName>"
  
%endfunction

%% Function: SLibIsIntegerDataTypeNotSizeofTargetInt ==========================================
%% Abstract:
%%   IntegerSizeMismatch provides an API for checking whether the size of 
%%   an integer specified via model matches with the integer size of target platform
%%
%% NOTE:
%%   Reference function SLibGetFormattedValueFromId for its handling type casting on numeric value
%function SLibIsIntegerDataTypeNotSizeofTargetInt(id)

  %assign dTypeId = LibGetDataTypeIdAliasedThruToFromId(id)
  %assign dTypeStorageId = LibGetDataTypeStorageIdFromId(dTypeId)
  %switch dTypeStorageId
     %case tSS_UINT8
     %case tSS_UINT16
     %case tSS_UINT32
     %case tSS_INT8
     %case tSS_INT16
     %case tSS_INT32
        %% function LibGetDataTypeSLSizeFromId() does not return real size of data type
        %% specified by model (e.g. target supports 24-bit short, datatye is fixdt(0,22,1,0))
        %if DataTypes.DataType[dTypeId].ActualBits != IntegerSizes.IntNumBits
            %return TLC_TRUE
        %endif
        %break
     %default
        %break
  %endswitch
  %return TLC_FALSE
%endfunction

%% Function: LibDoesStringContainDot ===========================================
%function LibDoesStringContainDot(inputStr) void
  %assign result = TLC_FALSE
  %assign len = SIZE(inputStr,1)
  %foreach idx = len
    %if inputStr[idx] == "."
      %assign result = TLC_TRUE
      %break
    %endif
  %endforeach
  
  %return result
%endfunction

%% Function: LibDoesStringContainDot ===========================================
%function LibDoesStringContainDotOrArrow(inputStr) void
  %assign result = TLC_FALSE
  %assign len = SIZE(inputStr,1)
  %foreach idx = len
    %if inputStr[idx] == "."
      %assign result = TLC_TRUE
      %break
    %endif
    %if inputStr[idx] == "-" && ...
      (idx + 1 <= len) && ...
      inputStr[idx+1] == ">"
      %assign result = TLC_TRUE
      %break
    %endif
  %endforeach
  %return result
%endfunction

%% Function: FcnGetElementDataTypeFromIndexInfo ===========================
%% Abstract: Gets the data type of a structure field with the given index
%% information. Returns both the data type ID and the structure field index
%% as a two element array: [dataTypeId, fieldIndex]
%function FcnGetElementDataTypeFromIndexInfo(structTypeId, indexInfo) void
  %assert (LibIsStructDataType(structTypeId))
  %assign retVal = ""
  %foreach idx = LibDataTypeNumElements(structTypeId)
    %assign eName = LibDataTypeElementName(structTypeId, idx)
    %assign translatedEName = FEVAL("regexptranslate", "escape", eName)
    %assign pat = "^\\[\\d+\\]\\.%<translatedEName>\\." + "|"
    %assign pat = pat + "^\\.%<translatedEName>\\." + "|"
    %assign pat = pat + "^\\[\\d+\\]\\.%<translatedEName>(\\[(\\/\\*.*\\*\\/)?\\d+\\])+" + "|" 
    %assign pat = pat + "^\\.%<translatedEName>(\\[(\\/\\*.*\\*\\/)?\\d+\\])+" + "|"
    %assign pat = pat + "^\\.%<translatedEName>$" 
    %assign resultingIndexInfo = FEVAL("regexprep", indexInfo, pat, "")
    %if !ISEQUAL(resultingIndexInfo, indexInfo)
      %assign eId = LibDataTypeElementDataTypeId(structTypeId, idx)
      %if ISEMPTY(resultingIndexInfo)
        %assign retVal = [%<eId>, %<idx>]
      %else
        %if resultingIndexInfo[0] != "."
          %assign resultingIndexInfo = ".%<resultingIndexInfo>"
        %endif
        %assert (LibIsStructDataType((eId)))
        %assign retVal = FcnGetElementDataTypeFromIndexInfo(eId, resultingIndexInfo)
      %endif
      %return retVal
    %endif
  %endforeach
  %assert (!ISEMPTY(retVal))
%endfunction

%% Function: FcnIsStructFieldComplex ======================================
%% Abstract:
%%   Return true if the field of the given structure type is complex.
%function FcnIsStructFieldComplex(structTypeId, fieldIdx) void
  %if LibIsStructDataType(structTypeId)
    %assign structTypeObj = ::CompiledModel.DataTypes.DataType[structTypeId].Object
    %assign fieldObj = structTypeObj.ObjectProperties.Elements_internal[fieldIdx].Object
    %return fieldObj.ObjectProperties.Complexity == "complex"
  %endif
  %return TLC_FALSE
%endfunction

%% Function: FcnNonVolatilePointerCast ======================================
%% Abstract:
%%   Return the code necessary to cast away the volatility of a pointer to the
%%   given datatype. If the provided memory section definition does not specify
%%   volatile then return the empty string.
%function FcnNonVolatilePointerCast(msDefn, dtypeId, cmplx, indexInfo) void

  %assign cast = ""
     
  %if msDefn.IsVolatile

    %assign constCast = ""
    %if msDefn.IsConst
      %assign constCast = "const "
    %endif
    
    %% If indexInfo contains a dot, virtual bus selection is involved
    %if LibIsStructDataType(dtypeId) && LibDoesStringContainDot(indexInfo)
      %assign retFieldInfo = FcnGetElementDataTypeFromIndexInfo(dtypeId, indexInfo)
      %assign eId = retFieldInfo[0]
      %if !ISEMPTY(eId)
        %assign fieldIdx = retFieldInfo[1]
        %assign cmplx = FcnIsStructFieldComplex(dtypeId, fieldIdx)
        %assign dtypeId = eId
      %endif
    %endif

    %if cmplx
      %assign dtypeName = LibGetDataTypeComplexNameFromId(dtypeId)
    %else
      %assign dtypeName = LibGetDataTypeNameFromId(dtypeId)
    %endif

    %assign cast = "(%<constCast>%<dtypeName> *)"
  %endif  
   
  %return cast
%endfunction

%% Function: LibGetNonVolatilePointerCast ======================================
%% Abstract:
%%   Return the code necessary to cast away the volatility of a pointer to the
%%   given real datatype. If the provided memory section definition does not specify
%%   volatile then return the empty string.
%function LibGetNonVolatilePointerCast(msDefn, dtypeId, indexInfo) void

  %return FcnNonVolatilePointerCast(msDefn, dtypeId, TLC_FALSE, indexInfo)
  
%endfunction

%% Function: LibGetNonVolatileCmplxPointerCast =================================
%% Abstract:
%%   Return the code necessary to cast away the volatility of a pointer to the
%%   given potentially complex datatype. If the provided memory section definition 
%%   does not specify volatile then return the empty string.
%function LibGetNonVolatileCmplxPointerCast(msDefn, dtypeId, cmplx, indexInfo) void

  %return FcnNonVolatilePointerCast(msDefn, dtypeId, cmplx, indexInfo)
  
%endfunction

%% Function: SLibGetSymbolNameForExternalInput =================================
%% Abstract:
%%   Return variable name given an External Input record for ertmain_expfcn
%function SLibGetSymbolNameForExternalInput(extInp) void
  %assert (extInp.RecordType=="ExternalInput")
  %assign varName = ""
  %if extInp.StorageClass == "Auto"

    %% If this External Input belongs to a coderDataGroup, then we need to 
    %% ensure that we return the correct structure reference. 
    %if(SLibDataRecordIsInCoderGroup(extInp))      
      %assign structName = SLibGetCoderDataGroupStructForRecord(extInp)
    %else
      %assign structName = LibGetExternalInputStruct()
    %endif

    %assign id = LibGetRecordIdentifier(extInp)

    %if (structName != "")
      %if (UQualifier == "->")
        %assign varName = "(&%<structName>)%<UQualifier>%<id>"         
      %else
        %assign varName = "%<structName>%<UQualifier>%<id>"
      %endif
    %else
      %assign varName = id
    %endif
  %elseif extInp.StorageClass == "Custom"          
    %assign varName = "%<LibCustomData(extInp,"contents","","")>"
  %else 
    %assert (extInp.StorageClass == "ExportedGlobal" || extInp.StorageClass == "ImportedExtern" ...
      || extInp.StorageClass == "ImportedExternPointer")
    %assign varName = LibGetRecordIdentifier(extInp)       
  %endif
  %return varName
%endfunction

%% Function: SLibGetSymbolNameForExternalOutput =================================
%% Abstract: 
%%   Return variable name, given an External Output record and it's outport 
%%   block
%function SLibGetSymbolNameForExternalOutput(extOut, outportBlk) void
  %assert (extOut.RecordType=="ExternalOutput")
  %assign varName = ""
  
  %assign id = LibGetRecordIdentifier(extOut)
  %if( id == "")
    %assign id = LibGetRecordIdentifier(outportBlk)
  %endif

  %% If this External Output belongs to a coderDataGroup, then we 
  %% need to ensure that we return the correct structure reference. 
  %if(SLibDataRecordIsInCoderGroup(extOut))    
    %assign structName = SLibGetCoderDataGroupStructForRecord(extOut)
  %elseif (extOut.StorageClass!="Auto")
    %assign structName = ""
    %assign CustomAtt = LibGetCustomStorageAttributes(extOut)
      %if !ISEMPTY(CustomAtt)
         %if ISFIELD(CustomAtt,"StructName")
	   %assign structName = CustomAtt.StructName
	 %endif
      %endif
  %else
    %assign structName = LibGetExternalOutputStruct()
  %endif
  
  %if (structName != "")
    %if (YQualifier == "->")
      %assign varName = "(&%<structName>)%<YQualifier>%<id>"
    %else
      %assign varName = "%<structName>%<YQualifier>%<id>"
    %endif
  %else
    %assign varName = id
  %endif
  
  %return varName
%endfunction


%% Function: SLibIsAuxBufferForReusableCSC ======================================
%% Abstract:
%%   Return if the record is an auxiliary buffer of a reusable CSC
%function SLibIsAuxBufferForReusableCSC(record) void
  %return (record.StorageClass == "Custom" && SLibGetIsReusable(record)) && ...
    ISFIELD(record, "ReuseBufferName") && ...
    record.ReuseBufferName != record.Identifier
%endfunction

%% Function: SLibHasReusableCSCWithoutReusableBuffer(record)
%% Abstract:
%%    Returns true iff a given record is reusable but does not need an auxiliary buffer.
%function SLibHasReusableCSCWithoutReusableBuffer(record) void
  %return (record.StorageClass == "Custom" && SLibGetIsReusable(record)) && ...
    !ISFIELD(record, "ReuseBufferName")
%endfunction

%% Function: SLibIsAuxBufferForReusableCSCOrAutoSar =============================
%% Abstract:
%%   Return if the record is an auxiliary buffer of a reusable CSC or an AutoSar
%%   buffer
%function SLibIsAuxBufferForReusableCSCOrAutoSar(record) void
  %return ((record.StorageClass == "Custom" && SLibGetIsReusable(record)) || ...
    ISFIELD(record, "AutosarPRPortVarIdx")) && ...
    ISFIELD(record, "ReuseBufferName") && ...
    record.ReuseBufferName != record.Identifier
%endfunction

%% [EOF] customstoragelib.tlc
