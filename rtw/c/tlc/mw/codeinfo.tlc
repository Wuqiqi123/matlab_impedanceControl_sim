%% ============================================================================
%% 
%%  
%% 
%%
%% Abstract: 
%%   This file creates the codeInfo MATLAB object and saves it in a MAT file.
%%   The process of creation here means emitting out an MATLAB file which 
%%   contains appropriate syntax to create codeInfo object.
%%
%% Copyright 2007-2018 The MathWorks, Inc.
%%

%if (EXISTS("_CIINFO_") == 0)
%assign _CIINFO_ = 1

%assign rightClickBuildFeature = FEVAL("slfeature", "RightClickBuild")

%include "%<::CompiledModel.Name>_codeIRInfo.tlc"
%include "codeinfolib.tlc"
%% reset state of codeinfolib.tlc which is also used by C API processing
%<SLibResetCodeInfoLib()>
%include "codeinfodatalib.tlc"
%include "codeinfofcnlib.tlc"
%include "codeinfomdlreflib.tlc"
%include "autosarsup.tlc"

%selectfile NULL_FILE
%realformat "CONCISE"

%% Name of the .m function which creates the codeInfo object and saves in .mat
%assign fcnName = "writeCodeInfoFcn"
%assign timingSubfcnName = "getIndexFromTimingInternalId"
%assign iDataSubfcnName = "getInternalDataByName"
%assign iDataSubfcnVariableName = "getInternalDataByVariableName"
%assign nameChkfcnName = "checkDataGraphicalNames"
%assign paramIndexFcnName = "getParamIndexFromGraphicalName"
%assign uniquifyDataInterfaces = "uniquifyDataAccess"

%selectfile NULL_FILE

%%with ::CompiledModel
%% Open file on disk and start writing to it
%openfile ModelCI = "%<fcnName>.m"
%assign comment = "% Autogenerated file: %<::CompiledModel.GeneratedOn>"
%<comment>
function %<fcnName>

%assign componentObj = "codeInfo"
%assign expInportsObj = "expInports"

%assign comment = "% Load a ComponentInterface object from IR"
%<comment>
%<FcnLoadCodeIRInfo()>

%if SLibAutosarActive()
  %assign map = FcnGetAutosarDataMap()
  %<componentObj>.Name          = '%<map.ComponentName>';
  %if SLibAutosarIsAR4()
    %<SLibCreateStaticMemory()>    
    %<SLibAddAutosarVarInfo()>    
  %endif
%endif
%%

%% create a data interface writer to code descriptor
%assign buildDir = FEVAL("rtwprivate", "rtwattic", "getBuildDir")
wr = coder.internal.writeDataInterfacesToCodeDescriptor("%<::CompiledModel.Name>","%<buildDir>") ;

%% create a function interface writer to code descriptor
fr = coder.internal.writeFunctionInterfacesToCodeDescriptor("%<::CompiledModel.Name>", "%<buildDir>") ;

%<SLibCreateInportInterfaces()>
%%
%<SLibCreateOutportInterfaces()>
%%
skippedParameters = [];
%<SLibCreateParameterInterfaces()>
%assign prmArgs = SLibCreateParameterArguments()

%%
%<SLibCreateDataStoreInterfaces()>

%<SLibCreateExternalBlockOutputInterfaces()>
%<SLibCreateDWorkInterfaces()>

wr.closeRepo();

%%
%if !GenerateClassInterface
  %if !IsModelReferenceTarget()
    %% Create Initialize function interface
    %<SLibCreateModelFunctionInterface(componentObj, "Initialize", "")>
    %%
    %if UsingMalloc
      %% Create Allocation function interface
      %<SLibCreateModelFunctionInterface(componentObj, "Registration", "")>
    %endif
    %%
    %if LibIsDeploymentDiagram()
      %<SLibDeploymentGenerateCodeInfo(componentObj)>
    %elseif (ExportFunctionsMode != 0) || (SLibAutosarActive() && !(SLibIsExportFcnDiagram()) && SLibIsAsyncTaskOnlyModel())
      %if SLibAutosarActive()
        %if SLibIsAsyncTaskOnlyModel() && !(SLibIsExportFcnDiagram())
          %<SLibCreateModelFunctionInterface(componentObj, "OutputUpdate", "")>
        %endif
        %<SLibCreateRunnables(componentObj)>
      %else
        %<SLibCreateExportFunctions(componentObj)>
      %endif
    %elseif (SLibIsAsyncTaskOnlyModel() == TLC_FALSE || SLibIsExportFcnDiagram())
      %if (SLibIsExportFcnDiagram() && SLibAutosarActive())
        %<SLibCreateRunnables(componentObj)>
      %else
      %assign isAsyncExportFcn = SLibIsExportFcnDiagram() && SLibIsAsyncTaskOnlyModel()
      %assign isPeriodicExportFcn = SLibIsExportFcnDiagram() && !SLibIsAsyncTaskOnlyModel()
      %assign isPeriodicRateGrouping = SLibIsMultiRateAndPeriodicRateGrouping(System[NumSystems-1])
      %%
      %assign updateCState  = (NumContStates > 0)
      %if isPeriodicRateGrouping || isAsyncExportFcn %% Rate grouped
        %%    
        %% Create rate grouped function interfaces
        %assign maxSampleTime = NumRuntimeExportedRates
        %if SLibIsExportFcnDiagram()
          %assign maxSampleTime = NumSampleTimes
        %endif
        %foreach tid = maxSampleTime
          %assign tidIdx = tid
          %if SLibIsExportFcnDiagram()
            %% Loop over TIDs backwards for export function diagrams to match
            %% module generation order in opaquelib.tlc : FcnGenerateCodeFromModule
            %% Needed to keep fcn index consistent with OutputFunctions array
            %assign tidIdx = maxSampleTime - tid - 1
          %endif

          %if (tidIdx==1) && FixedStepOpts.TID01EQ
            %continue
          %endif
          %if SLibIsExportFcnDiagram() 
            %assign expFcnName = SLibGenExporFunctionName(tidIdx)
            %if WHITE_SPACE(expFcnName)
              %% Skip empty function names for export functions
              %continue
            %else
              %assign rootSystem = System[NumSystems-1]
              %assign thisModule = ::CompiledModel.RTWCGModules.RTWCGModule[rootSystem.CGIRModuleIdx]
              %if ISFIELD(thisModule, "SystemFunctions") && ...
                ISFIELD(thisModule.SystemFunctions, expFcnName)
                %assign fcnIndex = GETFIELD(thisModule.SystemFunctions, expFcnName)
                %assign thisFcn  = thisModule.Function[fcnIndex]
                %if ISFIELD(thisFcn,"IsRateGroupedSLFcn") && thisFcn.IsRateGroupedSLFcn == TLC_TRUE
                  %% Skip rate grouped Simulink functions. They are handled as model entry
                  %% point functions elsewhere. Without skipping here, we end up with duplicate
                  %% functions in PIL.
                  %continue
                %endif
              %endif
            %endif
          %endif
          %% Skip synchronous sample times for async export function
          %if isAsyncExportFcn && ...
            (tidIdx < NumRuntimeExportedRates)
            %continue
          %endif
          %assign tid = tidIdx
          %if !CombineOutputUpdateFcns && !SLibIsExportFcnDiagram() %% Export function is always treated as combined
            %assign outString = "Output"
            %if updateCState
              %assign updateString = "UpdateContStates"
            %else 
              %assign updateString = "RootUpdate"
            %endif
            %<SLibCreateModelFunctionInterface(componentObj, outString, tid)>
            %<SLibCreateModelFunctionInterface(componentObj, updateString, tid)>
          %else
            %if updateCState 
              %assign outString = "UpdateContStates"
            %else
              %assign outString = "OutputUpdate"
            %endif
            %<SLibCreateModelFunctionInterface(componentObj, outString, tid)>
          %endif
          %assign updateCState = TLC_FALSE 
        %endforeach
        %if !SLibIsExportFcnDiagram() && !SLibIsAsyncTaskOnlyModel() && !SLibAutosarActive()
          %foreach tid = NumSampleTimes
            %if SLibResetOrResetWithInitEventTID(tid)
              %<SLibCreateModelFunctionInterface(componentObj, "OutputUpdate", tid)>
            %endif
          %endforeach
        %endif
      %else  %% Non-rate grouped
        %%    
        %% Create non-rate grouped function interfaces
        %if !CombineOutputUpdateFcns
          %assign outString = "Output"
          %if updateCState
            %assign updateString = "UpdateContStates"
          %else 
            %assign updateString = "RootUpdate"
          %endif
          %<SLibCreateModelFunctionInterface(componentObj, outString, "")>
          %<SLibCreateModelFunctionInterface(componentObj, updateString, "")>
        %else
          %if updateCState 
            %assign outString = "UpdateContStates"
          %else
            %assign outString = "OutputUpdate"
          %endif
          %<SLibCreateModelFunctionInterface(componentObj, outString, "")>
        %endif
        %if !SLibAutosarActive()
          %% Add reset functions to list of output functions vector in 
          %% CodeInfo for the "Non-rate grouped" case. Note that in the 
          %% "Rate grouped" case all TID's are iterated over, which includes
          %% the reset functions.
          %foreach tid = NumSampleTimes
            %if SLibResetOrResetWithInitEventTID(tid)
              %<SLibCreateModelFunctionInterface(componentObj, "OutputUpdate", tid)>
            %endif
          %endforeach
        %endif
      %endif
      %endif
      %if !SLibAutosarActive()
        %if !SLibIsExportFcnDiagram() %% Export function's info should be handled in the rate grouping code
          %<AddFunctionCallInputInformation(componentObj)>
        %endif
         %<AddExternalInportMappingInfo(expInportsObj)>
      %else
        %if !SLibIsExportFcnDiagram() && (NumAsynchronousSampleTimes > 0)
          %<SLibCreateRunnables(componentObj)>
        %endif
      %endif
    %elseif SLibIsAsyncTaskOnlyModel()
      %<AddFunctionCallInputInformation(componentObj)>
      %<AddExternalInportMappingInfo(expInportsObj)>
      %% For these cases, the base rate step function is generated and we want
      %% to reflect that in CodeInfo.
      %if !GenerateSampleERTMain
        %<SLibCreateModelFunctionInterface(componentObj, "OutputUpdate", "")>
      %endif
    %else 
      %% Do nothing
    %endif
    
    %% derivative function
    %if EXISTS("IncludeMdlDerivativeFcn") && IncludeMdlDerivativeFcn == TLC_TRUE
      %<SLibCreateModelFunctionInterface(componentObj, "Derivative", "")>
    %endif
      
    %if IncludeMdlTerminateFcn
      %<SLibCreateModelFunctionInterface(componentObj, "Terminate", "")>
    %endif
  %else
    %<SLibCreateModelReferenceFunctionInterfaces(componentObj)>
    %<AddExternalInportMappingInfo(expInportsObj)>
  %endif
%else %% GenerateClassInterface
  %if (SLibIsAsyncTaskOnlyModel() && ...
    SLibIsERTTarget() && ...
    !IsModelReferenceRTWTarget())
    %% step functions were removed in TLC so we must remove it from code info as well
    codeInfo.OutputFunctions = [];
  %endif
  %if !IsModelReferenceRTWTarget() && SLibIsExportFcnDiagram() 
    %% %<SLibCreateModelFunctionInterface(componentObj, "Initialize", "")>
    %% %if UsingMalloc
    %%   %% Create Allocation function interface
    %%  %<SLibCreateModelFunctionInterface(componentObj, "Registration", "")>
    %% %endif
    tmpArgs         = [];
    tmpActualArgs   = [];
    tmpRet          = coder.types.Argument.empty;
    tmpActualReturn = RTW.DataInterface.empty;
    %<AddFunctionCallInputInformation(componentObj)>
    %<AddExternalInportMappingInfo(expInportsObj)>
  %endif
  %if IsModelReferenceRTWTarget()
    %<SLibCreateModelReferenceFunctionInterfaces(componentObj)>
    %<AddExternalInportMappingInfo(expInportsObj)>
    for i=1 : length(codeInfo.OutputFunctions)
       codeInfo.OutputFunctions(i).Owner = codeInfo.InternalData(1).Implementation;
    end
  %elseif NumRuntimeExportedRates > 1 && SLibIsPeriodicRateGrouping() && !SLibIsExportFcnDiagram() %% multi rate
    fcnVec = [];
    %foreach tid = NumRuntimeExportedRates
      %if (tid==1) && FixedStepOpts.TID01EQ
        %continue
      %endif
     
      %assign timeObj = SLibGetRTWTimingObject(tid)
      fcnTemp = codeInfo.OutputFunctions(1);      
      tmpImpl = coder.types.Prototype;
      tmpImpl.Name = [fcnTemp.Prototype.Name,'%<tid>'];
      tmpImpl.HeaderFile = fcnTemp.Prototype.HeaderFile;
      tmpImpl.SourceFile = fcnTemp.Prototype.SourceFile;
      tmpFcn = RTW.FunctionInterface;
      tmpFcn.Prototype = tmpImpl;
      tmpFcn.Timing = %<timeObj>;
      tmpFcn.Owner = fcnTemp.Owner;
      fcnVec = [fcnVec, tmpFcn];
    %endforeach  
    %% depending on the fix of g758487, the wrapper step function may or may not present
    codeInfo.OutputFunctions = fcnVec;
  %endif
  %if !SLibAutosarActive()
    %% Add reset function into output functions vector for non-AUTOSAR
    %% targets, for the GenerateClassInterface case.
    %foreach tid = NumSampleTimes
      %if SLibResetOrResetWithInitEventTID(tid)
        %<SLibCreateModelFunctionInterface(componentObj, "OutputUpdate", tid)>
      %endif
    %endforeach
  %endif
%endif

%% Add Simulink functions info. For AUTOSAR, the Simulink functions are 
%% treated as runnables and added in SLibCreateRunnables.
%if !(IsModelReferenceSimTarget())
  %<AddSimulinkFunctionInfo(componentObj)>
%endif

%% Updates output function interface codeInfo for reused IO arguments
%% in terms of function prototype control 
%if GenerateClassInterface || SLibFcnProtoCtrlActive()
  %<UpdateReusableArgsCodeInfoByFPC(componentObj)>
%endif

%% if the root system has any CoderDataGroups, it is not using the alloc function
%% and the code is reusable then add the required DataGroup info to the InternalData
%if !LibCoderDataGroupStructsAreEmpty() && !UsingMalloc && SLibMultiInstance()
  %% add RTModel/self if not already part of InternalData
  %if !SLibAutosarActive() && !GenerateClassInterface
    %assign rtMType    = FcnGetInternalTypeObj("RTModel", ::tSimStructType, "")
    %assign rtMPtrType = FcnGetPointerTypeObj(rtMType, 1, 0)
    
    %if SLibAutosarActive()
      %<rtMType>.Name = '%<::CompiledModel.GlobalScope.tSimStructTypeTag>';
    %endif
    %% Create a RTW.DataInterface object
    %assign rtmTgtVarObj  = ...
      SLibGetRTWVariableObject("RTModel", rtMType,"%<::tSimStruct>_", "", "", "")
    %assign rtmVarObj  = ...
      SLibGetRTWPointerVariableObject("RTModel", rtMPtrType,"%<::tSimStruct>", rtmTgtVarObj)
    %% Add it to InternalData if not already there (e.g. self in th SLfunction case)
    %assign rtmDataObj = ...
      FcnGetInternalDataObject("RTModel", "", "RTModel", rtmVarObj, [])
  %endif

  %% Add CoderDataGroups to CodeInfo InternalData
  %foreach idx = ::CompiledModel.NumCoderDataGroups
    %assign group = ::CompiledModel.CoderDataGroup[idx]
    %assign groupNeeded = SLibHaveRootDataGroupVarGroup(group) && ...
      (group.AsStructure == "InParent") && !SLibIsGroupSelfCoderGroup(group)
    %% does the root system have a non-empty VarGroup matching the current group?
    %% is it referenced by rtM/self? is it rtM/self?
    %if groupNeeded
      %assert EXISTS(rtmVarObj) || GenerateClassInterface
      %assign typeObjName = group.Name + "Type"
      %assign groupType = FcnGetInternalTypeObj(typeObjName, SLibCoderDataGroupType(group), "")
      %assign groupPtrType = FcnGetPointerTypeObj(groupType, 0, 0)
	  %assign groupInstance = SLibCoderDataGroupInstance(group)
      %assign groupVarId = "rt_" + group.Name
      %assign groupVar = "Var_" + groupVarId
      %assign instanceStrId = "'" + groupInstance + "'"
      %% if InternalData already contains a TypedRegion for this group we 
      %% don't need to create a new one and thePointerExpression needs to 
      %% point to the existing region.
      %% search the existing InternalData for a matching implentation
      group_var_exists = 0;
      for idx = 1:numel(codeInfo.InternalData)
        curr_var = codeInfo.InternalData(idx).Implementation;
        if isa(curr_var,'RTW.Variable') && strcmp(curr_var.Identifier, %<instanceStrId>)
           group_var_exists = 1;
           break;
        end
      end

      if group_var_exists
          %<groupVar> = curr_var;
      else
          %assign groupVar = ...
              SLibGetRTWVariableObject(groupVarId, groupType, groupInstance, "","","")
      end
      %assign desc = "Storage class " + group.Name
      %if !SLibAutosarActive() && !GenerateClassInterface
        %% create a RTW.PointerExpression for the group 
        %assign groupPtrExpr = ...
          FcnCreateRTMMemberObject(groupVarId, SLibCoderDataGroupRTMFieldName(group), ...
          groupPtrType, rtmVarObj, groupVar)
        %assign groupDataObj =  ...
          FcnGetInternalDataObject(groupVarId, "", desc, groupPtrExpr, []) 
      %else
        %assign groupdDataObj =  ...
          FcnGetInternalDataObject(groupVarId, "", desc, groupVar, [])
      %endif
    %endif
  %endforeach
%endif

if ~isempty(skippedParameters)
codeInfo.Parameters(skippedParameters) = [];
end

%% Writing out internal data
%assign internalData = FIELDNAMES(CodeInfoMap.InternalDataMap)
%foreach idx = SIZE(internalData,1)
  %if (idx == 0)
%<componentObj>.InternalData = [%<componentObj>.InternalData, %<internalData[idx]>];
  %else
%<componentObj>.InternalData(end+1) = %<internalData[idx]>;
  %endif
%endforeach

%assign comment = "% Handling Right-Click Builds"
%<comment>
ss = rtwprivate('getSourceSubsystemHandle',codeInfo.GraphicalPath);
%assign comment = "% Check if Rt-Click build, then re-map SIDs"
%<comment>
if ~isempty(ss) && rtwprivate('rtwattic','hasSIDMap')
   codeInfo = modifyCodeInfoForSubsystemBuild(ss, codeInfo);
end

fr.writeFunctionInterfaces(%<componentObj>);
fr.writeServerCallPoints(%<componentObj>);

%assign lookupTableArray = SLibCreateLookupTableInfo()
%if !IsModelReferenceTarget()
  if exist('%<expInportsObj>', 'var')
    save codeInfo.mat %<componentObj> %<expInportsObj> %<lookupTableArray>;
  else
    save codeInfo.mat %<componentObj> %<lookupTableArray>;
  end
%else
  %assert IsModelReferenceRTWTarget() || (IsModelReferenceSimTarget())
  if exist('%<expInportsObj>', 'var')
      save %<::CompiledModel.Name>_mr_codeInfo.mat %<componentObj> %<expInportsObj>;
  else
      save %<::CompiledModel.Name>_mr_codeInfo.mat %<componentObj>;
  end
%endif
returnVal = 1;

%assign comment = "% End Function"
%<comment>: %<fcnName>

function data = %<uniquifyDataInterfaces>(list)
  data = RTW.DataInterface.empty;
  for idx=1:numel(list)
      if ~isPresentDI(data, list(idx))
          data(end+1) = list(idx); %#ok<AGROW>
      end
  end
%<comment>: %<uniquifyDataInterfaces>
        
function isPresent = isPresentDI(list, di)
  isPresent = false;
  for idx = 1:numel(list)
    if isequal(list(idx), di)
      isPresent = true;
      break
    end
  end

function idx = %<timingSubfcnName>(internalIdVec, internalId)
 idx = find(internalIdVec == internalId);
 if (isempty(idx) || (length(idx) > 1))
    ciMsg = 'Time object cannot be empty'; 
    ciExc = MException('RTW:buildProcess:CodeInfoInternalError',ciMsg);
    throw(ciExc);
  end
%<comment>: %<timingSubfcnName>

function %<nameChkfcnName>(ciName, rtwName)
  if (strcmp(ciName, rtwName) ~= 1)
    ciMsg = ['Name mismatch: ', ciName, ' and ', rtwName]; 
    ciExc = MException('RTW:buildProcess:CodeInfoInternalError',ciMsg);
    throw(ciExc);
  end
%<comment>: %<nameChkfcnName>

function iData = %<iDataSubfcnName>(iDataVec, iDataName)
 iData = RTW.DataInterface.empty;
 for idxData = 1:numel(iDataVec)
    if strcmp(iDataName, iDataVec(idxData).GraphicalName)
       iData(end+1) = iDataVec(idxData);
       break
    end
 end
 if (isempty(iData) || (length(iData) > 1))
    ciMsg = 'Internal Data object cannot be empty'; 
    ciExc = MException('RTW:buildProcess:CodeInfoInternalError',ciMsg);
    throw(ciExc);
  end
%<comment>: %<iDataSubfcnName>

function iData = %<iDataSubfcnVariableName>(iDataVec, iDataVariableName)
 iData = RTW.DataInterface.empty;
 for idxData = 1:numel(iDataVec)
    if strcmp(iDataVariableName, iDataVec(idxData).Implementation.VariableName)
       iData = iDataVec(idxData);
       break
    end
 end
 if isempty(iData)
    ciMsg = 'Internal Data object cannot be empty'; 
    ciExc = MException('RTW:buildProcess:CodeInfoInternalError',ciMsg);
    throw(ciExc);
  end
%<comment>: %<iDataSubfcnVariableName>

function paramIndex = %<paramIndexFcnName>(iParamVec, graphicalName)
  paramIndex = [];
  for idxData = 1:numel(iParamVec)
    if strcmp(graphicalName, iParamVec(idxData).GraphicalName)
       paramIndex = idxData;
       break
    end
  end
%<comment>: %<paramIndexFcnName>

function codeInfo = modifyCodeInfoForSubsystemBuild(ss, codeInfo)
%if rightClickBuildFeature==0
%assign comment = "% Extract Subsystem Build Map from AtticData"
%<comment>
    Subsystem_Build_Mapping = rtwprivate('rtwattic','getSIDMap');

%assign comment = "% Parameters"
%<comment>
    for i = 1:length(codeInfo.Parameters)
        sid = codeInfo.Parameters(i).SID;        

        sid = Simulink.ID.getSubsystemBuildSID(sid,ss, Subsystem_Build_Mapping);
        codeInfo.Parameters(i).SID = sid;        
    end

%assign comment = "% Data Stores"
%<comment>
     for i = 1:length(codeInfo.DataStores)
         sid = codeInfo.DataStores(i).SID;         

         sid = Simulink.ID.getSubsystemBuildSID(sid,ss, Subsystem_Build_Mapping);
         codeInfo.DataStores(i).SID = sid;
     end

%assign comment = "% Inports"
%<comment>
    for i = 1:length(codeInfo.Inports)
        sid = codeInfo.Inports(i).SID;

        sid = Simulink.ID.getSubsystemBuildSID(sid,ss, Subsystem_Build_Mapping);
        codeInfo.Inports(i).SID = sid;
    end

%assign comment = "% Outports"
%<comment>
    for i = 1:length(codeInfo.Outports)
        sid = codeInfo.Outports(i).SID;

        sid = Simulink.ID.getSubsystemBuildSID(sid,ss, Subsystem_Build_Mapping);
        codeInfo.Outports(i).SID = sid;
    end    
%endif

%closefile ModelCI

%endif  %% _CIINFO_

%% [EOF] codeinfo.tlc
