%% ============================================================================
%% 
%%  
%% 
%% Copyright 2003-2018 The MathWorks, Inc.
%%
%% Function: HandleModelrefConstBIOAndPrm =====================================
%% Dump const block IO and parameters for model reference
%%
%function ModelrefHandleConstBIOAndPrm()  void
  %% --------------------------------------------------------------------------
  %% SimulinkGlobal parameters:
  %% - Declaration done by standard data buffering mechanism (must be unstructured)
  %% - Instantiation done as part of model reference SFcn / top model.
  %assert( SLibAreSimulinkGlobalParamsUnstructured() || IsModelReferenceInlineOffTarget())

  %assign baseSystem = ::CompiledModel.System[GetBaseSystemIdx()]
  
  %% We should not generate the static rtP structure if we are
  %% generating Encapsulated C++ code, because the model class
  %% already has the rtP structure as its member.
  %if IsModelReferenceTarget() && ...
      !( GenerateClassInterface && ::CompiledModel.ParametersInRTMForMultiInstanceERT ) 
    
    %if !SLibPrmBufferIsEmpty("SimulinkGlobal", "Instance")
      %openfile dataBuf
      %assign paramsType = ::tParametersType
      %if !GenerateClassInterface
        %assign paramsStaticName = ...
          FcnSysVarGroupNonreusedName(baseSystem,"Parameter")
      %else
        %assign oldStrNames = SLibGetOldStrNames()
        %assign paramsStaticName = ...
                    SLibGetPrmsName(oldStrNames)
      %endif
      %assign classNamePrefix = ""
      %if GenerateClassInterface
        %if !ISEMPTY(::NamespaceName)
          %assign classNamePrefix = ::NamespaceName + "::" + ::CPPClassName + "::"
        %else
          %assign classNamePrefix = ::CPPClassName + "::"
        %endif
      %endif      
      %<paramsType> %<classNamePrefix>%<paramsStaticName> = {
             %<SLibGetPrmBuffer("SimulinkGlobal", "Instance")>
       };\
       %closefile dataBuf
       %<SLibCacheCodeToFile("mdl_data_defn", dataBuf)>
       %assign prmExternDecl = GetHideChildDefineSymbol("ifndef") + "\n" + ...
         "extern " + paramsType + " " + paramsStaticName + ";\n" + ...
         GetHideChildDefineSymbol("endif")       
       %<SLibCacheCodeToFile("mdl_priv_extern_data_decl", prmExternDecl)>
     %endif 

   %endif
  %% --------------------------------------------------------------------------
  %% Const parameters:
  %%   structure definition: goes to private file
  %%   instantiation:        goes to data file
  %%   extern declaration:   goes to private file
  %%   init (if applicable): goes to mdl_init function (in model.c)

  %% Structure definitions (typedefs)
  %openfile constPrmDef
  %if !SLibPrmBufferIsEmpty("Const", "Typedef")

    /* Constant parameters (%<::AutoOrDefaultStorageClass> storage) */
    %<SLibGetPrmBuffer("Const", "Typedef")>\
  %endif
  %%
  %if !SLibPrmBufferIsEmpty("ConstWithInit", "Typedef")
    
    /* Constant parameters with dynamic initialization (%<::AutoOrDefaultStorageClass> storage) */
    %<SLibGetPrmBuffer("ConstWithInit", "Typedef")>\
  %endif
  %closefile constPrmDef
  %if !WHITE_SPACE(constPrmDef)
    %<SLibCacheCodeToFile("mdl_priv_constParam_typedef", constPrmDef)>
  %endif
  
  %% Instantiation
  %openfile constPrmInst
  %if !SLibPrmBufferIsEmpty("Const", "Instance")
    /* Constant parameters (%<::AutoOrDefaultStorageClass> storage) */
    %<SLibGetPrmBuffer("Const", "Instance")>
  %endif
  %%
  %if !SLibPrmBufferIsEmpty("ConstWithInit", "Instance")

    /* Constant parameters with dynamic initialization (%<::AutoOrDefaultStorageClass> storage) */
    %<SLibGetPrmBuffer("ConstWithInit", "Instance")>
  %endif
  %closefile constPrmInst
  %if !WHITE_SPACE(constPrmInst)
    %<SLibCacheCodeToFile("mdl_constParam_with_initialization", constPrmInst)>
  %endif
  
  %% Extern declarations
  %assign constPrmDecl = GetConstPrmExternBuf()
  %assign constPrmDecl = constPrmDecl + GetConstPrmWithInitExternBuf()
  %if !WHITE_SPACE(constPrmDecl)
    %if SLibIsCompactFileFormat()    
      %assign constPrmDecl = GetHideChildDefineSymbol("ifndef") + "\n" + ...
        constPrmDecl + "\n" + GetHideChildDefineSymbol("endif")       
    %endif
    %<SLibCacheCodeToFile("mdl_priv_constParam_decl", constPrmDecl)>
  %endif
  
  %% --------------------------------------------------------------------------
  %% Const Block I/O 
  %%    structure definition:  goes to system header files (handled in 
  %%                           other places). 
  %%                           ModelrefCleanup: This structure
  %%                           should go to private file
  %%    Instance:              goes to data file
  %%    Extern declration:     goes to private file
  %%                           model reference s-function wrapper
  %%
  
  %% Instance
  %openfile cioBuf
  %if !LibConstBlockIOInstanceIsEmpty()
    /* Invariant block signals (%<::AutoOrDefaultStorageClass> storage) */
    %assign qualifiers = SLibGetConstBlockIOQualifiers()
    %<qualifiers> %<FcnSysVarGroupType(baseSystem,"ConstBlockIO")> %<::tConstBlockIOStruct> = {
      %<LibDumpConstBlockIOInstance()>
    };
  %endif
  %closefile cioBuf
  
  %% dump info in data file
  %if !WHITE_SPACE(cioBuf) 
    %<SLibCacheCodeToFile("data_constBIO_decl", cioBuf)>
  %endif

  %% Extern declration
  %assign cBIOExtBuf = GetConstBIOExternBuf()
  %if !WHITE_SPACE(cBIOExtBuf)
    %if SLibIsCompactFileFormat()    
      %assign cBIOExtBuf = GetHideChildDefineSymbol("ifndef") + "\n" + ...
        cBIOExtBuf + "\n" + GetHideChildDefineSymbol("endif")       
    %endif
    %<SLibCacheCodeToFile("mdl_priv_extern_data_decl", cBIOExtBuf)>
  %endif
  
  %% Structure data type zero representations
  %assign defGndBuf = LibDumpGroundDeclarations(0)
  %<SLibCacheCodeToFile("data_ground_defn", defGndBuf)>

%endfunction %% ModelrefHandleConstBIOAndPrm


%% Function: ModelrefHandleRTModel ============================================
%%  For model reference rtModel typedef goes to top model header file,
%%  and rtModel macros goes to private file.
%%  This may need to be updated when we support continuous states
%%
%function ModelrefHandleRTModel()  void
  
  %assert(IsModelReferenceTarget() && GenRTModel)  
  
  %% --------------------------------------------------------------------------
  %% rtModel typedef 
  %openfile rtmTypedefs
  %assign rtmTypedefsStr = RTMGenRtMdlTypedef()
  %if !WHITE_SPACE(rtmTypedefsStr)
    %<GetHideChildDefineSymbol("ifndef")>
    %<rtmTypedefsStr>
    %<GetHideChildDefineSymbol("endif")>
  %endif
  %closefile rtmTypedefs
  %<SLibCacheCodeToFile("data_rtmodel_typedef", rtmTypedefs)>
  %undef rtmTypedefs

  %% --------------------------------------------------------------------------
  %% rtModel macros
  %openfile rtmMacros
  
  %assign rtmMacrosStr = RTMGenMacroDefines("PUBLIC")
  %if !WHITE_SPACE(rtmMacrosStr)
    /* Macros for accessing real-time model data structure */
    %<rtmMacrosStr>
  %endif
  %closefile rtmMacros
  %<SLibCacheCodeToFile("mdl_priv_rtm_macro_define", rtmMacros)>
  %undef rtmMacros
  
  
  %% Opaque type def goes to type file 
  %if !EmptyRealTimeObject
    %openfile opaqTypedefBuf
    %<RTMsGenOpaqueTypedef(::CompiledModel.System[NumSystems-1])>\
    %closefile opaqTypedefBuf
    %<SLibCacheCodeToFile("mdl_data_typedef", opaqTypedefBuf)>
  %endif

%endfunction %% ModelrefHandleRTModel


%% Function:  ModelrefDumpDataFileBannerAndInclude ============================
%% Added code to dump banner and include to data file.
%function ModelrefDumpDataFileBannerAndInclude() void
  %openfile dataBanBuf
  /*
  * %<Name>_data.%<LangFileExt>
  *
  %<SLibCommonHeaderInfo()>\
  */
  %closefile dataBanBuf
  
  
  %openfile inclBuf
  %assign fileName = SLibGetSystemOutputHdrFileBaseName(System[NumSystems-2])
  #include "%<fileName>.h"
  %<SLibIncludePrivateHeader()>
  %closefile inclBuf

  %<SLibCacheCodeToFile("mdldata_src_ban", dataBanBuf)>
  %<SLibCacheCodeToFile("mdldata_src_incl", inclBuf)>

%endfunction


%% Function: ModelrefGenSfcnAndHandleConstPrmAndBIO  ===========================
%%   Temporary function to dump model reference constant parameter, etc
%%
%function ModelrefGenSfcnAndHandleConstPrmAndBIO() void
  %% Only generate s-function wrapper for the model reference SIM target
  %if IsModelReferenceSimTarget()
    %include "modelrefsfcnbody.tlc"
  %endif
  
  %<ModelrefHandleConstBIOAndPrm()>

  %assign dataFile = SLibGetFileRecForCode("mdldata_src")
  %if !ISEMPTY(dataFile) && !SLibGetModelFileIsEmpty(dataFile)
    %<ModelrefDumpDataFileBannerAndInclude()>
    %if ERTCustomFileBanners
      %<LibSetSourceFileCodeTemplate(dataFile,ERTDataSrcFileTemplate)>
    %endif
  %endif
%endfunction


%% Function:  =======================================
%%   Temporary function to dump model reference constant parameter, etc
%%
%function ModelrefHandleExportFileInfo() void
  
  %openfile mdlRefRegFcn
  %if !SLibGetEmptyModelRefInitializeFcn()
  /* Model reference registration function */
  %if CGMODEL_ACCESS("CGModel.isIndividualFunctionMappingEnabled")
    %<SLibGetFcnMemSecPragmaForFunction(GetModelRefRegistrationFcnName(), "Initialize", "", "Pre")>\
  %else
    %<SLibGetFcnMemSecPragmaOnDecl(GetModelRefRegistrationFcnName(), "MemSecFuncInitTerm", "Pre")>\
  %endif
	
  %<LibExternInFcnDecls()>void %<GetModelRefRegistrationFcnName()>(%<SLibModelReferenceRegFcnArgs()>);
  
  %if CGMODEL_ACCESS("CGModel.isIndividualFunctionMappingEnabled")
    %<SLibGetFcnMemSecPragmaForFunction(GetModelRefRegistrationFcnName(), "Initialize", "", "Post")>\
  %else
    %<SLibGetFcnMemSecPragmaOnDecl(GetModelRefRegistrationFcnName(), "MemSecFuncInitTerm", "Post")>\
  %endif
  %endif
  
  %<LibDumpGroundExterns()>\
  %closefile mdlRefRegFcn
  
  %if !GenerateClassInterface
    %<SLibCacheCodeToFile("baseMdl_reg_fcn_prototype", mdlRefRegFcn)>
  %endif
  
  %<ModelrefHandleRTModel()>
%endfunction

%% [EOF] formatmodelref.tlc
